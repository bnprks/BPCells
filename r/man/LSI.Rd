% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singlecell_utils.R
\name{LSI}
\alias{LSI}
\alias{project.LSI}
\title{Perform latent semantic indexing (LSI) on a matrix.}
\usage{
LSI(
  mat,
  n_dimensions = 50L,
  corr_cutoff = 1,
  scale_factor = 10000,
  threads = 1L,
  verbose = FALSE
)

\method{project}{LSI}(x, mat, threads = 1L, ...)
}
\arguments{
\item{mat}{(IterableMatrix) Counts matrix of shape \verb{(features x cells)}.}

\item{n_dimensions}{(integer) Number of dimensions to keep during PCA.}

\item{corr_cutoff}{(numeric) Numeric filter for the correlation of a PC to the sequencing depth.  If the PC has a correlation that is great or equal to
the corr_cutoff, it will be excluded from the final PCA matrix.}

\item{scale_factor}{(numeric) Scaling factor to multiply matrix by prior to log normalization (see formulas below).}

\item{threads}{(integer) Number of threads to use.}

\item{x}{DimReduction object.}
}
\value{
An object of class \code{c("LSI", "DimReduction")} with the following attributes:
\itemize{
\item \code{cell_embeddings}: The projected data as a matrix of shape \verb{(n_dimensions, ncol(mat))}
\item \code{fitted_params}: A tibble of the parameters used for iterative LSI, with rows as iterations. Columns include the following:
\itemize{
\item \code{scale_factor}: The scale factor used for tf-idf normalization
\item \code{feature_means}: The means of the features used for normalization
\item \code{pcs_to_keep}: The PCs that were kept after filtering by correlation to sequencing depth
\item \code{feature_loadings}: SVD component u with dimension \verb{(n_variable_features, n_dimensions)}
}
\item \code{feature_names}: The names of the features in the matrix
}
}
\description{
Given a \verb{(features x cells)} counts matrix, perform LSI, which sequentially executes tf-idf normalization and PCA to create a latent space representation of the matrix of shape \verb{(n_dimensions, ncol(mat))}.
Returns a DimReduction object, which allows for projection of new matrices with the same features into the same latent space.
}
\details{
Compute LSI through first doing a log(tf-idf) transform, z-score normalization, then PCA.  Tf-idf implementation is from Stuart & Butler et al. 2019.

Running on a 2600 cell dataset with 50000 peaks and 4 threads, as an example:
\itemize{
\item 17.1 MB memory usage, 25.1 seconds runtime
}
}
\seealso{
\code{project()} \code{DimReduction()} \code{normalize_tfidf()}
}
