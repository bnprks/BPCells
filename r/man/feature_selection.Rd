% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singlecell_utils.R
\name{select_features_variance}
\alias{select_features_variance}
\alias{select_features_dispersion}
\alias{select_features_mean}
\alias{select_features_binned_dispersion}
\title{Feature selection functions}
\usage{
select_features_variance(
  mat,
  num_feats = 0.05,
  normalize_method = NULL,
  threads = 1L
)

select_features_dispersion(
  mat,
  num_feats = 0.05,
  normalize_method = NULL,
  threads = 1L
)

select_features_mean(
  mat,
  num_feats = 0.05,
  normalize_method = NULL,
  threads = 1L
)

select_features_binned_dispersion(
  mat,
  num_feats = 0.05,
  n_bins = 20,
  threads = 1L
)
}
\arguments{
\item{mat}{(IterableMatrix) Counts matrix with dimensions \verb{(features x cells)}.}

\item{num_feats}{(float) Number of features to mark as highly_variable. If 0 < \code{num_feats} < 1, then interpret as a fraction of features.}

\item{normalize_method}{(function) Used to normalize the matrix prior to feature selection by calling \code{normalize_method(mat)} if it is not \code{NULL}.
For example, pass \code{normalize_log()} or \code{normalize_tfidf()}.}

\item{threads}{(integer) Number of threads to use. Also overrides the threads argument in \code{normalize_method}}

\item{n_bins}{(integer) Number of bins to split features into in order to control for the relationship between mean expression and dispersion (see details).}
}
\value{
Return a dataframe with the following columns:
\itemize{
\item \code{feature}: Feature name.
\item \code{score}: Scoring of the feature, depending on the method used.
\item \code{highly_variable}: Logical vector of whether the feature is highly variable.
}

Each different feature selection method will have a different scoring method.
Consider a matrix \eqn{X}, where the row index \eqn{i} refers to each feature
and the column index \eqn{j} refers to each cell. For each feature \eqn{x_{i} \in X}, we define the following feature-selection scores:
\itemize{
\item \code{select_features_variance}: \eqn{\mathrm{Score}(x_i) = \frac{1}{n - 1} \sum_{j=1}^{n} \bigl(x_{ij} - \bar{x}_i\bigr)^2}
}

\itemize{
\item \code{select_features_dispersion}: \eqn{\mathrm{Score}(x_i) = \frac{\frac{1}{n - 1} \sum_{j=1}^{n} \bigl(x_{ij} - \bar{x}_i\bigr)^2}{\bar{x}_i}}
}

\itemize{
\item \code{select_features_mean}: \eqn{\mathrm{Score}(x_i) = \frac{\sum_{j=1}^{n}\bigl(x_{ij}\bigr)}{n}}
}

\itemize{
\item \code{select_features_binned_dispersion}: Process described in \code{details}.
}
}
\description{
Apply a feature selection method to a non-normalized \verb{(features x cells)} matrix.  We recommend using counts matrices as input and to
apply any normalizations prior to feature selection via the normalize argument (if available).
Instead of directly subsetting the input matrix,
an output dataframe is returned, indicating which features are highly variable, and the scoring of each feature.
}
\details{
\code{select_features_binned_dispersion} implements the approach from Satija et al. 2015:
\enumerate{
\item Bin features into equal-width bins by \code{log1p(mean)}
\item Calculate dispersion of each feature as \code{log(variance / mean)}
\item Z-score normalize dispersion within each bin, and select highest normalized dispersion across all bins
}

If the number of features within a bin is equal to 1, then the mean dispersion for that bin is set to 1.

This should be equivalent to \code{Seurat::FindVariableFeatures()} with \code{selection.method="mean.var.plot"}
and \code{scanpy.pp.highly_variable_genes()} with \code{flavor="seurat"}.
}
\examples{

## Prep data
set.seed(12345)
mat <- matrix(rpois(4*5, lambda=1), nrow=4, ncol=5)
rownames(mat) <- paste0("gene", seq_len(nrow(mat)))
mat
mat <- as(mat, "IterableMatrix")


#######################################################################
## select_features_variance() examples
select_features_variance(
    mat, 
    num_feats=2, 
    normalize_method=normalize_log
)

# Because of how the BPCells `normalize` functions behave when the matrix 
# argument is missing, we can also customize the normalization parameters using partial arguments:
variable_features <- select_features_variance(
    mat,
    num_feats=2,
    normalize_method=normalize_log(scale_factor=20)
) 
# One can then filter to only variable features using the subset operator:
mat[variable_features$feature[variable_features$highly_variable],]
#######################################################################
#######################################################################
## select_features_dispersion() example
select_features_dispersion(
  mat,
  num_feats = 2,
  normalize_method = normalize_log
)
#######################################################################
#######################################################################
## select_features_mean() example
select_features_mean(
  mat,
  num_feats = 2,
  normalize_method = normalize_log
)
#######################################################################
#######################################################################
## select_features_binned_dispersion() example
select_features_binned_dispersion(
  mat,
  num_feats = 2
  n_bins = 2
)
#######################################################################
}
\seealso{
\code{normalize_tfidf()} \code{normalize_log()}
}
