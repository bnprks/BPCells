% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singlecell_utils.R
\name{select_features_variance}
\alias{select_features_variance}
\alias{select_features_dispersion}
\alias{select_features_mean}
\alias{select_features_binned_dispersion}
\title{Feature selection functions}
\usage{
select_features_variance(
  mat,
  num_feats = 0.05,
  normalize = NULL,
  threads = 1L,
  verbose = FALSE
)

select_features_dispersion(
  mat,
  num_feats = 0.05,
  normalize = NULL,
  threads = 1L,
  verbose = FALSE
)

select_features_mean(
  mat,
  num_feats = 0.05,
  normalize = NULL,
  threads = 1L,
  verbose = FALSE
)

select_features_binned_dispersion(
  mat,
  num_feats = 25000,
  n_bins = 20,
  threads = 1L,
  verbose = FALSE
)
}
\arguments{
\item{mat}{(IterableMatrix) dimensions features x cells}

\item{num_feats}{(float) Number of features to return.  If the number given is between 0 and 1, treat as a proportion of
the number of rows, rounded down.  Otherwise, treat as an absolute number.
If the number is higher than the number of features in the matrix,
all features will be returned.}

\item{normalize}{(function) Normalize matrix using a given function. Normalization occurs on the input mat prior to feature
selection. If \code{NULL}, no normalization is performed. @seealso \code{normalize_tfidf()} \code{normalize_log()}}

\item{threads}{(integer) Number of threads to use.}

\item{n_bins}{(integer) Number of bins for binning mean gene expression.  Normalizing dispersion is done with respect to each bin,
and if the number of features within a bin is less than 2, the dispersion is set to 1.}
}
\value{
Return a dataframe with the following columns:
\itemize{
\item \code{names}: Feature name.
\item \code{score}: Scoring of the feature, depending on the method used.
\item \code{highly_variable}: Logical vector of whether the feature is highly variable.
}

Each different feature selection method will have a different scoring method.
For each element \eqn{x_{ij}} in matrix \eqn{X} with \eqn{i} features and \eqn{j} cells, determine the score of
each feature \eqn{x_i} as follows:
\itemize{
\item \code{select_features_by_variance}: \eqn{\mathrm{Score}(x_i) = \frac{1}{n - 1} \sum_{j=1}^{n} \bigl(x_{ij} - \bar{x}_i\bigr)^2}
}

\itemize{
\item \code{select_features_by_dispersion}: \eqn{\mathrm{Score}(x_i) = \frac{\frac{1}{n - 1} \sum_{j=1}^{n} \bigl(x_{ij} - \bar{x}_i\bigr)^2}{\bar{x}_i}}
}

\itemize{
\item \code{select_features_by_mean}: \eqn{\mathrm{Score}(x_i) = \bar{x}_i}
}

\itemize{
\item \code{select_features_binned_dispersion}: Process described in \code{details}.
}
}
\description{
Apply a feature selection method to a \verb{(features x cells)} matrix.
}
\details{
\code{select_features_binned_dispersion} implements the approach from Satija et al. 2015:
\enumerate{
\item Bin features into equal-width bins by \code{log1p(mean)}
\item Calculate dispersion of each feature as \code{log(variance / mean)}
\item Z-score normalize dispersion within each bin, and select highest normalized dispersion across all bins
}

This should be equivalent to \code{Seurat::FindVariableFeatures()} with \code{selection.method="mean.var.plot"}
and \code{scanpy.pp.highly_variable_genes()} with \code{flavor="seurat"}.
}
\examples{
set.seed(12345)
mat <- matrix(rpois(4*5, lambda=1), nrow=4, ncol=5)
rownames(mat) <- paste0("gene", seq_len(nrow(mat)))
mat

select_features_variance(
    mat, 
    num_feats=2, 
    normalize=normalize_log
)

# Because of how the BPCells normalize functions behave when the matrix 
# argument is missing, we can also customize the normalization parameters:
select_features_variance(
    mat,
    num_feats=2,
    normalize=normalize_log(scale_factor=20)
) 

}
