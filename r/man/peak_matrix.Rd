% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix.R
\name{peak_matrix}
\alias{peak_matrix}
\title{Calculate ranges x cells overlap matrix}
\usage{
peak_matrix(
  fragments,
  ranges,
  mode = c("insertions", "fragments", "overlaps"),
  zero_based_coords = !is(ranges, "GRanges"),
  explicit_peak_names = TRUE
)
}
\arguments{
\item{fragments}{Input fragments object. Must have cell names and chromosome names defined}

\item{ranges}{Peaks/ranges to overlap, given as GRanges, data.frame, or list. See \code{help("genomic-ranges-like")} for details on format and coordinate systems. Required attributes:
\itemize{
\item \code{chr}, \code{start}, \code{end}: genomic position
}}

\item{mode}{Mode for counting peak overlaps. (See "value" section for more details)}

\item{zero_based_coords}{Whether to convert the ranges from a 1-based end-inclusive
coordinate system to a 0-based end-exclusive coordinate system. Defaults to true
for GRanges and false for other formats
(see this \href{https://web.archive.org/web/20210920203703/https://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/}{archived UCSC blogpost})}

\item{explicit_peak_names}{Boolean for whether to add rownames to the output matrix in format e.g
chr1:500-1000, where start and end coords are given in a 0-based coordinate system.
Note that either way, peak names will be written when the matrix is saved.}
}
\value{
Iterable matrix object with dimension ranges x cells. When saved,
the column names of the output matrix will be in the format chr1:500-1000,
where start and end coords are given in a 0-based coordinate system.

\strong{\code{mode} options}
\itemize{
\item \code{"insertions"}: Start and end coordinates are separately overlapped with each peak
\item \code{"fragments"}: Like \code{"insertions"}, but each fragment can contribute at most 1 count
to each peak, even if both the start and end coordinates overlap
\item \code{"overlaps"}: Like \code{"fragments"}, but an overlap is also counted if the fragment fully
spans the peak even if neither the start or end falls within the peak
}
}
\description{
Calculate ranges x cells overlap matrix
}
\note{
When calculating the matrix directly from a fragments tsv, it's necessary to first call \code{select_chromosomes()} in order to
provide the ordering of chromosomes to expect while reading the tsv.
}
\examples{
## Prep demo data
frags <- tibble::tribble(
   ~chr, ~start, ~end, ~cell_id,
    "chr1", 0, 5, "cell1",
    "chr1", 2, 4, "cell2",
    "chr2", 3, 6, "cell1",
    "chr3", 7, 9, "cell2"
) \%>\% convert_to_fragments()
frags

# Note: this is how we would normally call peaks given this data
# We use a toy example here
# chrom_sizes <- read_ucsc_chrom_sizes(file.path(tempdir(), "references"), genome="hg38")
# blacklist <- read_encode_blacklist(file.path(tempdir(), "references"), genome="hg38")
# frags \%>\% select_regions(blacklist, invert_selection = TRUE)
# peaks <- call_peaks_tile(
#   frags_filter_blacklist, 
#   chrom_sizes,
#   effective_genome_size = 2.8e9
# )
peaks <- tibble::tribble(
  ~chr, ~start, ~end, ~group, ~p_val, ~q_val, ~enrichment,
 "chr1", 1, 4, "all", 0, 0, 767,
 "chr2", 2, 8, "all", 0, 0, 766,
 "chr3", 5, 10, "all", 0, 0, 645
)
peaks

# We would normally select the top peaks like this:
# peaks <- head(peaks, 5000)
# peaks <- peaks[order_ranges(peaks, chrNames(frags)),]

## Get peak matrix
peak_mat <- peak_matrix(frags, peaks, mode="insertions")
peak_mat

peak_mat \%>\% as("dgCMatrix")

}
