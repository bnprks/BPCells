% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix-svds-docs.R
\name{svds}
\alias{svds}
\title{Calculate svds}
\usage{
svds(A, k, nu = k, nv = k, opts = list(), threads=0L, ...)
}
\arguments{
\item{A}{The matrix whose truncated SVD is to be computed.}

\item{k}{Number of singular values requested.}

\item{nu}{Number of right singular vectors to be computed. This must be between \code{0} and \code{k}. (Must be equal to \code{k} for BPCells IterableMatrix)}

\item{opts}{Control parameters related to computing algorithm. See \emph{Details} below}

\item{threads}{Control threads to use calculating mat-vec producs (BPCells specific)}
}
\value{
A list with the following components:
\item{d}{A vector of the computed singular values.}
\item{u}{An \code{m} by \code{nu} matrix whose columns contain
the left singular vectors. If \code{nu == 0}, \code{NULL}
will be returned.}
\item{v}{An \code{n} by \code{nv} matrix whose columns contain
the right singular vectors. If \code{nv == 0}, \code{NULL}
will be returned.}
\item{nconv}{Number of converged singular values.}
\item{niter}{Number of iterations used.}
\item{nops}{Number of matrix-vector multiplications used.}
}
\description{
Use the C++ Spectra solver (same as RSpectra package), in order to
compute the largest k values and corresponding singular vectors.
Empirically, memory usage is much lower than using \code{irlba::irlba()}, likely
due to avoiding R garbage creation while solving due to the pure-C++ solver.
This documentation is a slightly-edited version of the \code{RSpectra::svds()}
documentation.
}
\details{
When RSpectra is installed, this function will just add a method to
\code{RSpectra::svds()} for the \code{IterableMatrix} class.

The \code{opts} argument is a list that can supply any of the
following parameters:

\describe{
\item{\code{ncv}}{Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. \code{ncv} must satisfy
\code{k < ncv <= p} where
\code{p = min(m, n)}.
Default is \code{min(p, max(2*k+1, 20))}.}
\item{\code{tol}}{Precision parameter. Default is \code{1e-10}.}
\item{\code{maxitr}}{Maximum number of iterations. Default is \code{1000}.}
\item{\code{center}}{Either a logical value (\code{TRUE}/\code{FALSE}), or a numeric
vector of length \code{n}. If a vector \code{c} is supplied, then
SVD is computed on the matrix \verb{A-1c'},
in an implicit way without actually forming this matrix.
\code{center = TRUE} has the same effect as
\code{center = colMeans(A)}. Default is \code{FALSE}. Ignored in BPCells}
\item{\code{scale}}{Either a logical value (\code{TRUE}/\code{FALSE}), or a numeric
vector of length \code{n}. If a vector \code{s} is supplied, then
SVD is computed on the matrix \verb{(A-1c')S},
where \code{c} is the centering vector and \code{S = diag(1/s)}.
If \code{scale = TRUE}, then the vector \code{s} is computed as
the column norm of \verb{A - 1c'}.
Default is \code{FALSE}. Ignored in BPCells}
}
}
\references{
Qiu Y, Mei J (2022). \emph{RSpectra: Solvers for Large-Scale Eigenvalue and SVD Problems}. R package version 0.16-1, \url{https://CRAN.R-project.org/package=RSpectra}.
}
