% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix.R
\name{tcrossprod_dense}
\alias{tcrossprod_dense}
\alias{crossprod_dense}
\alias{cov_dense}
\alias{cor_dense}
\title{Matrix correlation, covariance, or cross-product with dense output}
\usage{
tcrossprod_dense(x, ..., buffer_bytes = 5e+06, threads = 1L)

crossprod_dense(x, ..., buffer_bytes = 5e+06, threads = 1L)

cov_dense(x, ..., method = "pearson", buffer_bytes = 5e+06, threads = 1L)

cor_dense(x, ..., method = "pearson", buffer_bytes = 5e+06, threads = 1L)
}
\arguments{
\item{x}{(IterableMatrix) Input matrix. In general, disk-backed matrices should have cell-major storage ordering. (See details,
or \code{transpose_storage_order()})}

\item{...}{Reserved for potential future argument additions}

\item{buffer_bytes}{(integer) In-memory chunk size to use during computations. Performance is best when this is slightly below
the largest CPU cache size on the computer running BPCells.}

\item{threads}{(integer) Number of threads to use during execution. Thread counts higher than 4-8 may see diminishing speedups}

\item{method}{(character) Must be \code{"pearson"}. Provided for compatibility with \code{cov()} and \code{cor()} but otherwise ignored.}
}
\value{
Symmetric, square dense matrix. Results should match the base R \code{crossprod()}, \code{tcrossprod()}, \code{cov()}, and \code{cor()}.
}
\description{
These functions provide optimized versions of \code{tcrossprod()}, \code{crossprod()}, \code{cov()}, and \code{cor()} that take
BPCells matrices as inputs and produce dense matrix outputs. These functions will run more quickly than
combining multiple BPCells operations to produce equivalent output.
They are mainly recommended for sparse \verb{cell x feature} matrices with ~10k features or fewer,
since compute and memory costs will rise with the square of the number of features (see details).

Note that the input matrix orientation is \verb{cell x feature} rather than the standard R single cell convention
of \verb{feature x cell} in order to provide consistency with the builtin \code{cor()} and \code{cov()} functions. It will
be necessary to pass \code{t(mat)} as the first argument in many cases.
}
\details{
\strong{Input storage order}

The input matrix must be row-major for \code{crossprod_dense()}, \code{cor_dense()}, and \code{cov_dense()}.
For \code{tcrossprod_dense()}, the input must be col-major. Stated another way: when these functions are used to calculate
feature correlations, the cell axis should always be the major axis. The functions will raise an error if
the input requires running \code{transpose_storage_order()} to switch to the required storage order.

\strong{Efficiency considerations}

These functions require only 1 or 2 matrix passes, so they will run much faster than using \code{\%*\%} to perform
disk-backed sparse-sparse matrix multiplies.

The memory required for the output matrix scales with the square of the feature count and the computational
work scales with the square of the number of non-zero entries per feature. So in typical cases running with
20k features will take 100x the time and memory compared to 2k features. Correlation of 2k features from
1.3M cells should take under 1 minute single-threaded, and under 15 seconds with 8 threads.
}
\examples{
set.seed(12345)
base_r_mat <- matrix(rpois(3*5, lambda=1), nrow=3, ncol=5)
rownames(base_r_mat) <- paste0("row", 1:3)
base_r_mat

mat <- as(base_r_mat, "IterableMatrix")

tcrossprod_dense(mat)

all.equal(tcrossprod_dense(mat), tcrossprod(base_r_mat))
all.equal(crossprod_dense(t(mat)), crossprod(t(base_r_mat)))
all.equal(cov_dense(t(mat)), cov(t(base_r_mat)))
all.equal(cor_dense(t(mat)), cor(t(base_r_mat)))
}
