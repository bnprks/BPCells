% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/atac_utils.R
\name{call_peaks_tile}
\alias{call_peaks_tile}
\title{Call peaks from tiles}
\usage{
call_peaks_tile(
  fragments,
  chromosome_sizes,
  cell_groups = rep.int("all", length(cellNames(fragments))),
  effective_genome_size = NULL,
  peak_width = 200,
  peak_tiling = 3,
  fdr_cutoff = 0.01,
  merge_peaks = c("all", "group", "none")
)
}
\arguments{
\item{fragments}{IterableFragments object}

\item{chromosome_sizes}{Chromosome start and end coordinates given as GRanges, data.frame, or list. See \code{help("genomic-ranges-like")} for details on format and coordinate systems. Required attributes:
\itemize{
\item \code{chr}, \code{start}, \code{end}: genomic position
}

See \code{read_ucsc_chrom_sizes()}.}

\item{cell_groups}{Grouping vector with one entry per cell in fragments, e.g.
cluster IDs}

\item{effective_genome_size}{(Optional) effective genome size for poisson
background rate estimation. See \href{https://deeptools.readthedocs.io/en/develop/content/feature/effectiveGenomeSize.html}{deeptools}
for values for common genomes. Defaults to sum of chromosome sizes, which
overestimates peak significance}

\item{peak_width}{Width of candidate peaks}

\item{peak_tiling}{Number of candidate peaks overlapping each base of genome.
E.g. peak_width = 300 and peak_tiling = 3 results in candidate peaks of
300bp spaced 100bp apart}

\item{fdr_cutoff}{Adjusted p-value significance cutoff}

\item{merge_peaks}{How to merge significant peaks with \code{merge_peaks_iterative()}
\itemize{
\item \code{"all"} Merge the full set of peaks
\item \code{"group"} Merge peaks within each group
\item \code{"none"} Don't perform any merging
}}
}
\value{
tibble with peak calls and the following columns:
\itemize{
\item \code{chr}, \code{start}, \code{end}: genome coordinates
\item \code{group}: group ID that this peak was identified in
\item \code{p_val}, \code{q_val}: Poission p-value and BH-corrected p-value
\item \code{enrichment}: Enrichment of counts in this peak compared to a genome-wide
background
}
}
\description{
Calling peaks from a pre-set list of tiles can be much faster than using
dedicated peak-calling software like \code{macs3}. The resulting peaks are less
precise in terms of exact coordinates, but should be sufficient for most
analyses.
}
\details{
Peak calling steps:
\enumerate{
\item Estimate the genome-wide expected insertions per tile based on
\code{peak_width}, \code{effective_genome_size}, and per-group read counts
\item Tile the genome with nonoverlapping tiles of size peak_width
\item For each tile and group, calculate p_value based on a Poisson model
\item Compute adjusted p-values using BH method and using the total number of
tiles as the number of hypotheses tested.
\item Repeat steps 2-4 \code{peak_tiling} times, with evenly spaced offsets
\item If \code{merge_peaks} is "all" or "group": use \code{merge_peaks_iterative()} within each group to keep only the most
significant of the overlapping candidate peaks
\item If \code{merge_peaks} is "all", perform a final round of \code{merge_peaks_iterative()},
prioritizing each peak by its within-group significance rank
}
}
\examples{
## Prep data
reference_dir <- file.path(tempdir(), "references")
frags <- get_demo_frags() 
## Remove blacklist regions from fragments
blacklist <- read_encode_blacklist(reference_dir, genome="hg38")
frags_filter_blacklist <- select_regions(frags, blacklist, invert_selection = TRUE)
chrom_sizes <- read_ucsc_chrom_sizes(reference_dir, genome="hg38") \%>\% dplyr::filter(chr \%in\% c("chr4", "chr11"))


## Call peaks
call_peaks_tile(frags_filter_blacklist, chrom_sizes, effective_genome_size = 2.8e9)
}
