% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singlecell_utils.R
\name{IterativeLSI}
\alias{IterativeLSI}
\title{Run iterative LSI on a matrix.}
\usage{
IterativeLSI(
  mat,
  n_iterations = 2,
  first_feature_selection_method = select_features_binned_dispersion,
  feature_selection_method = select_features_dispersion,
  lsi_method = LSI,
  cluster_method = cluster_graph_leiden,
  threads = 1L,
  verbose = FALSE
)
}
\arguments{
\item{mat}{(IterableMatrix)}

\item{n_iterations}{(int) The number of LSI iterations to perform.}

\item{first_feature_selection_method}{(function) Method to use for selecting features for the first iteration. Current builtin options are \code{select_features_variance}, \code{select_features_dispersion}, \code{select_features_mean}, \code{select_features_binned_dispersion}}

\item{feature_selection_method}{(function) Method to use for selecting features for each iteration after the first. Current builtin options are \code{select_features_variance}, \code{select_features_dispersion}, \code{select_features_mean}, \code{select_features_binned_dispersion}}

\item{lsi_method}{(function) Method to use for LSI.  Only \code{LSI} is allowed.  The user can pass in partial parameters to \code{LSI} to customize the LSI method, such as by passing \code{LSI(n_dimensions = 30, corr_cutoff = 0.5)}.}

\item{cluster_method}{(function) Method to use for clustering. Current builtin options are \verb{cluster_graph_\{leiden, louvain, seurat\}()}}

\item{threads}{(integer) Number of threads to use.}
}
\value{
An object of class \code{c("IterativeLSI", "DimReduction")} with the following attributes:
\itemize{
\item \code{cell_embeddings}: The projected data
\item \code{fitted_params}: A tibble of the parameters used for iterative LSI, with rows as iterations. Columns include the following:
\item \code{first_feature_selection_method}: The method used for selecting features for the first iteration
\item \code{lsi_method}: The method used for LSI
\item \code{cluster_method}: The method used for clustering
\item \code{feature_means}: The means of the features used for normalization
\item \code{iterations}: The number of iterations
\item \code{iter_info}: A tibble with the following columns:
\itemize{
\item \code{iteration}: The iteration number
\item \code{feature_names}: The names of the features used for the iteration
\item \code{lsi_results}: The results of LSI for the iteration.  This follows the same structure as the \code{fitted_params} attribute of the \code{LSI} object, but information such as the \code{v} and \code{d} matrices are removed.
\item \code{clusters}: The clusters for the iteration.  This is blank for the first iteration
}
}
}
\description{
Given a \verb{(features x cells)} matrix, Compute an iterative LSI dimensionality reduction, using the method described in \href{https://doi.org/10.1038/s41588-021-00790-6}{ArchR} (Granja et al; 2019).
}
\details{
The iterative LSI method is as follows:
\itemize{
\item First iteration:
\itemize{
\item Select features based on the \code{first_feature_selection_method} argument
\item Perform LSI on the selected features
\item If \code{n_iterations} is 1, return the PCA results
\item Else, cluster the LSI results using \code{cluster_method}
}
\item For each subsequent iteration:
\itemize{
\item Pseudobulk the clusters and select the top features based on the variance of the pseudobulked clusters
\item Perform LSI on the selected features
\item If this is the final iteration, return the PCA results
\item Else, cluster the LSI results using \code{cluster_method}
}
}
}
\seealso{
\code{LSI()}, \code{feature_selection}, \code{DimReduction()}
}
