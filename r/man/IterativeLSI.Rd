% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singlecell_utils.R
\name{IterativeLSI}
\alias{IterativeLSI}
\alias{project.IterativeLSI}
\title{Run Iterative LSI on a matrix.}
\usage{
IterativeLSI(
  mat,
  n_iterations = 2,
  feature_selection_method = select_features_variance,
  scale_factor = 10000,
  n_dimensions = 50L,
  corr_cutoff = 1,
  cluster_method = cluster_cells_graph,
  threads = 1L,
  verbose = FALSE
)

\method{project}{IterativeLSI}(x, mat, iteration = x$fitted_params$iterations, threads = 1L, ...)
}
\arguments{
\item{mat}{(IterableMatrix) Counts matrix of shape \verb{(features x cells)}.}

\item{n_iterations}{(int) The number of LSI iterations to perform.}

\item{feature_selection_method}{(function) Method to use for selecting features for LSI.
Current builtin options are \code{select_features_variance}, \code{select_features_dispersion}, \code{select_features_mean}, \code{select_features_binned_dispersion}}

\item{scale_factor}{(numeric) Scaling factor to multiply matrix by during tf-idf normalization.}

\item{n_dimensions}{(integer) Number of dimensions to keep during PCA.}

\item{corr_cutoff}{(numeric) Numeric filter for the correlation of a PC to the sequencing depth.  If the PC has a correlation that is greater or equal to
the corr_cutoff, it will be excluded from the final PCA matrix.}

\item{cluster_method}{(function) Method to use for clustering the post-SVD matrix.
The user can pass in partial parameters to the cluster method, such as by passing
\code{cluster_cells_graph(mat, graph_to_cluster_method = cluster_graph_louvain(resolution = 0.5))} into \code{cluster_method}.}

\item{threads}{(integer) Number of threads to use.  Also gets passed down into \code{feature_selection_method} and \code{cluster_method}}

\item{x}{DimReduction object.}

\item{iteration}{(integer) Which iteration of \code{IterativeLSI}'s features and loadings to use for projection.}
}
\value{
\code{IterativeLSI()} An object of class \code{c("IterativeLSI", "DimReduction")} with the following attributes:
\itemize{
\item \code{cell_embeddings}: The projected data as a matrix of shape \verb{(cells, n_dimensions)}
\item \code{fitted_params}: A list of the parameters used for iterative LSI.  Includes the following:
\itemize{
\item \code{lsi_method}: The method used for LSI
\item \code{feature_selection_method}: The method used for selecting features
\item \code{cluster_method}: The method used for clustering
\item \code{feature_means}: The means of the features used for tf-idf normalization
\item \code{iterations}: The number of LSI iterations ran
\item \code{iter_info}: A tibble of iteration info with rows as iterations. Columns include the following:
\itemize{
\item \code{iteration}: The iteration number
\item \code{feature_names}: The names of the features used for the iteration
\item \code{feature_loadings}: SVD component \code{u} with dimension \verb{(n_dimensions, n_variable_features)}
\item \code{pcs_to_keep}: The PCs that were kept after filtering by correlation to sequencing depth
\item \code{clusters}: The clusters for the iteration.  This is blank for the first iteration
}
}
}

\code{project()} Matrix of the projected data of shape \verb{(cells, n_dimensions)}.
}
\description{
Given a \verb{(features x cells)} counts matrix, perform IterativeLSI to create a latent space representation of the matrix of shape \verb{(n_dimensions, ncol(mat))}.
This uses the method described in \href{https://doi.org/10.1038/s41588-021-00790-6}{ArchR} (Granja et al; 2019).
See details for more specific information.  Returns a DimReduction object, which allows for projection of matrices with the same features into the same latent space.
}
\details{
The Iterative LSI method is as follows:
\itemize{
\item First iteration:
\itemize{
\item Select features using \code{feature_selection_method}
\item Perform LSI on the selected features
\item If \code{n_iterations} is 1, return the projected data from the first PCA projection
\item Else, cluster the LSI results using \code{cluster_method}
}
\item For each subsequent iteration:
\itemize{
\item Pseudobulk the clusters from the previous iteration and select the top features based on the pseudobulked clusters
\item Perform LSI on the selected features
\item If this is the final iteration, return the projected data from this PCA projection
\item Else, cluster the LSI results using \code{cluster_method}
}
}

There are some minor differences when compared to the ArchR implementation:
\itemize{
\item ArchR binarizes data prior to feature selection.  To replicate this, the user can pass \code{select_features_variance(normalize=binarize)} for their \code{feature_selection_method}.
\item \code{IterativeLSI()} currently does not support utilization of different feature selection methods across each iteration.
If one desires to use a different feature selection method for each iteration, they can take the cluster assignments from the previous
iteration and use them to select features and run LSI.
\item ArchR uses a default of 25000 features picked during feature selection. As the number of input features is dependent on the input matrix fed into \code{IterativeLSI()},
the default for \code{select_features_variance()} instead picks the number of variable features as a proportion of the total features provided.  To mimic the ArchR implementation,
\code{feature_selection_method} can be set to \code{select_features_variance(num_feats = 25000)}.
\item ArchR calculates LSI during non-terminal iterations using a default subset of 10000 cells.  ArchR does this to prevent a memory bottleneck,
which BPCells does not encounter even with a non-subsetted matrix. Therefore, IterativeLSI will run LSI on the entire matrix for each iteration.
\item ArchR defaults on using Seurat clustering for default, which utilizes the Louvain algorithm (See \code{Seurat::FindClusters()}).  In constrast, \code{IterativeLSI()} utilizes
leiden, which should provide the same clustering results while being faster.
\item ArchR also plots and calculates a umap of every iteration's dimensionality reduction.  While this is not implemented in \code{IterativeLSI()},
one can use the \code{project()} method with the \code{iteration} argument set to the desired iteration to get projected data.  This can then be fed into \code{uwot::umap()}
\item ArchR filters out PCs with a correlation to sequencing depth greater than 0.75.
While corr_cutoff is provided as an argument in \code{IterativeLSI()}, it is set to not removing any PCs by default.
\item ArchR filters out outliers dependent on number of accesible regions of cells, by the bottom and top quantiles.  This is not implemented in \code{IterativeLSI()},
but can be done as a preprocessing step.
}
}
\examples{
## Prep data
nrows <- 350
ncols <- 2000
mat <- matrix(1:(nrows*ncols), nrow = nrows) \%>\% as("IterableMatrix")
rownames(mat) <- paste0("feat", seq(nrows))
colnames(mat) <- paste0("cell", seq(ncols))


#######################################################################
## IterativeLSI() examples
#######################################################################
dim_reduction <- IterativeLSI(mat, n_dimensions = 5)

## Can customize parameters using partialization
dim_reduction <- IterativeLSI(
  mat,
  n_dimensions = 10,
  feature_selection_method = select_features_variance(
    num_feats = 0.5,
    normalize_method = normalize_tfidf(scale_factor = 5000)
  ),
  cluster_method = cluster_cells_graph(
    graph_to_cluster_method = cluster_graph_louvain(resolution = 0.5),
    knn_to_graph_method = knn_to_snn_graph
  )
)
dim_reduction


#######################################################################
## project(<IterativeLSI>) example
#######################################################################
dim(project(dim_reduction, mat))


}
\seealso{
\code{LSI()} \code{DimReduction()} \code{svds()}
\code{cluster_cells_graph()} \code{select_features_variance()} \code{select_features_dispersion()}
\code{select_features_mean()} \code{select_features_binned_dispersion()}
}
