[{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic tutorial","text":"tutorial, : Load RNA ATAC-seq data 10x multiome experiment Filter high-quality cells RNA PCA + UMAP dimensionality reduction Unbiased clustering Visualize marker genes annotate clusters Call ATAC-seq peaks ATAC PCA + UMAP dimensionality reduction Visualize transcription factor footprints Plot accessibility genome tracks tutorial work--progress, inspired Seurat’s PBMC 3k clustering tutorial.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"install-packages","dir":"Articles","previous_headings":"Setup","what":"Install packages","title":"Basic tutorial","text":"Install cran dependencies: irlba (PCA) uwot (UMAP) RcppHNSW (clustering) igraph (clustering) BiocManager (access bioconductor packages) ggplot2 version <=3.3.5 >=3.4.1 (hexbin broken versions 3.3.6-3.4.0) Bioconductor dependencies: BSgenome.Hsapiens.UCSC.hg38 (TF motif scanning) Github: motifmatchr (TF motif scanning) chromVARmotifs (TF motif database)","code":"install.packages(c(\"irlba\", \"uwot\", \"RcppHNSW\", \"igraph\", \"BiocManager\", \"remotes\", \"ggplot2\")) BiocManager::install(\"BSgenome.Hsapiens.UCSC.hg38\") remotes::install_github(c(\"GreenleafLab/motifmatchr\", \"GreenleafLab/chromVARmotifs\"), repos=BiocManager::repositories()) remotes::install_github(c(\"bnprks/BPCells/r\"))"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"set-up-analysis-folder","dir":"Articles","previous_headings":"Setup","what":"Set up analysis folder","title":"Basic tutorial","text":"","code":"library(BPCells) suppressPackageStartupMessages({   library(dplyr) })  # Substitute your preferred working directory for data_dir data_dir <- file.path(tempdir(), \"pbmc-3k\") dir.create(data_dir, recursive = TRUE, showWarnings = FALSE) setwd(data_dir)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"download-data","dir":"Articles","previous_headings":"Setup","what":"Download data","title":"Basic tutorial","text":"Next, download 3k PBMC dataset 10x Genomics temporary directory. files 500MB large combined","code":"url_base <- \"https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_3k/\" rna_raw_url <- paste0(url_base, \"pbmc_granulocyte_sorted_3k_raw_feature_bc_matrix.h5\") atac_raw_url <- paste0(url_base, \"pbmc_granulocyte_sorted_3k_atac_fragments.tsv.gz\")  # Increase download timeout from 60 seconds to 5 minutes options(timeout=300)  # Only download files if we haven't downloaded already if (!file.exists(\"pbmc_3k_10x.h5\")) {   download.file(rna_raw_url, \"pbmc_3k_10x.h5\", mode=\"wb\") } if (!file.exists(\"pbmc_3k_10x.fragments.tsv.gz\")) {   download.file(atac_raw_url, \"pbmc_3k_10x.fragments.tsv.gz\", mode=\"wb\") }"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"data-loading","dir":"Articles","previous_headings":"","what":"Data Loading","title":"Basic tutorial","text":"First, convert raw data inputs 10x format bitpacked compressed format stored binary files disk. BPCells can still read data don’t convert format, certain ATAC-seq functionality run much faster converted data. Convert RNA matrix: Convert ATAC-seq fragments ATAC storage space dropped 468 MB gzipped 10x file 209 MB bitpacked storage. RNA storage space dropped 51.2 MB 10x hdf5 file gzip compression 33.5 MB using bitpacking compression. case, storage space little misleading since 39% bitpacked storage spent gene + cell names. case 10x compressed hdf5 bitpacking compression 4-6x smaller uncompressed sparse matrix format AnnData.","code":"# Check if we already ran import if (!file.exists(\"pbmc_3k_rna_raw\")) {   mat_raw <- open_matrix_10x_hdf5(\"pbmc_3k_10x.h5\", feature_type=\"Gene Expression\") %>%      write_matrix_dir(\"pbmc_3k_rna_raw\") } else {   mat_raw <- open_matrix_dir(\"pbmc_3k_rna_raw\") } mat_raw ## 36601 x 650165 IterableMatrix object with class MatrixDir ##  ## Row names: ENSG00000243485, ENSG00000237613 ... ENSG00000277196 ## Col names: AAACAGCCAAACAACA-1, AAACAGCCAAACATAG-1 ... TTTGTTGGTTTGTTGC-1 ##  ## Data type: uint32_t ## Storage order: column major ##  ## Queued Operations: ## 1. Load compressed matrix from directory /home/bparks/dev/github/bnprks/BPCells/r/vignettes/pbmc-3k-data/pbmc_3k_rna_raw # Check if we already ran import if (!file.exists(\"pbmc_3k_frags\")) {   frags_raw <- open_fragments_10x(\"pbmc_3k_10x.fragments.tsv.gz\") %>%       write_fragments_dir(\"pbmc_3k_frags\") } else {   frags_raw <- open_fragments_dir(\"pbmc_3k_frags\") } frags_raw ## IterableFragments object of class \"FragmentsDir\" ##  ## Cells: 462264 cells with names TTTAGCAAGGTAGCTT-1, GCCTTTGGTTGGTTCT-1 ... ATCACCCTCCATAATG-1 ## Chromosomes: 39 chromosomes with names chr1, chr10 ... KI270713.1 ##  ## Queued Operations: ## 1. Read compressed fragments from directory /home/bparks/dev/github/bnprks/BPCells/r/vignettes/pbmc-3k-data/pbmc_3k_frags"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"rna-seq-filtering","dir":"Articles","previous_headings":"Filter for high-quality cells","what":"RNA-seq filtering","title":"Basic tutorial","text":"use simple minimum read threshold RNA-seq quality. cutoff choose just first knee log-log plot reads vs. barcode rank, separates cells empty droplets.","code":"reads_per_cell <- Matrix::colSums(mat_raw) plot_read_count_knee(reads_per_cell, cutoff = 1e3)"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"download-reference-annotations","dir":"Articles","previous_headings":"Filter for high-quality cells > ATAC-seq filtering","what":"Download reference annotations","title":"Basic tutorial","text":"fetch reference information necessary calculate quality-control statistics. default, fetches latest annotations hg38. Since fetching references involves downloading gtf bed files, provide name directory save files . also allows us skip re-downloading files next time.","code":"genes <- read_gencode_transcripts(   \"./references\",    release=\"42\",    transcript_choice=\"MANE_Select\",   annotation_set = \"basic\",    features=\"transcript\" # Make sure to set this so we don't get exons as well ) head(genes) ## # A tibble: 6 × 13 ##   chr   source feature     start    end score strand frame gene_id     gene_type ##   <chr> <chr>  <chr>       <dbl>  <int> <chr> <chr>  <chr> <chr>       <chr>     ## 1 chr1  HAVANA transcript  65418  71585 .     +      .     ENSG000001… protein_… ## 2 chr1  HAVANA transcript 450739 451678 .     -      .     ENSG000002… protein_… ## 3 chr1  HAVANA transcript 685715 686654 .     -      .     ENSG000002… protein_… ## 4 chr1  HAVANA transcript 923922 944574 .     +      .     ENSG000001… protein_… ## 5 chr1  HAVANA transcript 944202 959256 .     -      .     ENSG000001… protein_… ## 6 chr1  HAVANA transcript 960583 965719 .     +      .     ENSG000001… protein_… ## # ℹ 3 more variables: gene_name <chr>, transcript_id <chr>, MANE_Select <lgl> blacklist <- read_encode_blacklist(\"./references\", genome=\"hg38\") head(blacklist) ## # A tibble: 6 × 4 ##   chr      start      end reason             ##   <chr>    <dbl>    <dbl> <chr>              ## 1 chr10        0    45700 Low Mappability    ## 2 chr10 38481300 38596500 High Signal Region ## 3 chr10 38782600 38967900 High Signal Region ## 4 chr10 39901300 41712900 High Signal Region ## 5 chr10 41838900 42107300 High Signal Region ## 6 chr10 42279400 42322500 High Signal Region chrom_sizes <- read_ucsc_chrom_sizes(\"./references\", genome=\"hg38\") head(chrom_sizes) ## # A tibble: 6 × 3 ##   chr   start       end ##   <chr> <dbl>     <int> ## 1 chr1      0 248956422 ## 2 chr2      0 242193529 ## 3 chr3      0 198295559 ## 4 chr4      0 190214555 ## 5 chr5      0 181538259 ## 6 chr6      0 170805979"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"calculate-atac-seq-quality-control-metrics","dir":"Articles","previous_headings":"Filter for high-quality cells > ATAC-seq filtering","what":"Calculate ATAC-seq quality-control metrics","title":"Basic tutorial","text":"can calculate several built-quality control metrics barcode, including number fragments TSS enrichment. calculations fully compatible ArchR’s methodology quality control statistics. One key ways identify high-quality cells ATAC-seq data plot number fragments vs. TSS Enrichment. plot puts empty droplets bottom-left quadrant, low-quality/dead cells bottom-right quadrant, high-quality cells top-right quadrant. flow-cytometry perspective, use bottom-left group empty droplets negative control help set cutoffs.  Due thresholding ArchR’s formula applies denominator TSS Enrichment calculation, low-read cells can’t assigned high TSS Enrichment value. plot TSS enrichment without thresholding, following:  Note 200/101 fraction accounts ReadsInTSS drawing 101-bp windows, ReadsFlankingTSS drawing 2x100-bp windows. results low-read droplets measuring high TSS Enrichment, use slightly adjusted cutoffs. can also plot sample-level quality control plots. left, fragment length distribution shows three broad bumps corresponding nucleosome spacing (147bp), smaller wiggles corresponding DNA winding (11.5bp). right, TSS enrichment profile shows strong enrichment signal transcription start sites, well small asymmetrical bump downstream TSS +1 nucleosome.","code":"atac_qc <- qc_scATAC(frags_raw, genes, blacklist) head(atac_qc) ## # A tibble: 6 × 10 ##   cellName  TSSEnrichment nFrags subNucleosomal monoNucleosomal multiNucleosomal ##   <chr>             <dbl>  <int>          <int>           <int>            <int> ## 1 TTTAGCAA…        45.1    16363           8069            5588             2706 ## 2 GCCTTTGG…         0.198      3              1               2                0 ## 3 AGCCGGTT…        30.9    33313          15855           11868             5590 ## 4 TGATTAGT…        41.9    11908           6103            3817             1988 ## 5 ATTGACTC…        43.9    13075           6932            4141             2002 ## 6 CGTTAGGT…        31.5    14874           6833            5405             2636 ## # ℹ 4 more variables: ReadsInTSS <dbl>, ReadsFlankingTSS <dbl>, ## #   ReadsInPromoter <dbl>, ReadsInBlacklist <dbl> plot_tss_scatter(atac_qc, min_frags=1000, min_tss=10) atac_qc %>%   dplyr::mutate(TSSEnrichment=ReadsInTSS/pmax(1,ReadsFlankingTSS) * 200/101) %>%   plot_tss_scatter(min_frags=2000, min_tss=20) +   ggplot2::labs(title=\"Raw TSS Enrichment\") plot_fragment_length(frags_raw) + plot_tss_profile(frags_raw, genes)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"select-high-quality-cells","dir":"Articles","previous_headings":"Filter for high-quality cells","what":"Select high-quality cells","title":"Basic tutorial","text":"take cells pass minimum RNA reads, minimum ATAC reads, minimum TSS Enrichment cutoffs. subset RNA ATAC input data just cells passing filter. RNA, subset genes least 3 reads. subset operation also puts cells matching order simplifies cross-modality calculations later .","code":"pass_atac <- atac_qc %>%     dplyr::filter(nFrags > 1000, TSSEnrichment > 10) %>%     dplyr::pull(cellName) pass_rna <- colnames(mat_raw)[Matrix::colSums(mat_raw) > 1e3] keeper_cells <- intersect(pass_atac, pass_rna) frags <- frags_raw %>% select_cells(keeper_cells)  keeper_genes <- Matrix::rowSums(mat_raw) > 3 mat <- mat_raw[keeper_genes,keeper_cells]"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"matrix-normalization","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Matrix normalization","title":"Basic tutorial","text":", walk Seurat-style matrix normalization calculations manually, though soon helper functions simplify process. First log-normalize, roughly equivalent Seurat::NormalizeData Next pick variable genes: look normalized matrix object, can see quite math operations queued performed --fly needed. improve performance downstream PCA, save sparse normalized matrix temporary file just prior normalizations make matrix dense. saves storage space preventing us re-calculate queued operations several-hundred times PCA optimization iterations. case, matrix quite small ’ll just store memory. larger example swap write_matrix_dir(tempfile(\"mat\")) Finally, perform z-score normalization makes matrix dense.","code":"# Normalize by reads-per-cell mat <- multiply_cols(mat, 1/Matrix::colSums(mat))  # Log normalization mat <- log1p(mat * 10000) # Log normalization stats <- matrix_stats(mat, row_stats=\"variance\")  # To keep the example small, we'll do a very naive variable gene selection variable_genes <- order(stats$row_stats[\"variance\",], decreasing=TRUE) %>%    head(1000) %>%    sort()  mat_norm <- mat[variable_genes,] mat_norm ## 1000 x 2600 IterableMatrix object with class TransformLog1p ##  ## Row names: ENSG00000078369, ENSG00000116251 ... ENSG00000212907 ## Col names: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ##  ## Data type: double ## Storage order: column major ##  ## Queued Operations: ## 1. Load compressed matrix from directory /home/bparks/dev/github/bnprks/BPCells/r/vignettes/pbmc-3k-data/pbmc_3k_rna_raw ## 2. Select rows: 87, 171 ... 36568 and cols: 640783, 89020 ... 504383 ## 3. Convert type from uint32_t to double ## 4. Scale by 1e+04 ## 5. Scale columns by 0.000221, 0.000118 ... 0.000177 ## 6. Transform log1p mat_norm <- mat_norm %>% write_matrix_memory(compress=FALSE) gene_means <- stats$row_stats[\"mean\",variable_genes] gene_vars <- stats$row_stats[\"variance\", variable_genes] mat_norm <- (mat_norm - gene_means) / gene_vars"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"pca-and-umap","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"PCA and UMAP","title":"Basic tutorial","text":"PCA can performed standard solver like irlba, though BPCells also provides C++-level solver based Spectra package built-parallelization support. Next calculate UMAP coordinates","code":"svd <- BPCells::svds(mat_norm, k=50) # Alternate option: irlba::irlba(mat_norm, nv=50) pca <- multiply_cols(svd$v, svd$d)  cat(sprintf(\"PCA dimensions: %s\\n\", toString(dim(pca)))) pca[1:4,1:3] ## PCA dimensions: 2600, 50 ##           [,1]       [,2]       [,3] ## [1,] 15.167732  0.8951489 -2.3650024 ## [2,]  6.599775  7.2484737  4.4369185 ## [3,] 14.621697 -1.1929478 -0.6439663 ## [4,]  8.142875  1.0977223 -2.5066235 set.seed(12341512) umap <- uwot::umap(pca) umap[1:4,] ##            [,1]        [,2] ## [1,]  9.9284977   2.8806480 ## [2,] -0.7640393 -11.7900724 ## [3,]  9.8782410   3.1049877 ## [4,]  7.7622828   0.5004428"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"clustering","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Clustering","title":"Basic tutorial","text":"perform quick clustering follows, based PCA coordinates. now can visualize clusters UMAP:","code":"clusts <- knn_hnsw(pca, ef=500) %>% # Find approximate nearest neighbors   knn_to_snn_graph() %>% # Convert to a SNN graph   cluster_graph_louvain() # Perform graph-based clustering cat(sprintf(\"Clusts length: %s\\n\", length(clusts))) clusts[1:10] ## Clusts length: 2600 ##  [1] 1 2 1 2 2 3 2 2 4 5 ## Levels: 1 2 3 4 5 6 7 8 9 10 11 12 plot_embedding(clusts, umap)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"visualize-marker-genes","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Visualize marker genes","title":"Basic tutorial","text":"annotate clusters cell types, can plot several marker genes overlaid onto UMAP.  observe cluster-specific enrichment B-cell marker MS4A1, T-cell marker CD3E, Monocyte marker LYZ. allows us make broad cell type groupings follows:  can visualize marker genes cluster using dot plot. typical situations, known marker genes clear, others less specific.","code":"plot_embedding(   source = mat,   umap,   features = c(\"MS4A1\", \"GNLY\", \"CD3E\",                 \"CD14\", \"FCER1A\", \"FCGR3A\",                 \"LYZ\", \"CD4\",\"CD8\"), ) cluster_annotations <- c(   \"1\" = \"T\",   \"2\" = \"CD8 T\",   \"3\" = \"B\",   \"4\" = \"T\",   \"5\" = \"NK\",   \"6\" = \"Mono\",   \"7\" = \"Mono\",   \"8\" = \"Mono\",   \"9\" = \"T\",   \"10\" = \"DC\",   \"11\" = \"Mono\",   \"12\" = \"DC\" ) cell_types <- cluster_annotations[clusts] plot_embedding(cell_types, umap) plot_dot(   mat,    c(\"MS4A1\", \"GNLY\", \"CD3E\",      \"CD14\", \"FCER1A\", \"FCGR3A\",      \"LYZ\", \"CD4\", \"CD8\"),    cell_types )"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"atac-normalization-pca-and-umap","dir":"Articles","previous_headings":"","what":"ATAC Normalization, PCA and UMAP","title":"Basic tutorial","text":"start tile-based peak calling, tests pre-determined overlapping tile positions significant enrichment ATAC-seq signal genome-wide background cell type independently. faster using real peak-caller like MACS, though default parameters peaks always 200bp wide positioning resolution approximately +/- 30bp. Next compute peak matrix counting many ATAC-seq insertions overlap peak. save memory rather saving disk since dataset quite small. Next calculate TF-IDF normalization. formula TF-IDF variant Stuart et al. Looking LSI matrix, can see power BPCells performing matrix operations --fly: LSI normalization fact calculated time fragment overlap calculations read matrix. don’t need store intermediate matrices calculations, even peak matrix can re-calculated --fly based fragments object saved disk. Just like RNA, save matrix running PCA. larger dataset, save disk rather memory. Finally, z-score normalization LSI matrix run PCA. standard practice running PCA, commonly done ATAC-seq datasets due fact greatly increases memory usage. methods, 1st PC highly correlated number reads per cell, thrown empirical correction. Luckily, BPCells can avoid memory usage can just normalize data run PCA usual Next calculate UMAP cluster, just like RNA can plot ATAC-seq embedding ATAC-derived clusters, easily compare RNA-derived clusters earlier.  BPCells works based order cells matrix fragment object. Since ATAC PCA rows cell order RNA clusters, datasets combine additional work. skip normalization, first observe get high correlation first PC reads-per-cell peak matrix  terms actual PCA results, can see cell embeddings mostly 1--1 correspondence across first 6 PCs, though later PCs start diverge. first PC raw TF-IDF corresponds mostly read depth, signal spread across 2 PCs z-score normalized variant.  look loading peak PCA, see similar result.  Finally, UMAP generated exclude first PC fairly similar, though notable difference positioning dendritic cells","code":"frags_filter_blacklist <- frags %>%   select_regions(blacklist, invert_selection = TRUE) peaks <- call_peaks_tile(frags_filter_blacklist, chrom_sizes, cell_groups=cell_types,                            effective_genome_size = 2.8e9) head(peaks) ## # A tibble: 6 × 7 ##   chr       start       end group     p_val     q_val enrichment ##   <fct>     <int>     <int> <chr>     <dbl>     <dbl>      <dbl> ## 1 chr1   16644600  16644800 T     0         0              1017. ## 2 chr19  18281733  18281933 Mono  0         0               518. ## 3 chr17  81860866  81861066 DC    7.87e- 63 1.21e- 55       552. ## 4 chr1    1724333   1724533 Mono  0         0               512. ## 5 chr1  228140000 228140200 NK    2.77e-162 2.14e-155       842. ## 6 chr8   30083133  30083333 CD8 T 4.80e-220 7.41e-213       744. top_peaks <- head(peaks, 50000) top_peaks <- top_peaks[order_ranges(top_peaks, chrNames(frags)),] peak_mat <- peak_matrix(frags, top_peaks, mode=\"insertions\") mat_lsi <- peak_mat %>%   multiply_cols(1 / Matrix::colSums(peak_mat)) %>%   multiply_rows(1 / Matrix::rowMeans(peak_mat))  mat_lsi <- log1p(10000 * mat_lsi) mat_lsi ## 50000 x 2600 IterableMatrix object with class TransformLog1p ##  ## Row names: chr1:817200-817400, chr1:827466-827666 ... chrX:155881200-155881400 ## Col names: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ##  ## Data type: double ## Storage order: row major ##  ## Queued Operations: ## 1. Read compressed fragments from directory /home/bparks/dev/github/bnprks/BPCells/r/vignettes/pbmc-3k-data/pbmc_3k_frags ## 2. Select 2600 cells by name: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ## 3. Calculate 2600 peaks over 50000 ranges: chr1:817201-817400 ... chrX:155881201-155881400 ## 4. Convert type from uint32_t to double ## 5. Scale by 1e+04 ## 6. Scale columns by 6.71e-05, 5.17e-05 ... 0.000801 ## 7. Scale rows by 11.1, 2.78 ... 3.77 ## 8. Transform log1p mat_lsi <- write_matrix_memory(mat_lsi, compress=FALSE) # Compute colMean and colVariance in one pass cell_peak_stats <- matrix_stats(mat_lsi, col_stats=\"variance\")$col_stats cell_means <- cell_peak_stats[\"mean\",] cell_vars <- cell_peak_stats[\"variance\",] mat_lsi_norm <- mat_lsi %>%   add_cols(-cell_means) %>%   multiply_cols(1 / cell_vars) svd_atac <- BPCells::svds(mat_lsi_norm, k=10) pca_atac <- multiply_cols(svd_atac$v, svd_atac$d) pca_atac[1:4,1:4] ##            [,1]       [,2]       [,3]      [,4] ## [1,] -103.64071   1.553515   2.436148  21.22977 ## [2,]  -44.75342 -28.737622 -12.681591 -10.01745 ## [3,]  -90.74857   3.266168   3.627660  12.95109 ## [4,]  -90.74640  -6.447103   6.853840 -15.76629 set.seed(12341512) umap_atac <- uwot::umap(pca_atac) umap_atac[1:4,] ##           [,1]      [,2] ## [1,]  6.380669  4.681697 ## [2,] -6.929080 -1.873173 ## [3,]  6.416005  9.665938 ## [4,]  7.895295  1.542123 clusts_atac <- knn_hnsw(pca_atac, ef=500) %>% # Find approximate nearest neighbors   knn_to_snn_graph() %>% # Convert to a SNN graph   cluster_graph_louvain() # Perform graph-based clustering plot_embedding(clusts_atac, umap_atac, colors_discrete = discrete_palette(\"ironMan\")) +   ggplot2::guides(color=\"none\") +    plot_embedding(cell_types, umap_atac) svd_atac_no_norm <- BPCells::svds(mat_lsi, k=10) pca_atac_no_norm <- multiply_cols(svd_atac_no_norm$v, svd_atac$d) cor_to_depth <- dplyr::bind_rows(   tibble::tibble(     method=\"z-score normalize\",     abs_cor_to_depth = as.numeric(abs(cor(Matrix::colSums(mat_lsi), pca_atac))),     PC=seq_along(abs_cor_to_depth)   ),   tibble::tibble(     method=\"raw TF-IDF\",     abs_cor_to_depth = as.numeric(abs(cor(Matrix::colSums(mat_lsi), pca_atac_no_norm))),     PC=seq_along(abs_cor_to_depth)   ) ) ggplot2::ggplot(cor_to_depth, ggplot2::aes(PC, abs_cor_to_depth, color=method)) +   ggplot2::geom_point() +   ggplot2::theme_bw() +   ggplot2::labs(title=\"Correlation to of PCs to read depth\") cor_between_embeddings <- tidyr::expand_grid(   pca_atac_no_norm = seq_len(ncol(pca_atac_no_norm)),   pca_atac=seq_len(ncol(pca_atac)) ) %>% mutate(   cor = as.numeric(abs(cor(.env$pca_atac, .env$pca_atac_no_norm))) )  ggplot2::ggplot(cor_between_embeddings, ggplot2::aes(pca_atac, pca_atac_no_norm, fill=abs(cor))) +   ggplot2::geom_tile() +   ggplot2::geom_text(mapping=ggplot2::aes(label=sprintf(\"%.2f\", cor))) +   ggplot2::scale_x_continuous(breaks=1:10) +   ggplot2::scale_y_continuous(breaks=1:10) +   ggplot2::theme_classic() +   ggplot2::labs(title=\"Correlation between cell embeddings\",                  x=\"z-score normalize PCs\",                 y =\"raw TF-IDF PCs\") cor_between_loadings <- tidyr::expand_grid(   pca_atac_no_norm = seq_len(ncol(svd_atac_no_norm$u)),   pca_atac=seq_len(ncol(svd_atac$u)) ) %>% mutate(   cor = as.numeric(abs(cor(.env$svd_atac$u, .env$svd_atac_no_norm$u))) )  ggplot2::ggplot(cor_between_loadings, ggplot2::aes(pca_atac, pca_atac_no_norm, fill=abs(cor))) +   ggplot2::geom_tile() +   ggplot2::geom_text(mapping=ggplot2::aes(label=sprintf(\"%.2f\", cor))) +   ggplot2::scale_x_continuous(breaks=1:10) +   ggplot2::scale_y_continuous(breaks=1:10) +   ggplot2::theme_classic() +   ggplot2::labs(title=\"Correlation between peak loadings\",                 x=\"z-score normalize PCs\",                 y =\"raw TF-IDF PCs\") set.seed(12341512) umap_atac_no_norm <- uwot::umap(pca_atac_no_norm[,-1]) plot_embedding(clusts_atac, umap_atac_no_norm, colors_discrete = discrete_palette(\"ironMan\")) +   ggplot2::guides(color=\"none\") +    plot_embedding(cell_types, umap_atac_no_norm)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"motif-footprinting","dir":"Articles","previous_headings":"","what":"Motif footprinting","title":"Basic tutorial","text":"motif footprinting, first need find instances motifs--interest peaks Next, can use motif positions plot aggregate accessibility surrounding TF binding sites across cell types proxy TF activity. ’re able see enrichment accessibility neighboring sites myeloid transcription factor DC Monocyte cells. Transcription factor binding (generally) mutually-exclusive nucleosome occupancy, transcription factor bound creates accessibility flanking regions. squiggly bit center due Tn5 insertion bias motif .  can also use patchwork library show multiple plots grid, highlighting cell-type-specific factors well general factors like CTCF.","code":"suppressPackageStartupMessages({   library(GenomicRanges)   library(Biostrings) }) peaks_sorted <- dplyr::arrange(peaks, chr, start) peaks_gr <- dplyr::mutate(peaks_sorted, start = start + 1) %>% as(\"GenomicRanges\") selected_motifs <- c(   \"CEBPA\" = \"ENSG00000245848_LINE568_CEBPA_D_N4\",   \"EOMES\" = \"ENSG00000163508_LINE3544_EOMES_D_N1\",    \"SPI1\" = \"ENSG00000066336_LINE1813_SPI1_D_N5\",   \"CTCF\" = \"ENSG00000102974_LINE747_CTCF_D_N67\" ) suppressWarnings({   motif_positions <- motifmatchr::matchMotifs(       chromVARmotifs::human_pwms_v2[selected_motifs],        peaks_gr, genome=\"hg38\", out=\"positions\") }) names(motif_positions) <- names(selected_motifs) motif_positions ## GRangesList object of length 4: ## $CEBPA ## GRanges object with 13983 ranges and 1 metadata column: ##           seqnames              ranges strand |     score ##              <Rle>           <IRanges>  <Rle> | <numeric> ##       [1]     chr1     1060191-1060200      + |   7.24878 ##       [2]     chr1     1398356-1398365      - |   7.31950 ##       [3]     chr1     1408228-1408237      - |   7.91954 ##       [4]     chr1     1470604-1470613      + |   7.26055 ##       [5]     chr1     1614370-1614379      - |   7.33072 ##       ...      ...                 ...    ... .       ... ##   [13979]     chrX 154247973-154247982      + |   7.91954 ##   [13980]     chrX 154377819-154377828      - |   7.91954 ##   [13981]     chrX 154497506-154497515      + |   8.62478 ##   [13982]     chrX 154734157-154734166      + |   7.33771 ##   [13983]     chrX 155242494-155242503      - |   7.24396 ##   ------- ##   seqinfo: 39 sequences from an unspecified genome; no seqlengths ##  ## ... ## <3 more elements> plot_tf_footprint(   frags,   motif_positions$CEBPA,   cell_groups = cell_types,   flank = 250,   smooth = 2 ) +   ggplot2::labs(title=\"CEBPA\") footprinting_plots <- list() for (motif in names(selected_motifs)) {   footprinting_plots[[motif]] <- plot_tf_footprint(     frags,      motif_positions[[motif]],      cell_groups = cell_types,      flank=250,     smooth=2) +     ggplot2::labs(title=motif, color=\"Cluster\") } patchwork::wrap_plots(footprinting_plots, guides=\"collect\")"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"genome-accessibility-tracks","dir":"Articles","previous_headings":"","what":"Genome accessibility tracks","title":"Basic tutorial","text":"plot genome accessibility tracks, need select genome region view. BPCells provides helper function find genome regions centered around gene. normalizing tracks, need provide total number reads cell type. can substituted total reads peaks metrics desired. can create first component track plot plotting genome tracks . can see small peak center mainly present B cells (top row), unclear sits relative B-cell marker CD19.  much useful gene annotation track added . ’ll get set canonical transcripts (one per gene) Gencode can make annotation track  optionally scale bar.  Finally, can stack elements trackplot_combine(). Now see small peak just upstream CD19 gene.","code":"region <- gene_region(genes, \"CD19\", extend_bp = 1e5) region ## $chr ## [1] \"chr16\" ##  ## $start ## [1] 28831970 ##  ## $end ## [1] 29039342 read_counts <- atac_qc$nFrags[   match(cellNames(frags), atac_qc$cellName) ] coverage_plot <- trackplot_coverage(   frags,   region = region,    groups=cell_types,   read_counts,   bins=500 ) coverage_plot transcripts <- read_gencode_transcripts(\"./references\", release=\"42\") head(transcripts) ## # A tibble: 6 × 13 ##   chr   source feature     start    end score strand frame gene_id     gene_type ##   <chr> <chr>  <chr>       <dbl>  <int> <chr> <chr>  <chr> <chr>       <chr>     ## 1 chr1  HAVANA transcript  65418  71585 .     +      .     ENSG000001… protein_… ## 2 chr1  HAVANA exon        65418  65433 .     +      .     ENSG000001… protein_… ## 3 chr1  HAVANA exon        65519  65573 .     +      .     ENSG000001… protein_… ## 4 chr1  HAVANA exon        69036  71585 .     +      .     ENSG000001… protein_… ## 5 chr1  HAVANA transcript 450739 451678 .     -      .     ENSG000002… protein_… ## 6 chr1  HAVANA exon       450739 451678 .     -      .     ENSG000002… protein_… ## # ℹ 3 more variables: gene_name <chr>, transcript_id <chr>, MANE_Select <lgl> gene_plot <- trackplot_gene(transcripts, region) gene_plot scalebar_plot <- trackplot_scalebar(region) scalebar_plot # We list plots in order from top to bottom to combine.  # Notice that our inputs are also just ggplot objects, so we can make modifications # like removing the color legend from our gene track. trackplot_combine(   list(     scalebar_plot,      coverage_plot,      gene_plot + ggplot2::guides(color=\"none\")   ) )"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"rna-seq-normalization-pca","dir":"Articles > Web-only","previous_headings":"","what":"RNA-seq normalization + PCA","title":"Performance Benchmarks","text":"BPCells can perform operations streaming disk, able use dramatically less memory operations read matrix values. chunking strategy similar tools like DelayedArray. extensively optimized C++ code avoid slowdowns commonly caused using disk-backed computations. benchmark , show time memory perform basic workflow data import, normalization, variable gene selection, PCA. reproduce PCA results existing tools within numerical precision, starting raw counts1.  Note Seurat plot crashes 1.3M cell dataset due R sparse matrices supporting roughly 2 billion non-zero entries matrix. utilizing Seurat v5’s BPCells integration, possible perform analyses million cell datasets without downsampling.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"counts-matrices-rna-or-atac","dir":"Articles > Web-only","previous_headings":"Bitpacking compression","what":"Counts matrices (RNA or ATAC)","title":"Performance Benchmarks","text":"Single cell counts matrices stored sparse matrices. traditional formats like AnnData 10x hdf5 feature matrices, inherent tradeoff storage size speed loading. Gzip-compressed files small, slow read. BPCells uses bitpacking compression provide 4-6x smaller storage counts matrices compared uncompressed binary format (e.g. AnnData’s default h5ad settings2). single thread can load matrix data faster reading uncompressed data many cases, due smaller data size extremely fast decompression3. Benchmark storing + loading 1.3M cell RNA-seq experiment 10x Genomics.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"fragment-alignments-atac","dir":"Articles > Web-only","previous_headings":"Bitpacking compression","what":"Fragment alignments (ATAC)","title":"Performance Benchmarks","text":"Single cell ATAC-seq data stored lists fragment alignments, including chromosome, start+end coordinates, cell ID. storage space BPCells bitpacked format 2x smaller 10x fragments.tsv.gz file. storage format includes lightweight genome-position index enable fast loading data selected genome location. BPCells can decompress 70 million fragments per second single core, compared 5 million fragments per second 10x fragments.tsv.gz file (14x faster). Compared ArchR arrow files, BPCells also 2x smaller ~10x faster import times fragments.tsv.gz files.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"atac-seq-overlap-calculations","dir":"Articles > Web-only","previous_headings":"","what":"ATAC-seq overlap calculations","title":"Performance Benchmarks","text":"BPCells stores fragments genome-indexed format also enables fast seeking genome location. helps visualization selected genomic loci, well fast calculations cell x peak matrices. often necessary re-quantify cell x peak matrices fragments comparing datasets different original peak calls. implementation 40x faster ArchR calculating overlaps 100k peaks across genome, 500x faster calculating overlaps just 10 peaks. due fact BPCells fragments sorted genome coordinate, whereas arrow files sort cell genome coordinate.  peak matrix overlap calculation runs rate 25 million overlapping fragments per second, fast enough bottleneck /O speed rather computation reading 250MB/s hard drive bitpacking compression available reduce /O bandwidth.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"matrix-logical-storage-layout","dir":"Articles > Web-only","previous_headings":"","what":"Matrix Logical Storage Layout","title":"Matrix Storage Format","text":"data storage, use storage abstraction named data arrays, stored e.g. single group hdf5 directory files. matrix format compressed sparse column/row (CSC/CSR) format following data arrays: interpretation array follows: val - Values non-zero entries increasing order (column, row) position non-zero value. index - index[] provides 0-based row index value found val[] (column index row-major storage order) idxptr - indexes idx val entries column j can found idxptr[j] idxptr[j+1] - 1 , inclusive. (row j row-major storage order) shape - number rows matrix, followed number columns row_names - Names row matrix (optional) col_names - Names column matrix (optional) storage_order- col compressed-sparse-column, row compressed-sparse-row Bitpacked compressed matrices consist following modifications: val: unsigned 32-bit integers, replace val val_data, val_idx, val_idx_offsets corresponding BP-128m1 encoding described . total number values already stored last value idxptr. 32-bit 64-bit floats val remains unchanged. index: replace index array BP-128d1z encoded data arrays index_data, index_idx, index_idx_offsets, index_starts matrix stored single directory, HDF5 group, R S4 object. storage format matrix encoded version string. current version string format [compression]-[datatype]-matrix-v2, [compression] can either packed unpacked, [datatype] can one uint, float, double corresponding 32-bit unsigned integer, 32-bit float, 64-bit double respectively. v1 formats, difference idxptr type uint32.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bitpacking-formats","dir":"Articles > Web-only","previous_headings":"","what":"Bitpacking formats","title":"Matrix Storage Format","text":"bitpacked formats based formats described paper Lemire Boytsov.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128","title":"Matrix Storage Format","text":"vanilla BP-128 format stored 3 arrays follows: data - stream bitpacked data, represented 32-bit integers interleaved bit layout shown Lemire Boytsov figure 6. chunk 128 32-bit input integers BB bits per integer stored using 4B4B 32-bit integers holding bitpacked data. idx - list 32-bit integers, encoded data integers index 128*128*+ 127 can found data index idx[] index idx[+1]-1. lists 2322^{32} (4 billion) entries greater, idx stores index modulo 2322^{32} idx_offsets - list 64-bit integers, values idx indices idx_offsets[] idx_offsets[+1]-1 *(2^32) added .","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128m1","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128m1","title":"Matrix Storage Format","text":"BP-128, 1 subtracted value prior compression","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128d1","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128d1","title":"Matrix Storage Format","text":"Equivalent BP-128* algorithm Lemire Boytsov integers difference encoded prior bitpacking. best lists sorted integers. data - Encoding vanilla BP-128, difference encoding prior bitpacking: x0′=0x_{0}^{\\prime}=0, x1′=x1−x0x_{1}^{\\prime}=x_{1}-x_{0}, x2′=x2−x1x_{2}^{\\prime}=x_{2}-x_{1}, …, x127′=x127−x126x_{127}^{\\prime}=x_{127}-x_{126} idx, idx_offsets - identical BP-128 starts - list 32-bit integers, starts[] decoded value integer index 128*","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128d1z","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128d1z","title":"Matrix Storage Format","text":"Similar BP128d1 zigzag encoding applied difference encoding. best lists close fully sorted runs integers. data - Encoding BP-128d1, difference encoding bitpacking, results zigzag encoded, zigzag(x)=2xzigzag(x)=2x x≥0x\\geq0, zigzag(x)=−2x−1zigzag(x)=-2x-1 x<0x<0. idx, idx_offsets - identical BP-128 starts - identical BP128-d1 core bitpacking code can found src/bitpacking/bp128.cpp github repository.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"physical-storage-layout","dir":"Articles > Web-only","previous_headings":"","what":"Physical storage layout","title":"Matrix Storage Format","text":"abstraction named data arrays can realized different formats. three currently supported BPCells :","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"directory-of-files-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"Directory of files format:","title":"Matrix Storage Format","text":"array numbers stored single file 8-byte header, followed data values little-endian binary format. Unsigned integers encoded according standard little-endian representation, 32-bit 64-bit floating point numbers IEEE-754 format. Header values 8-byte ASCII text follows: unsigned 32-bit integer UINT32v1, unsigned 64-bit integer UINT64v1, 32-bit float FLOATSv1, 64-bit float DOUBLEv1. Arrays strings stored ASCII text one array value per line header. version string stored file named version containing version string followed newline.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"hdf5-file-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"Hdf5 file format:","title":"Matrix Storage Format","text":"Arrays numbers stored HDF5 datasets using built-HDF5 encoding format. Arrays strings stored HDF5 variable length string datasets. version string stored version attribute HDF5 group","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"r-object-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"R object format:","title":"Matrix Storage Format","text":"Strings stored native R character arrays. Unsigned integers 32-bit floats stored native R integer arrays bitcasting R signed integers required data types. 64-bit floats stored native R numeric arrays. 64-bit integers stored doubles R numeric arrays. reduces highest representable value 264−12^{64}-1 253−12^{53}-1 (9 quadrillion), expect pose practical problems. Named collections arrays stored R lists (writing) S4 objects (reading). version string stored string vector named version length 1.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/developer-notes.html","id":"garbage-collection-and-threads","dir":"Articles > Web-only","previous_headings":"","what":"Garbage collection and threads","title":"Notes for Developers","text":"help avoid unnecessary copies, BPCells circumstances keeps direct references R objects. major use-cases happens : Loading data R object (e.g. dgCMatrix) Using pre-loaded R vectors holding row/col names (cell/chr names) avoid repeatedly reading disk. Unfortunately, need extremely careful R objects created/destroyed R main thread. stated R extensions documentation: Calling R API threaded code ‘experts ’ strongly discouraged. Many functions R API modify internal R data structures might corrupt data structures called simultaneously multiple threads. R API functions can signal errors, must happen R main thread. Also, external libraries (e.g. LAPACK) may thread-safe. Within Rcpp, R objects default protected garbage collection (code link). means, however, Rcpp object constructors destructors must execute main thread interact R API manage GC protection. design BPCells C++ code, often code running main thread, e.g. C++ function run_with_R_interrupt_check runs main work background thread simplify interrupt checking. obviously explicit parallelization result code running main thread. safety, must assume MatrixLoader FragmentLoader objects may contain references R objects. Therefore constructors destructors can called main thread. Ensuring constructors called main thread fairly simple – just put constructors top level directly requested R. ensure destructors called main thread, must never give ownership MatrixLoader FragmentLoader object worker thread. Passing references raw pointers fine. Giving ownership via unique_ptr, move semantics, pass--value must avoided handing MatrixLoader FragmentLoader worker thread.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"operating-principles","dir":"Articles > Web-only","previous_headings":"","what":"Operating Principles","title":"How BPCells works","text":"Two key principles understand using BPCells operations streaming lazy. Streaming means minimal amount data stored memory computation happening. almost memory used storing intermediate results. Hence, can compute operations large matrices without ever loading fully memory. Lazy means real work performed matrix fragment objects result needs returned R object written disk. helps support streaming computation, since otherwise forced compute intermediate results use additional memory.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"basic-usage","dir":"Articles > Web-only","previous_headings":"Operating Principles","what":"Basic usage","title":"How BPCells works","text":"begin basic example loading ATAC fragments 10x fragments file, reading peak set bed file, calculating cell x peak matrix. bitpacked compressed fragment file half size 10x file, much faster read.","code":"library(\"BPCells\")  # File reading is lazy, so this is instantaneous fragments <- open_fragments_10x(\"atac_fragments.tsv.gz\")  # This is when we actually read the file, should take 1-2 minutes to scan # since we bottleneck on gzip decompression. packed_fragments <- write_fragments_dir(fragments, \"pbmc-3k-fragments\") # Later, we can re-open these fragments packed_fragments <- open_fragments_dir(\"pbmc-3k_fragments\")  peaks <- read_bed(\"peaks.bed\")  # This is fast because the peak matrix calculation is lazy. # It will be computed on-the-fly when we actually need results from it. peak_matrix <- peak_matrix(packed_fragments, peaks)  # Here is where the peak matrix calculation happens. Runs over 10-times # faster than ArchR, which utilizes IRanges to perform overlap calculations. R_matrix <- as(peak_matrix, \"dgCMatrix\")"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"streaming-operations","dir":"Articles > Web-only","previous_headings":"Operating Principles","what":"Streaming operations","title":"How BPCells works","text":"lazy, stream-oriented design means can calculate complicated transformations single pass. faster memory-efficient calculating several intermediate results sequential manner. example, perform following pipeline: 1. Exclude fragments non-standard chromosomes 2. Subset cells 3. Add Tn5 offset 4. Calculate peak matrix 5. Calculate mean-accessibility per peak done using e.g. GRanges sparse matrices, need 3 passes fragments saving intermediate results, 2 passes peak matrix. BPCell’s streaming operations, can done directly fragments single pass, memory usage limited bytes per cell iterating peak matrix returning colMeans. Note knew cell names ahead time, even perform operation directly orignal 10x fragments without ever saving fragments memory. fairly slow 10x fragment files slow decompress, ’s recommended convert BPCells format.","code":"# Here I make use of the new pipe operator |> for better readability  # We'll subset to just the standard chromosomes standard_chr <- which(   stringr::str_detect(chrNames(packed_fragments), \"^chr[0-9XY]+$\") )  # Pick a random subset of 100 cells to consider set.seed(1337) keeper_cells <- sample(cellNames(packed_fragments), 100)  # Run the pipeline, and save the average accessibility per peak peak_accessibility <- packed_fragments |>   select_chromosomes(standard_chr) |>   select_cells(keeper_cells) |>   shift_fragments(shift_start=4, shift_end=-5) |>   peak_matrix(peaks) |>   colMeans()"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"normalizations-and-pca","dir":"Articles > Web-only","previous_headings":"","what":"Normalizations and PCA","title":"Efficiency tips","text":"Avoid dense matrices whenever possible. Put normalizations preserve sparsity (0 values stay 0) normalizations break sparsity (e.g. adding values row/column). typical RNA-seq matrix <5% non-zero entries, code operate 20x entries dense matrix. operations, recommend using lazy evaluation avoid creating intermediate matrices. one common exception rule running PCA. PCA requires looping matrix several hundred times, often faster write matrix disk just PCA rather recalculating entries PCA iteration. storage efficiency, keep sparsity-breaking normalizations delayed, store sparse normalizations temporary location write_matrix_dir() apply sparsity-breaking normalizations Adding values rows/columns matrix little overhead PCA translates pre post processing step mat-vec multiply iteration. sparsity-breaking operation, adding vector matrix causes operations become expensive, however.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"storage-order","dir":"Articles > Web-only","previous_headings":"","what":"Storage order","title":"Efficiency tips","text":"Marker features can computed matrix indexed gene/feature. Sparse matrix multiplication can performed matrices storage order Sparse matrix multiplication performance can change dramatically depending storage order relative matrix size/sparsity. column-major matrices, left matrix fast load contain delayed operations, right matrix can slow load contain many delayed operations. row-major matrices left/right preferences reversed. can check storage order matrix printing R terminal calling t() function, BPCells just flips boolean flag whether matrix row-major column-major. affect underlying storage order. adjust underlying storage order, call transpose_storage_order(). slower operation, requires writing new copy data disk.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"other-tips","dir":"Articles > Web-only","previous_headings":"","what":"Other tips","title":"Efficiency tips","text":"Use single call matrix_stats() calculate mean + variance single pass matrix possible. See function reference details. ATAC-seq data, can calculate variable features tile matrix without ever saving disk. allows subset variable tiles create peak matrix just variable tiles space savings.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosophy.html","id":"programming-philosopy","dir":"Articles > Web-only","previous_headings":"","what":"Programming philosopy","title":"Programming Philosophy","text":"BPCells operates according somewhat different programming philosophy tools. particular: modify input data files, instead preferring write copy new location needed. Analysis code runs quickly raw counts provides clear reproducibility data provenance BPCells generally avoids storing normalized matrix copies (sometimes referred layers), instead preferring re-calculate normalized values --fly. helps avoid wasteful storage use. BPCells (currently) concept “project” object combines data + metadata complex structure.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosophy.html","id":"working-without-a-project-object","dir":"Articles > Web-only","previous_headings":"Programming philosopy","what":"Working without a project object","title":"Programming Philosophy","text":"Imagine want plot UMAP cells colored cluster. BPCells, way providing: 1, matrix cells x UMAP coordinates 2. vector listing cells belong cluster correspondence cells clusters determined based ordering. rows UMAP matrix order cluster membership vector. keep simple, recommend following approach: See tutorial example, make keeper_cells vector order data consistently according list cell IDs. downstream operations (PCA, clustering, etc.), cell order preserved unless explicitly change . things “just work” keep track per-cell metadata, can helpful make data frame tracking sample IDs, cluster membership, metadata Working without project object provides lot flexibility, since user can easily swap UMAP embeddings, cluster assignments, etc. just providing different variable input. ’s also need “export” metadata since wasn’t import step begin . course, power come additional responsibility keep track metadata. Keeping BPCells flexible power users retaining ease--use newbies ongoing effort, BPCells currently falls side power users","code":""},{"path":"https://bnprks.github.io/BPCells/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Benjamin Parks. Author, maintainer, copyright holder. Stanford University. Copyright holder, funder. Genentech, Inc.. Copyright holder, funder.","code":""},{"path":"https://bnprks.github.io/BPCells/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parks B (2024). BPCells: Single Cell Counts Matrices PCA. R package version 0.2.0, https://github.com/bnprks/BPCells, https://bnprks.github.io/BPCells.","code":"@Manual{,   title = {BPCells: Single Cell Counts Matrices to PCA},   author = {Benjamin Parks},   year = {2024},   note = {R package version 0.2.0, https://github.com/bnprks/BPCells},   url = {https://bnprks.github.io/BPCells}, }"},{"path":"https://bnprks.github.io/BPCells/index.html","id":"bpcells","dir":"","previous_headings":"","what":"Single Cell Counts Matrices to PCA","title":"Single Cell Counts Matrices to PCA","text":"site R package. Python site (experimental) BPCells package high performance single cell analysis RNA-seq ATAC-seq datasets. can analyze 1.3M cell dataset 2GB RAM around 10 minutes (benchmarks). makes analysis million-cell datasets practical laptop. BPCells provides: Efficient storage single cell datasets via bitpacking compression Fast, disk-backed RNA-seq ATAC-seq data processing powered C++ Downstream analysis marker genes, clustering Interoperability AnnData, 10x datasets, R sparse matrices, GRanges Additionally, BPCells exposes optimized data processing infrastructure use scaling 3rd party single cell tools (e.g. Seurat)","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"learn-more","dir":"","previous_headings":"","what":"Learn more","title":"Single Cell Counts Matrices to PCA","text":"Draft manuscript Benchmarks Multiomic analysis example BPCells works Additional articles Function documentation News","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"r-installation","dir":"","previous_headings":"","what":"R Installation","title":"Single Cell Counts Matrices to PCA","text":"recommend installing BPCells directly github: installing, must HDF5 library installed accessible system. HDF5 can installed choice package manager. Mac Windows users trouble installing github, check R-universe page instructions install pre-built binary packages. binary packages automatically track latest github main branch.","code":"remotes::install_github(\"bnprks/BPCells/r\")"},{"path":"https://bnprks.github.io/BPCells/index.html","id":"linux","dir":"","previous_headings":"R Installation","what":"Linux","title":"Single Cell Counts Matrices to PCA","text":"Obtaining HDF5 dependency usually pretty straightforward Linux apt: sudo apt-get install libhdf5-dev yum: sudo yum install hdf5-devel Note: Linux users prefer distro’s package manager (e.g. apt yum) possible, appears give slightly reliable installation experience.","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"windows","dir":"","previous_headings":"R Installation","what":"Windows","title":"Single Cell Counts Matrices to PCA","text":"Compiling R packages source Windows requires installing R tools Windows. See Issue #9 discussion.","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"macos","dir":"","previous_headings":"R Installation","what":"MacOS","title":"Single Cell Counts Matrices to PCA","text":"MacOS, installing HDF5 homebrew seems reliable: brew install hdf5. Mac-specific troubleshooting: Check R installation running sessionInfo(), seeing lists ARM x86 “Platform”. easiest option use ARM R homebrew default ARM hdf5 installation possible (though tricky) install x86 copy homebrew order access x86 version hdf5 Older Macs (10.14 Mojave older): default compiler old Macs support needed C++17 filesystem features. See issue #3 tips getting newer compiler set via homebrew.","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"supported-compilers","dir":"","previous_headings":"R Installation","what":"Supported compilers","title":"Single Cell Counts Matrices to PCA","text":"cases, already appropriate compiler. BPCells recommends gcc >=9.1, clang >= 9.0. corresponds versions late-2018 newer. Older versions may work cases long basic C++17 support, officially supported.","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"general-installation-troubleshooting","dir":"","previous_headings":"R Installation","what":"General Installation troubleshooting","title":"Single Cell Counts Matrices to PCA","text":"BPCells tries print informative error messages compilation help diagnose problem. verbose set information, run Sys.setenv(BPCELLS_DEBUG_INSTALL=\"true\") prior remotes::install_github(\"bnprks/BPCells/r\"). still can’t solve issue additional information, feel free file Github issue, sure use collapsible section verbose installation log.","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Single Cell Counts Matrices to PCA","text":"BPCells open source project, welcome quality contributions. interested contributing experience C++, along Python R, feel free reach ideas like implement . ’m happy provide pointers get started, time permitting. unfamiliar C++ difficult contribute code, detailed bug reports reproducible examples still useful way help . Github issues best forum . maintain single cell analysis package want use BPCells improve scalability, ’m happy provide advice. couple labs try far, promising success. Email best way get touch (look DESCRIPTION file github contact info). Python developers welcome, though full python package likely available summer 2023.","code":""},{"path":"https://bnprks.github.io/BPCells/python/api/fragments.html","id":null,"dir":"Python > Api","previous_headings":"","what":"Fragment functions#","title":null,"text":"experimental.import_10x_fragments(input, output) Convert 10x fragment file BPCells format experimental.build_cell_groups(fragments, ...) Build cell_groups array use pseudobulk_insertion_counts() experimental.pseudobulk_insertion_counts(...) Calculate pseudobulk coverage matrix experimental.precalculate_insertion_counts(...) Precalculate per-base insertion counts fragment data experimental.PrecalculatedInsertionMatrix(path) Disk-backed precalculated insertion matrix","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/api/matrix.html","id":null,"dir":"Python > Api","previous_headings":"","what":"Matrix functions#","title":null,"text":"experimental.DirMatrix(dir) Disk-backed BPCells integer matrix experimental.MemMatrix(dir[, threads]) -memory BPCells integer matrix","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.T.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.T#","title":null,"text":"property DirMatrix.T: DirMatrix[source]# Return transposed view matrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.from_h5ad.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.from_h5ad#","title":null,"text":"classmethod DirMatrix.from_h5ad(h5ad_path: str, out_dir: str, group: str = 'X') → DirMatrix[source]# Create DirMatrix h5ad file. Truncates floating point values integers Parameters: h5ad_path (str) – Path h5ad file out_dir (str) – Output path DirMatrix group (str, optional) – HDF5 group read matrix . Defaults “X”. Returns: View matrix written disk Return type: DirMatrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.from_hstack.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.from_hstack#","title":null,"text":"classmethod DirMatrix.from_hstack(mats: List[DirMatrix], out_dir: str) → DirMatrix[source]# Create DirMatrix concatenating list DirMatrix objects horizontally (column wise) Parameters: mats (List[DirMatrix]) – List input matrices out_dir (str) – Output path DirMatrix Returns: View matrix written disk Return type: DirMatrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.from_scipy_sparse.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.from_scipy_sparse#","title":null,"text":"classmethod DirMatrix.from_scipy_sparse(scipy_mat: spmatrix, dir: str) → DirMatrix[source]# Create DirMatrix scipy sparse matrix. write compressed sparse column format input types scipy.sparse.csr_matrix Parameters: scipy_mat (scipy.spmatrix) – Scipy sparse matrix dir (str) – Path write matrix Returns: View matrix written disk Return type: DirMatrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.from_vstack.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.from_vstack#","title":null,"text":"classmethod DirMatrix.from_vstack(mats: List[DirMatrix], out_dir: str) → DirMatrix[source]# Create DirMatrix concatenating list DirMatrix objects vertically (row wise) Parameters: mats (List[DirMatrix]) – List input matrices out_dir (str) – Output path DirMatrix Returns: View matrix written disk Return type: DirMatrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix#","title":null,"text":"class bpcells.experimental.DirMatrix(dir: str)[source]# Disk-backed BPCells integer matrix reads BPCells-format matrices, returning scipy.sparse.csc_matrix objects sliced. Parameters: dir (str) – Path matrix directory Examples Attributes DirMatrix.T Return transposed view matrix DirMatrix.shape Dimensions matrix DirMatrix.threads Number threads use reading (default=1) Methods DirMatrix.from_h5ad(h5ad_path, out_dir[, group]) Create DirMatrix h5ad file. DirMatrix.from_hstack(mats, out_dir) Create DirMatrix concatenating list DirMatrix objects horizontally (column wise) DirMatrix.from_scipy_sparse(scipy_mat, dir) Create DirMatrix scipy sparse matrix. DirMatrix.from_vstack(mats, out_dir) Create DirMatrix concatenating list DirMatrix objects vertically (row wise) DirMatrix.transpose() Return transposed view matrix","code":">>> from bpcells import DirMatrix >>> mat = DirMatrix(\"/path/to/matrix\") >>> mat[:,[1,3,2,4]] <3x4 sparse matrix of type '<class 'numpy.uint32'>'     with 6 stored elements in Compressed Sparse Column format>"},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.shape.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.shape#","title":null,"text":"DirMatrix.shape# Dimensions matrix Type: Tuple[int,int]","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.threads.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.threads#","title":null,"text":"DirMatrix.threads# Number threads use reading (default=1) Type: int","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.DirMatrix.transpose.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.DirMatrix.transpose#","title":null,"text":"DirMatrix.transpose() → DirMatrix[source]# Return transposed view matrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.MemMatrix.T.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.MemMatrix.T#","title":null,"text":"property MemMatrix.T: MemMatrix[source]# Return transposed view matrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.MemMatrix.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.MemMatrix#","title":null,"text":"class bpcells.experimental.MemMatrix(dir: str, threads: int = 0)[source]# -memory BPCells integer matrix reads BPCells-format matrices disk, returning scipy.sparse.csc_matrix objects sliced. much memory-intensive, consistently fast random reads Parameters: dir (str) – Path matrix directory Examples Attributes MemMatrix.T Return transposed view matrix MemMatrix.shape Dimensions matrix MemMatrix.threads Threads used reads (default=1) Methods MemMatrix.transpose() Return transposed view matrix","code":">>> from bpcells import MemMatrix >>> mat = MemMatrix(\"/path/to/matrix\") >>> mat[:,[1,3,2,4]] <3x4 sparse matrix of type '<class 'numpy.uint32'>'     with 6 stored elements in Compressed Sparse Column format>"},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.MemMatrix.shape.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.MemMatrix.shape#","title":null,"text":"MemMatrix.shape# Dimensions matrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.MemMatrix.threads.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.MemMatrix.threads#","title":null,"text":"MemMatrix.threads# Threads used reads (default=1)","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.MemMatrix.transpose.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.MemMatrix.transpose#","title":null,"text":"MemMatrix.transpose() → MemMatrix[source]# Return transposed view matrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.PrecalculatedInsertionMatrix.get_counts.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.PrecalculatedInsertionMatrix.get_counts#","title":null,"text":"PrecalculatedInsertionMatrix.get_counts(regions: DataFrame)[source]# Load pseudobulk insertion counts Parameters: regions (pandas.DataFrame) – Pandas dataframe columns (chrom, start, end) representing genomic ranges (0-based, end-exclusive like BED format). regions must size. chrom string column; start/end numeric. Returns: Numpy array dimensions (region, psudobulks, position) type numpy.int32 Return type: numpy.ndarray","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.PrecalculatedInsertionMatrix.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.PrecalculatedInsertionMatrix#","title":null,"text":"class bpcells.experimental.PrecalculatedInsertionMatrix(path: str)[source]# Disk-backed precalculated insertion matrix reads per-base precalculated insertion matrices. current implementation EXPERIMENTAL, crash matrices 2^32-1 non-zero entries. Parameters: dir (str) – Path matrix directory See also precalculate_insertion_counts() Attributes PrecalculatedInsertionMatrix.shape  Methods PrecalculatedInsertionMatrix.get_counts(regions) Load pseudobulk insertion counts","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.PrecalculatedInsertionMatrix.shape.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.PrecalculatedInsertionMatrix.shape#","title":null,"text":"property PrecalculatedInsertionMatrix.shape: Tuple[int, int][source]#","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.build_cell_groups.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.build_cell_groups#","title":null,"text":"bpcells.experimental.build_cell_groups(fragments: str, cell_ids: Sequence[str], group_ids: Sequence[str], group_order: Sequence[str]) → ndarray[source]# Build cell_groups array use pseudobulk_insertion_counts() Parameters: fragments (str) – Path BPCells fragments directory cell_ids (list[str]) – List cell IDs group_ids (list[str]) – List pseudobulk IDs cell (length cell_ids) group_order (list[str]) – Output order pseudobulks (Contain unique group_ids) Returns: Numpy array suitable input cell_groups pseudobulk_insertion_counts(). length total number cells fragments input, specifying output pseudobulk index cell (-1 cell excluded consideration) Return type: numpy.ndarray See also pseudobulk_insertion_counts()","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.import_10x_fragments.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.import_10x_fragments#","title":null,"text":"bpcells.experimental.import_10x_fragments(input: str, output: str, shift_start: int = 0, shift_end: int = 0, keeper_cells: List[str] | None = None)[source]# Convert 10x fragment file BPCells format Parameters: input (str) – Path 10x input file output (str) – Path BPCells output directory shift_start (int) – Basepairs add start coordinates (generally positive number) shift_end (int) – Basepairs subtract end coordinates (generally negative number) keeper_cells (list[str]) – None, save fragments cells keeper_cells list","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.precalculate_insertion_counts.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.precalculate_insertion_counts#","title":null,"text":"bpcells.experimental.precalculate_insertion_counts(fragments: str, output_dir: str, cell_groups: Sequence[int], chrom_sizes: str | Dict[str, int], threads: int = 0)[source]# Precalculate per-base insertion counts fragment data current implementation EXPERIMENTAL, crash matrices 2^32-1 non-zero entries. Parameters: fragments (str) – Path BPCells fragments directory output_dir (str) – Path save insertion counts cell_groups (list[int]) – List pseudbulk groupings created build_cell_groups() chrom_sizes (str | dict[str, int]) – Path/URL UCSC-style chrom.sizes file, dictionary mapping chromosome names sizes threads (int) – Number threads use matrix calculation (default = 1) Returns: PrecalculatedInsertionMatrix object See also PrecalculatedInsertionMatrix","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/generated/bpcells.experimental.pseudobulk_insertion_counts.html","id":null,"dir":"Python > Generated","previous_headings":"","what":"bpcells.experimental.pseudobulk_insertion_counts#","title":null,"text":"bpcells.experimental.pseudobulk_insertion_counts(fragments: str, regions: DataFrame, cell_groups: Sequence[int], bin_size: int = 1) → ndarray[source]# Calculate pseudobulk coverage matrix Coverage calculated number start/end coordinates falling given position bin. Parameters: fragments (str) – Path BPCells fragments directory regions (pandas.DataFrame) – Pandas dataframe columns (chrom, start, end) representing genomic ranges (0-based, end-exclusive like BED format). regions must size. chrom string column; start/end numeric. cell_groups (list[int]) – List pseudbulk groupings created build_cell_groups() bin_size (int) – Size bins within region given basepairs. region width even multiple resolution_bp, last region may truncated. Returns: Numpy array dimensions (region, psudobulks, position) type numpy.int32 Return type: numpy.ndarray See also build_cell_groups()","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/index.html","id":null,"dir":"Python","previous_headings":"","what":"BPCells#","title":null,"text":"BPCells python bindings still experimental API subject change. existing functionality mainly focused allowing read/write access BPCells file formats integer matrices scATAC fragments. Future updates add data-processing functions present R interface (e.g. streaming normalization, PCA, ATAC-seq peak/tile matrix creation). provide Python access shared C++ core code. Notably, plotting functionality currently planned implementation, written primarily R relies R plotting libraries present Python. helper functions R BPCells implemented pure R thus unlikely added Python near future. functionality interest , welcome contributions – able write code pure Python. Reach via github/email interested. BPCells can directly installed via pip: Matrix slicing Basepair insertion dataloading Fragment functions Matrix functions Installation Tutorials API Reference R Docs","code":"python -m pip install bpcells"},{"path":"https://bnprks.github.io/BPCells/python/index.html","id":null,"dir":"Python","previous_headings":"","what":"Installation#","title":null,"text":"BPCells can directly installed via pip:","code":"python -m pip install bpcells"},{"path":"https://bnprks.github.io/BPCells/python/index.html","id":null,"dir":"Python","previous_headings":"","what":"Tutorials#","title":null,"text":"Matrix slicing Basepair insertion dataloading","code":""},{"path":"https://bnprks.github.io/BPCells/python/index.html","id":null,"dir":"Python","previous_headings":"","what":"API Reference#","title":null,"text":"Fragment functions Matrix functions Installation Tutorials API Reference R Docs","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Basepair insertion counts tutorial#","title":null,"text":"BPCells python bindings can used query basepair-level coverage predefined cell types. way works two steps: 10x ArchR arrow files converted BPCells format. flexible BPCells R bindings, though single-sample 10x import supported python bindings. BPCells python bindings use input fragment files create large matrix dimensions (# cell types, # basepairs genome). cell type groupings determined. BPCells python bindings can slice arbitrary genomic regions, returning numpy array dimensions (regions, cell types, basepairs) Benchmark dataset: 600K cell subset Catlas paper, 2.5 billion fragments Benchmark task: Load 128 random 501-bp peak regions 111 cell types basepair resolution Storage location: Local SSD. Networked file systems slower  BPCells BigWigs Creation time 4.7 minutes, 8 threads ? File size 6.2 GB 13 GB Query time 0.37 seconds 2.2 seconds Cell type count aggregation can re-run fully Python Query time 6x faster BigWigs Caveat prototype: due development time limitations, insertion matrix implementation support >=2^32 non-zero entries (4.29 billion). catlas dataset 3.2 billion non-zero entries. limitation can removed additional technical work, workaround multiple matrix objects can created individually <2^32 non-zero entries.","code":""},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Benchmark estimates#","title":null,"text":"Benchmark dataset: 600K cell subset Catlas paper, 2.5 billion fragments Benchmark task: Load 128 random 501-bp peak regions 111 cell types basepair resolution Storage location: Local SSD. Networked file systems slower  BPCells BigWigs Creation time 4.7 minutes, 8 threads ? File size 6.2 GB 13 GB Query time 0.37 seconds 2.2 seconds","code":""},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Main benefits of BPCells#","title":null,"text":"Cell type count aggregation can re-run fully Python Query time 6x faster BigWigs Caveat prototype: due development time limitations, insertion matrix implementation support >=2^32 non-zero entries (4.29 billion). catlas dataset 3.2 billion non-zero entries. limitation can removed additional technical work, workaround multiple matrix objects can created individually <2^32 non-zero entries.","code":""},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Usage Demo#","title":null,"text":"use public 500-cell 10x dataset 484 rows × 20 columns Notice conversion allows adjusting start/end coordinates, well subsetting barcodes passing QC. Adding 1 end coordinate necessary 10x inputs produced cellranger calculate insertion matrix, first define cell groups, well ordering cell groups want output matrix. use first two characters cell barcode since annotated cell types available. Note possible leave cells calling build_cell_groups, case data included precalculated matrix Next, precalculate insertion counts matrix, can use parallelization speed portions work. can load pre-calculated matrix input path. query matrix, use pandas DataFrame, columns (chrom, start, end). regions must length BPCells returns numpy array dimensions (regions, cell types, basepairs), holding per-base counts cell type simple wrap matrix pytorch-compatible dataset, given set regions training set. Note use non-standard __getitems__() function pytorch uses provide batched loading higher performance. dataset object can directly passed torch.utils.data.DataLoader.","code":"import bpcells.experimental  import pandas as pd import os.path import subprocess import tempfile tmpdir = tempfile.TemporaryDirectory() fragments_10x_path = os.path.join(tmpdir.name, \"atac_fragments.tsv.gz\")  data_url = \"https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_fragments.tsv.gz\" subprocess.run([\"curl\", \"--silent\", data_url], stdout=open(fragments_10x_path, \"w\")) CompletedProcess(args=['curl', '--silent', 'https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_fragments.tsv.gz'], returncode=0) metadata_url = \"https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_singlecell.csv\" metadata_path = os.path.join(tmpdir.name, \"cell_metadata.csv\") subprocess.run([\"curl\", \"--silent\", metadata_url], stdout=open(metadata_path, \"w\"))  cell_metadata = pd.read_csv(metadata_path) cell_metadata = cell_metadata[cell_metadata.is__cell_barcode == 1].reset_index() cell_metadata cell_metadata.is__cell_barcode.sum() np.int64(484) %%time fragments_bpcells_path = os.path.join(tmpdir.name, \"bpcells_fragments\") bpcells.experimental.import_10x_fragments(     input = fragments_10x_path,      output = fragments_bpcells_path,      shift_end=1,      keeper_cells=cell_metadata.barcode[cell_metadata.is__cell_barcode == 1] ) CPU times: user 3.43 s, sys: 74.9 ms, total: 3.51 s Wall time: 3.45 s %%time barcodes = cell_metadata.barcode clusters = cell_metadata.barcode.str.slice(0,2) cluster_order = sorted(set(clusters))  cell_groups_array = bpcells.experimental.build_cell_groups(fragments_bpcells_path, barcodes, clusters, cluster_order)  # We could provide a dict or local file path, but URL is easier chrom_sizes = \"http://hgdownload.cse.ucsc.edu/goldenpath/hg38/bigZips/hg38.chrom.sizes\"  insertions_matrix_path = os.path.join(tmpdir.name, \"bpcells_insertions_matrix\")  bpcells.experimental.precalculate_insertion_counts(     fragments_bpcells_path,      insertions_matrix_path,      cell_groups_array,      chrom_sizes,      threads=4 ) CPU times: user 3min 8s, sys: 710 ms, total: 3min 8s Wall time: 1min 45s <PrecalculatedInsertionMatrix with 16 pseudobulks and 24 chromomsomes stored in  \t/tmp/tmpenistmm7/bpcells_insertions_matrix mat = bpcells.experimental.PrecalculatedInsertionMatrix(insertions_matrix_path) mat <PrecalculatedInsertionMatrix with 16 pseudobulks and 24 chromomsomes stored in  \t/tmp/tmpenistmm7/bpcells_insertions_matrix mat.shape (np.uint32(16), np.uint32(3088269832)) query_regions = pd.DataFrame({     \"chrom\": [\"chr1\", \"chr1\", \"chr6\"],     \"start\": [1_000_000, 2_000_000, 10_000_000], }) query_regions[\"end\"] = query_regions.start + 1000 query_regions x = mat.get_counts(query_regions) x array([[[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]],         [[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]],         [[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]]], dtype=int32) x.shape (3, 16, 1000) x.sum() np.int64(363) class BPCellsDataset:     def __init__(self, regions, matrix_dir):         self.regions = regions[[\"chrom\", \"start\", \"end\"]]          matrix_dir = str(os.path.abspath(os.path.expanduser(matrix_dir)))         self.mat = bpcells.experimental.PrecalculatedInsertionMatrix(matrix_dir)                  peak_width = self.regions.end[0] - self.regions.start[0]         assert (self.regions.end - self.regions.start == peak_width).all()      def __getitem__(self, i):         return self.__getitems__([i])[0]      def __getitems__(self, idx):         # Adding this function allows for batched loading         # See: https://github.com/pytorch/pytorch/issues/107218          # Return tensor of shape (batch_size, n_tasks, basepairs)         return self.mat.get_counts(             self.regions.iloc[idx,]         )      def __len__(self):         return self.regions.shape[0]"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Data download#","title":null,"text":"use public 500-cell 10x dataset 484 rows × 20 columns","code":"import os.path import subprocess import tempfile tmpdir = tempfile.TemporaryDirectory() fragments_10x_path = os.path.join(tmpdir.name, \"atac_fragments.tsv.gz\")  data_url = \"https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_fragments.tsv.gz\" subprocess.run([\"curl\", \"--silent\", data_url], stdout=open(fragments_10x_path, \"w\")) CompletedProcess(args=['curl', '--silent', 'https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_fragments.tsv.gz'], returncode=0) metadata_url = \"https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_singlecell.csv\" metadata_path = os.path.join(tmpdir.name, \"cell_metadata.csv\") subprocess.run([\"curl\", \"--silent\", metadata_url], stdout=open(metadata_path, \"w\"))  cell_metadata = pd.read_csv(metadata_path) cell_metadata = cell_metadata[cell_metadata.is__cell_barcode == 1].reset_index() cell_metadata cell_metadata.is__cell_barcode.sum() np.int64(484)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Convert to BPCells format#","title":null,"text":"Notice conversion allows adjusting start/end coordinates, well subsetting barcodes passing QC. Adding 1 end coordinate necessary 10x inputs produced cellranger","code":"%%time fragments_bpcells_path = os.path.join(tmpdir.name, \"bpcells_fragments\") bpcells.experimental.import_10x_fragments(     input = fragments_10x_path,      output = fragments_bpcells_path,      shift_end=1,      keeper_cells=cell_metadata.barcode[cell_metadata.is__cell_barcode == 1] ) CPU times: user 3.43 s, sys: 74.9 ms, total: 3.51 s Wall time: 3.45 s"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Create the insertion matrix#","title":null,"text":"calculate insertion matrix, first define cell groups, well ordering cell groups want output matrix. use first two characters cell barcode since annotated cell types available. Note possible leave cells calling build_cell_groups, case data included precalculated matrix Next, precalculate insertion counts matrix, can use parallelization speed portions work.","code":"%%time barcodes = cell_metadata.barcode clusters = cell_metadata.barcode.str.slice(0,2) cluster_order = sorted(set(clusters))  cell_groups_array = bpcells.experimental.build_cell_groups(fragments_bpcells_path, barcodes, clusters, cluster_order)  # We could provide a dict or local file path, but URL is easier chrom_sizes = \"http://hgdownload.cse.ucsc.edu/goldenpath/hg38/bigZips/hg38.chrom.sizes\"  insertions_matrix_path = os.path.join(tmpdir.name, \"bpcells_insertions_matrix\")  bpcells.experimental.precalculate_insertion_counts(     fragments_bpcells_path,      insertions_matrix_path,      cell_groups_array,      chrom_sizes,      threads=4 ) CPU times: user 3min 8s, sys: 710 ms, total: 3min 8s Wall time: 1min 45s <PrecalculatedInsertionMatrix with 16 pseudobulks and 24 chromomsomes stored in  \t/tmp/tmpenistmm7/bpcells_insertions_matrix"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Querying the insertion matrix#","title":null,"text":"can load pre-calculated matrix input path. query matrix, use pandas DataFrame, columns (chrom, start, end). regions must length BPCells returns numpy array dimensions (regions, cell types, basepairs), holding per-base counts cell type","code":"mat = bpcells.experimental.PrecalculatedInsertionMatrix(insertions_matrix_path) mat <PrecalculatedInsertionMatrix with 16 pseudobulks and 24 chromomsomes stored in  \t/tmp/tmpenistmm7/bpcells_insertions_matrix mat.shape (np.uint32(16), np.uint32(3088269832)) query_regions = pd.DataFrame({     \"chrom\": [\"chr1\", \"chr1\", \"chr6\"],     \"start\": [1_000_000, 2_000_000, 10_000_000], }) query_regions[\"end\"] = query_regions.start + 1000 query_regions x = mat.get_counts(query_regions) x array([[[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]],         [[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]],         [[0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         ...,         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0],         [0, 0, 0, ..., 0, 0, 0]]], dtype=int32) x.shape (3, 16, 1000) x.sum() np.int64(363)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/fragment_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Pytorch-compatible dataset#","title":null,"text":"simple wrap matrix pytorch-compatible dataset, given set regions training set. Note use non-standard __getitems__() function pytorch uses provide batched loading higher performance. dataset object can directly passed torch.utils.data.DataLoader.","code":"class BPCellsDataset:     def __init__(self, regions, matrix_dir):         self.regions = regions[[\"chrom\", \"start\", \"end\"]]          matrix_dir = str(os.path.abspath(os.path.expanduser(matrix_dir)))         self.mat = bpcells.experimental.PrecalculatedInsertionMatrix(matrix_dir)                  peak_width = self.regions.end[0] - self.regions.start[0]         assert (self.regions.end - self.regions.start == peak_width).all()      def __getitem__(self, i):         return self.__getitems__([i])[0]      def __getitems__(self, idx):         # Adding this function allows for batched loading         # See: https://github.com/pytorch/pytorch/issues/107218          # Return tensor of shape (batch_size, n_tasks, basepairs)         return self.mat.get_counts(             self.regions.iloc[idx,]         )      def __len__(self):         return self.regions.shape[0]"},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Matrix slicing tutorial#","title":null,"text":"BPCells prototype Python bindings allow matrix creation slicing, optional multithreaded reads. scimilarity dataset 15M human cells, compressed storage 64GB (2.2 bytes/non-zero) Read speeds 10k random cells 15M human cells (range 5 random tests) Storage location 1 thread 4 threads Memory 2.8-4.7 seconds 1.0-1.1 seconds Local SSD 4.5-4.9 seconds 1.5-1.7 seconds Networked FS (warm cache) 20-21 seconds 5.5-6.2 seconds Networked FS (cold cache) 🙁 76-115 seconds Slicing matrix returns scipy.sparse matrix can use many slicing options standard numpy matrices can also make transposed view matrix similar numpy. work done, just switch row-major col-major representations matrix path 13 files (compressed integer matrices), contain data metadata can concatenate multiple matrices single file disk low memory usage. allows importing many samples parallel, concatenating together single matrix larger matrices, can desirable perform matrix reading multi-threaded manner. using multiple threads, BPCells divide matrix slice query chunks loaded parallel, recombined memory threads completed. performing random slicing along major storage axis, seek latency primary performance bottleneck. Setting high number threads (even actual core count machine) can help mitigate filesystem seek latency. slicing across non-major storage axis, decompression speed can become performance bottleneck. Setting threads number available cores can help parallelize decompression speed. cell-major RNA-seq matrices, thread can process compressed input rate 1 GB/s, filesystems >1GB/s sequential read speeds benefit parallelization. neural network training use-cases, fast slicing performance may critical avoid bottlenecking data loads. case, BPCells supports loading compressed data memory, eliminates seek latency saving ~4x memory usage compared uncompressed scipy sparse matrix. Loading can performed existing BPCells matrix directory, current version involves re-compressing data -memory load time (avoidable, bit trickier code direct loading isn’t implemented yet)","code":"import bpcells.experimental  import os import tempfile  import numpy as np import scipy.sparse tmp = tempfile.TemporaryDirectory() os.chdir(tmp.name) mat = scipy.sparse.csc_matrix(np.array([     [1, 0, 4, 0],     [0, 0, 5, 7],     [2, 3, 6, 0]] )) mat <Compressed Sparse Column sparse matrix of dtype 'int64' \twith 7 stored elements and shape (3, 4)> mat.toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]]) bp_mat = bpcells.experimental.DirMatrix.from_scipy_sparse(mat, \"basic_mat\") bp_mat <3x4 col-major sparse array stored in  \t/tmp/tmpgnnfj3gp/basic_mat> bp_mat[:,:] <Compressed Sparse Column sparse matrix of dtype 'uint32' \twith 7 stored elements and shape (3, 4)> bp_mat[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32) bp_mat[1:3, [0,2]].toarray() array([[0, 5],        [2, 6]], dtype=uint32) bp_mat[[True, False, True], -2:].toarray() array([[4, 0],        [6, 0]], dtype=uint32) bp_mat.T <4x3 row-major sparse array stored in  \t/tmp/tmpgnnfj3gp/basic_mat> !ls -l basic_mat total 44 -rw-rw-r-- 1 bparks bparks  0 Aug 25 00:51 col_names -rw-rw-r-- 1 bparks bparks 48 Aug 25 00:51 idxptr -rw-rw-r-- 1 bparks bparks 56 Aug 25 00:51 index_data -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 index_idx -rw-rw-r-- 1 bparks bparks 24 Aug 25 00:51 index_idx_offsets -rw-rw-r-- 1 bparks bparks 12 Aug 25 00:51 index_starts -rw-rw-r-- 1 bparks bparks  0 Aug 25 00:51 row_names -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 shape -rw-rw-r-- 1 bparks bparks  4 Aug 25 00:51 storage_order -rw-rw-r-- 1 bparks bparks 56 Aug 25 00:51 val_data -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 val_idx -rw-rw-r-- 1 bparks bparks 24 Aug 25 00:51 val_idx_offsets -rw-rw-r-- 1 bparks bparks 22 Aug 25 00:51 version bp_mat = bpcells.experimental.DirMatrix(\"basic_mat\") import anndata anndata.AnnData(mat).write(\"mat.h5ad\") bp_mat = bpcells.experimental.DirMatrix.from_h5ad(\"mat.h5ad\", \"basic_mat_from_h5ad\") bp_mat[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32) bpcells.experimental.DirMatrix.from_hstack(     [bp_mat, bp_mat],      \"basic_mat_hstack\" )[:,:].toarray() array([[1, 0, 4, 0, 1, 0, 4, 0],        [0, 0, 5, 7, 0, 0, 5, 7],        [2, 3, 6, 0, 2, 3, 6, 0]], dtype=uint32) bpcells.experimental.DirMatrix.from_vstack(     [bp_mat, bp_mat],      \"basic_mat_vstack\" )[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0],        [1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32) bp_mat.threads = 8 bp_mat[:,:].toarray() # This will be performed with 8 threads now array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32) bp_mat_mem = bpcells.experimental.MemMatrix(\"basic_mat\") bp_mat_mem.threads = 8 bp_mat_mem[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Performance estimates#","title":null,"text":"scimilarity dataset 15M human cells, compressed storage 64GB (2.2 bytes/non-zero) Read speeds 10k random cells 15M human cells (range 5 random tests) Storage location 1 thread 4 threads Memory 2.8-4.7 seconds 1.0-1.1 seconds Local SSD 4.5-4.9 seconds 1.5-1.7 seconds Networked FS (warm cache) 20-21 seconds 5.5-6.2 seconds Networked FS (cold cache) 🙁 76-115 seconds","code":""},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Demo data setup#","title":null,"text":"","code":"import bpcells.experimental  import os import tempfile  import numpy as np import scipy.sparse tmp = tempfile.TemporaryDirectory() os.chdir(tmp.name) mat = scipy.sparse.csc_matrix(np.array([     [1, 0, 4, 0],     [0, 0, 5, 7],     [2, 3, 6, 0]] )) mat <Compressed Sparse Column sparse matrix of dtype 'int64' \twith 7 stored elements and shape (3, 4)> mat.toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]])"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Basic usage from scipy.sparse#","title":null,"text":"Slicing matrix returns scipy.sparse matrix can use many slicing options standard numpy matrices can also make transposed view matrix similar numpy. work done, just switch row-major col-major representations","code":"bp_mat = bpcells.experimental.DirMatrix.from_scipy_sparse(mat, \"basic_mat\") bp_mat <3x4 col-major sparse array stored in  \t/tmp/tmpgnnfj3gp/basic_mat> bp_mat[:,:] <Compressed Sparse Column sparse matrix of dtype 'uint32' \twith 7 stored elements and shape (3, 4)> bp_mat[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32) bp_mat[1:3, [0,2]].toarray() array([[0, 5],        [2, 6]], dtype=uint32) bp_mat[[True, False, True], -2:].toarray() array([[4, 0],        [6, 0]], dtype=uint32) bp_mat.T <4x3 row-major sparse array stored in  \t/tmp/tmpgnnfj3gp/basic_mat>"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Reopening the matrix later#","title":null,"text":"matrix path 13 files (compressed integer matrices), contain data metadata","code":"!ls -l basic_mat total 44 -rw-rw-r-- 1 bparks bparks  0 Aug 25 00:51 col_names -rw-rw-r-- 1 bparks bparks 48 Aug 25 00:51 idxptr -rw-rw-r-- 1 bparks bparks 56 Aug 25 00:51 index_data -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 index_idx -rw-rw-r-- 1 bparks bparks 24 Aug 25 00:51 index_idx_offsets -rw-rw-r-- 1 bparks bparks 12 Aug 25 00:51 index_starts -rw-rw-r-- 1 bparks bparks  0 Aug 25 00:51 row_names -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 shape -rw-rw-r-- 1 bparks bparks  4 Aug 25 00:51 storage_order -rw-rw-r-- 1 bparks bparks 56 Aug 25 00:51 val_data -rw-rw-r-- 1 bparks bparks 16 Aug 25 00:51 val_idx -rw-rw-r-- 1 bparks bparks 24 Aug 25 00:51 val_idx_offsets -rw-rw-r-- 1 bparks bparks 22 Aug 25 00:51 version bp_mat = bpcells.experimental.DirMatrix(\"basic_mat\")"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Import from h5ad#","title":null,"text":"","code":"import anndata anndata.AnnData(mat).write(\"mat.h5ad\") bp_mat = bpcells.experimental.DirMatrix.from_h5ad(\"mat.h5ad\", \"basic_mat_from_h5ad\") bp_mat[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Concatenate multiple matrices#","title":null,"text":"can concatenate multiple matrices single file disk low memory usage. allows importing many samples parallel, concatenating together single matrix","code":"bpcells.experimental.DirMatrix.from_hstack(     [bp_mat, bp_mat],      \"basic_mat_hstack\" )[:,:].toarray() array([[1, 0, 4, 0, 1, 0, 4, 0],        [0, 0, 5, 7, 0, 0, 5, 7],        [2, 3, 6, 0, 2, 3, 6, 0]], dtype=uint32) bpcells.experimental.DirMatrix.from_vstack(     [bp_mat, bp_mat],      \"basic_mat_vstack\" )[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0],        [1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Multithreaded operation#","title":null,"text":"larger matrices, can desirable perform matrix reading multi-threaded manner. using multiple threads, BPCells divide matrix slice query chunks loaded parallel, recombined memory threads completed. performing random slicing along major storage axis, seek latency primary performance bottleneck. Setting high number threads (even actual core count machine) can help mitigate filesystem seek latency. slicing across non-major storage axis, decompression speed can become performance bottleneck. Setting threads number available cores can help parallelize decompression speed. cell-major RNA-seq matrices, thread can process compressed input rate 1 GB/s, filesystems >1GB/s sequential read speeds benefit parallelization.","code":"bp_mat.threads = 8 bp_mat[:,:].toarray() # This will be performed with 8 threads now array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32)"},{"path":"https://bnprks.github.io/BPCells/python/notebooks/matrix_basics.html","id":null,"dir":"Python > Notebooks","previous_headings":"","what":"Compressed in-memory storage#","title":null,"text":"neural network training use-cases, fast slicing performance may critical avoid bottlenecking data loads. case, BPCells supports loading compressed data memory, eliminates seek latency saving ~4x memory usage compared uncompressed scipy sparse matrix. Loading can performed existing BPCells matrix directory, current version involves re-compressing data -memory load time (avoidable, bit trickier code direct loading isn’t implemented yet)","code":"bp_mat_mem = bpcells.experimental.MemMatrix(\"basic_mat\") bp_mat_mem.threads = 8 bp_mat_mem[:,:].toarray() array([[1, 0, 4, 0],        [0, 0, 5, 7],        [2, 3, 6, 0]], dtype=uint32)"},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/python/python.html","id":null,"dir":"Python","previous_headings":"","what":"Python Docs#","title":null,"text":"BPCells python bindings still experimental API subject change. existing functionality mainly focused allowing read/write access BPCells file formats integer matrices scATAC fragments. Future updates add data-processing functions present R interface (e.g. streaming normalization, PCA, ATAC-seq peak/tile matrix creation). provide Python access shared C++ core code. Notably, plotting functionality currently planned implementation, written primarily R relies R plotting libraries present Python. helper functions R BPCells implemented pure R thus unlikely added Python near future. functionality interest , welcome contributions – able write code pure Python. Reach via github/email interested. BPCells can directly installed via pip: Matrix slicing Basepair insertion dataloading Fragment functions Matrix functions","code":"python -m pip install bpcells"},{"path":"https://bnprks.github.io/BPCells/python/python.html","id":null,"dir":"Python","previous_headings":"","what":"Installation#","title":null,"text":"BPCells can directly installed via pip:","code":"python -m pip install bpcells"},{"path":"https://bnprks.github.io/BPCells/python/python.html","id":null,"dir":"Python","previous_headings":"","what":"Tutorials#","title":null,"text":"Matrix slicing Basepair insertion dataloading","code":""},{"path":"https://bnprks.github.io/BPCells/python/python.html","id":null,"dir":"Python","previous_headings":"","what":"API Reference#","title":null,"text":"Fragment functions Matrix functions","code":""},{"path":[]},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_open_matrix_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Open experimental sparse-column format integer matrix — EXPERIMENTAL_open_matrix_dir","title":"Open experimental sparse-column format integer matrix — EXPERIMENTAL_open_matrix_dir","text":"experimental sparse-column format designed handle storage matrices many columns -zero, less 2^32-1 non-zero entries.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_open_matrix_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open experimental sparse-column format integer matrix — EXPERIMENTAL_open_matrix_dir","text":"","code":"EXPERIMENTAL_open_matrix_dir(dir, buffer_size = 8192L)"},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_open_matrix_dir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Open experimental sparse-column format integer matrix — EXPERIMENTAL_open_matrix_dir","text":"dir Directory load data buffer_size performance tuning . number items buffered memory calling writes disk.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_write_matrix_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Write to experimental sparse-column format integer matrix — EXPERIMENTAL_write_matrix_dir","title":"Write to experimental sparse-column format integer matrix — EXPERIMENTAL_write_matrix_dir","text":"experimental sparse-column format designed handle storage matrices many columns -zero, less 2^32-1 non-zero entries.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_write_matrix_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write to experimental sparse-column format integer matrix — EXPERIMENTAL_write_matrix_dir","text":"","code":"EXPERIMENTAL_write_matrix_dir(mat, dir, buffer_size = 8192L, overwrite = FALSE)"},{"path":"https://bnprks.github.io/BPCells/reference/EXPERIMENTAL_write_matrix_dir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write to experimental sparse-column format integer matrix — EXPERIMENTAL_write_matrix_dir","text":"dir Directory save data overwrite TRUE, write temp dir overwrite existing data. Alternatively, pass temp path string customize temp dir location.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"IterableFragments methods — IterableFragments-methods","title":"IterableFragments methods — IterableFragments-methods","text":"Methods IterableFragments objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IterableFragments methods — IterableFragments-methods","text":"","code":"# S4 method for class 'IterableFragments' show(object)  cellNames(x)  cellNames(x, ...) <- value  chrNames(x)  chrNames(x, ...) <- value"},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IterableFragments methods — IterableFragments-methods","text":"object IterableFragments object x IterableFragments object value Character vector new names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"IterableFragments methods — IterableFragments-methods","text":"cellNames() Character vector cell names, NULL none known chrNames(): Character vector chromosome names, NULL none known","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IterableFragments methods — IterableFragments-methods","text":"cellNames<- possible replace names, add new names. chrNames<- possible replace names, add new names.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"IterableFragments methods — IterableFragments-methods","text":"show(IterableFragments): Print IterableFragments cellNames(): Get cell names cellNames(x, ...) <- value: Set cell names chrNames(): Set chromosome names chrNames(x, ...) <- value: Set chromosome names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"IterableMatrix methods — IterableMatrix-methods","title":"IterableMatrix methods — IterableMatrix-methods","text":"Generic methods built-functions IterableMatrix objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IterableMatrix methods — IterableMatrix-methods","text":"","code":"matrix_type(x)  storage_order(x)  # S4 method for class 'IterableMatrix' show(object)  # S4 method for class 'IterableMatrix' t(x)  # S4 method for class 'IterableMatrix,matrix' x %*% y  # S4 method for class 'IterableMatrix' rowSums(x)  # S4 method for class 'IterableMatrix' colSums(x)  # S4 method for class 'IterableMatrix' rowMeans(x)  # S4 method for class 'IterableMatrix' colMeans(x)  colVars(   x,   rows = NULL,   cols = NULL,   na.rm = FALSE,   center = NULL,   ...,   useNames = TRUE )  rowVars(   x,   rows = NULL,   cols = NULL,   na.rm = FALSE,   center = NULL,   ...,   useNames = TRUE )  rowMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)  colMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)  rowQuantiles(   x,   rows = NULL,   cols = NULL,   probs = seq(from = 0, to = 1, by = 0.25),   na.rm = FALSE,   type = 7L,   digits = 7L,   ...,   useNames = TRUE,   drop = TRUE )  colQuantiles(   x,   rows = NULL,   cols = NULL,   probs = seq(from = 0, to = 1, by = 0.25),   na.rm = FALSE,   type = 7L,   digits = 7L,   ...,   useNames = TRUE,   drop = TRUE )  # S4 method for class 'IterableMatrix' log1p(x)  log1p_slow(x)  # S4 method for class 'IterableMatrix' expm1(x)  expm1_slow(x)  # S4 method for class 'IterableMatrix,numeric' e1^e2  # S4 method for class 'numeric,IterableMatrix' e1 < e2  # S4 method for class 'IterableMatrix,numeric' e1 > e2  # S4 method for class 'numeric,IterableMatrix' e1 <= e2  # S4 method for class 'IterableMatrix,numeric' e1 >= e2  # S4 method for class 'IterableMatrix' round(x, digits = 0)  # S4 method for class 'IterableMatrix,numeric' e1 * e2  # S4 method for class 'IterableMatrix,numeric' e1 + e2  # S4 method for class 'IterableMatrix,numeric' e1/e2  # S4 method for class 'IterableMatrix,numeric' e1 - e2"},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IterableMatrix methods — IterableMatrix-methods","text":"x IterableMatrix object matrix-like object. object IterableMatrix object y matrix probs (Numeric) Quantile value(s) computed, 0 1. type (Integer) 4 9 selecting quantile algorithm use, detailed matrixStats::rowQuantiles()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"IterableMatrix methods — IterableMatrix-methods","text":"t() Transposed object x %*% y: dense matrix result rowSums(): vector row sums colSums(): vector col sums rowMeans(): vector row means colMeans(): vector col means colVars(): vector col variance rowVars(): vector row variance rowMaxs(): vector maxes every row colMaxs(): vector column maxes rowQuantiles(): length(probs) == 1, return numeric number entries equal number rows matrix. Else, return Matrix quantile values, cols representing quantile, row representing row input matrix. colQuantiles(): length(probs) == 1, return numeric number entries equal number columns matrix. Else, return Matrix quantile values, cols representing quantile, row representing col input matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"IterableMatrix methods — IterableMatrix-methods","text":"matrix_type(): Get matrix data type (mat_uint32_t, mat_float, mat_double now) storage_order(): Get matrix storage order (\"row\" \"col\") show(IterableMatrix): Display IterableMatrix t(IterableMatrix): Transpose IterableMatrix x %*% y: Multiply dense matrix rowSums(IterableMatrix): Calculate rowSums colSums(IterableMatrix): Calculate colSums rowMeans(IterableMatrix): Calculate rowMeans colMeans(IterableMatrix): Calculate colMeans colVars(): Calculate colVars (replacement matrixStats::colVars()) rowVars(): Calculate rowVars (replacement matrixStats::rowVars()) rowMaxs(): Calculate rowMaxs (replacement matrixStats::rowMaxs()) colMaxs(): Calculate colMax (replacement matrixStats::colMax()) rowQuantiles(): Calculate rowQuantiles (replacement matrixStats::rowQuantiles) colQuantiles(): Calculate colQuantiles (replacement matrixStats::colQuantiles) log1p(IterableMatrix): Calculate log(x + 1) log1p_slow(): Calculate log(x + 1) (non-SIMD version) expm1(IterableMatrix): Calculate exp(x) - 1 expm1_slow(): Calculate exp(x) - 1 (non-SIMD version) e1^e2: Calculate x^y (elementwise) e1 < e2: Binarize matrix according numeric < matrix comparison e1 > e2: Binarize matrix according matrix > numeric comparison e1 <= e2: Binarize matrix according numeric <= matrix comparison e1 >= e2: Binarize matrix according matrix >= numeric comparison round(IterableMatrix): round nearest integer (digits must 0) e1 * e2: Multiply constant, multiply rows vector length nrow(mat) e1 + e2: Add constant, row-wise addition vector length nrow(mat) e1 / e2: Divide constant, divide rows vector length nrow(mat) e1 - e2: Subtract constant, row-wise subtraction vector length nrow(mat)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/LinearOperator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Represent a sparse matrix-vector product operation — LinearOperator-class","title":"Represent a sparse matrix-vector product operation — LinearOperator-class","text":"LinearOperators perform sparse matrix-vector product operations downstream matrix solvers. avoid repeatedly calling iterate_matrix SVD solver possible efficiency gain","code":""},{"path":"https://bnprks.github.io/BPCells/reference/all_matrix_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Get/set inputs to a matrix transform — all_matrix_inputs","title":"Get/set inputs to a matrix transform — all_matrix_inputs","text":"matrix object can either input (.e. file disk raw matrix memory), can represent delayed operation one matrices. all_matrix_inputs() getter setter functions allow accessing base-level input matrices list, changing . useful want re-locate data disk without losing transformed BPCells matrix. (Note: experimental API; potentially subject revisions).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/all_matrix_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get/set inputs to a matrix transform — all_matrix_inputs","text":"","code":"all_matrix_inputs(x)  all_matrix_inputs(x) <- value"},{"path":"https://bnprks.github.io/BPCells/reference/all_matrix_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get/set inputs to a matrix transform — all_matrix_inputs","text":"x IterableMatrix value List IterableMatrix objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/all_matrix_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get/set inputs to a matrix transform — all_matrix_inputs","text":"List IterableMatrix objects. matrix m input object, all_matrix_inputs(m) return list(m).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/apply_by_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to summarize rows/cols — apply_by_row","title":"Apply a function to summarize rows/cols — apply_by_row","text":"Apply custom R function row/col BPCells matrix. run slower builtin C++-backed functions, keep memory benefits disk-backed operations.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/apply_by_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to summarize rows/cols — apply_by_row","text":"","code":"apply_by_row(mat, fun, ...)  apply_by_col(mat, fun, ...)"},{"path":"https://bnprks.github.io/BPCells/reference/apply_by_row.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to summarize rows/cols — apply_by_row","text":"mat IterableMatrix object fun function(val, row, col) takes row/col values returns summary output. Argument details: val - Vector length (# non-zero values) value non-zero matrix entry row - one-based row index (apply_by_col: vector length (# non-zero values), apply_by_row: single integer) col - one-based col index (apply_by_col: single integer, apply_by_row: vector length (# non-zero values)) ... - Optional additional arguments (named row, col, val) ... Optional additional arguments passed fun","code":""},{"path":"https://bnprks.github.io/BPCells/reference/apply_by_row.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to summarize rows/cols — apply_by_row","text":"apply_by_row - list length nrow(matrix) results returned fun() row apply_by_col - list length ncol(matrix) results returned fun() row","code":""},{"path":"https://bnprks.github.io/BPCells/reference/apply_by_row.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function to summarize rows/cols — apply_by_row","text":"functions require row-major matrix storage apply_by_row col-major storage apply_by_col, matrices stored wrong order may neeed re-ordered copy created using transpose_storage_order() first. required able keep memory-usage low allow calculating result single streaming pass input matrix. vector/matrix outputs desired instead lists, calling unlist(x) .call(cbind, x) .call(rbind, x) can convert list output.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/binarize.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert matrix elements to zeros and ones — binarize","title":"Convert matrix elements to zeros and ones — binarize","text":"Binarize compares matrix element values threshold value sets output elements either zero one. default, element values greater threshold set one; otherwise, set zero. strict_inequality set FALSE, element values greater equal threshold set one. alternative, <, <=, >, >= operators also supported.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/binarize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert matrix elements to zeros and ones — binarize","text":"","code":"binarize(mat, threshold = 0, strict_inequality = TRUE)"},{"path":"https://bnprks.github.io/BPCells/reference/binarize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert matrix elements to zeros and ones — binarize","text":"mat IterableMatrix threshold numeric value determines whether elements x set zero one. strict_inequality logical value determining whether comparison threshold >= (strict_inequality=FALSE) > (strict_inequality=TRUE).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/binarize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert matrix elements to zeros and ones — binarize","text":"binarized IterableMatrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_macs_peaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Call peaks using MACS2/3 — call_macs_peaks","title":"Call peaks using MACS2/3 — call_macs_peaks","text":"Export pseudobulk bed files input MACS, run MACS read output peaks tibble. step can can run independently, allowing quickly re-loading results already completed call, running MACS externally (e.g. via cluster job submisison) increased parallelization. See details information.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_macs_peaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call peaks using MACS2/3 — call_macs_peaks","text":"","code":"call_macs_peaks(   fragments,   path,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   effective_genome_size = 2.9e+09,   insertion_mode = c(\"start_only\", \"both\", \"end_only\"),   step = c(\"all\", \"prep-inputs\", \"run-macs\", \"read-outputs\"),   macs_executable = NULL,   additional_params =     \"--call-summits --keep-dup all --shift -75 --extsize 150 --nomodel --nolambda\",   verbose = FALSE,   threads = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/call_macs_peaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call peaks using MACS2/3 — call_macs_peaks","text":"fragments IterableFragments object path (string) Parent directory store MACS inputs outputs. Inputs stored <path>/input/ outputs <path>/output/<group>/. See \"File format\" details cell_groups Grouping vector one entry per cell fragments, e.g. cluster IDs effective_genome_size (numeric) Effective genome size MACS. Default 2.9e9 following MACS default GRCh38. See deeptools values common genomes. insertion_mode (string) fragment ends use coverage calculation. One , start_only, end_only. step (string) step run. One  , prep-inputs, run-macs, read-outputs.  prep-inputs, create input bed files macs, provides shell script per cell group command run macs.  run-macs, also run bash scripts execute macs. read-outputs, read outputs tibbles. macs_executable (string) Path either MACS2/3 executable. Default (NULL) autodetect PATH. additional_params (string) Additional parameters pass MACS2/3. verbose (bool) Whether provide verbose output MACS. used step run-macs . threads (int) Number threads use.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_macs_peaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call peaks using MACS2/3 — call_macs_peaks","text":"step prep-inputs, return script paths cell group given character vector. step run-macs, return NULL. step read-outputs , returns tibble peaks cell group concatenated. Columnns chr, start, end, group, name, score, strand, fold_enrichment, log10_pvalue, log10_qvalue, summit_offset","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_macs_peaks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call peaks using MACS2/3 — call_macs_peaks","text":"File format: Inputs written bed file used input MACS, well shell file containing call MACS written cell group. Bed files containing chr, start, end coordinates insertions written <path>/input/<group>.bed.gz. Shell commands run MACS manually written <path>/input/<group>.sh. Outputs written output directory subdirectory cell group. cell group's output directory contains file narrowPeaks, peaks, summits. NarrowPeaks written <path>/output/<group>/<group>_peaks.narrowPeak. Peaks written <path>/output/<group>/<group>_peaks.xls. Summits written <path>/output/<group>/<group>_summits.bed. narrowPeaks file read tibble returned. information outputs MACS, visit MACS docs Performance: Running 2600 cell dataset taking start end insertions account, written input bedfiles MACS outputs used 364 MB 158 MB space respectively.  4 threads, running function end end took 74 seconds, 61 seconds spent running MACS. Running MACS manually: run MACS manually, first run call_macs_peaks() step=\"prep-inputs. , manually run shell scripts generated <path>/input/<group>.sh. Finally, run call_macs_peaks() original arguments, setting step=\"read-outputs\".","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_macs.html","id":null,"dir":"Reference","previous_headings":"","what":"Call peaks using MACS2/3 — call_peaks_macs","title":"Call peaks using MACS2/3 — call_peaks_macs","text":"Export pseudobulk bed files input MACS, run MACS read output peaks tibble. step can can run independently, allowing quickly re-loading results already completed call, running MACS externally (e.g. via cluster job submisison) increased parallelization. See details information.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_macs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call peaks using MACS2/3 — call_peaks_macs","text":"","code":"call_peaks_macs(   fragments,   path,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   effective_genome_size = 2.9e+09,   insertion_mode = c(\"both\", \"start_only\", \"end_only\"),   step = c(\"all\", \"prep-inputs\", \"run-macs\", \"read-outputs\"),   macs_executable = NULL,   additional_params =     \"--call-summits --keep-dup all --shift -75 --extsize 150 --nomodel --nolambda\",   verbose = FALSE,   threads = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_macs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call peaks using MACS2/3 — call_peaks_macs","text":"fragments IterableFragments object path (string) Parent directory store MACS inputs outputs. Inputs stored <path>/input/ outputs <path>/output/<group>/. See \"File format\" details cell_groups Grouping vector one entry per cell fragments, e.g. cluster IDs effective_genome_size (numeric) Effective genome size MACS. Default 2.9e9 following MACS default GRCh38. See deeptools values common genomes. insertion_mode (string) fragment ends use coverage calculation. One , start_only, end_only. step (string) step run. One  , prep-inputs, run-macs, read-outputs.  prep-inputs, create input bed files macs, provides shell script per cell group command run macs.  run-macs, also run bash scripts execute macs. read-outputs, read outputs tibbles. macs_executable (string) Path either MACS2/3 executable. Default (NULL) autodetect PATH. additional_params (string) Additional parameters pass MACS2/3. verbose (bool) Whether provide verbose output MACS. used step run-macs . threads (int) Number threads use.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_macs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call peaks using MACS2/3 — call_peaks_macs","text":"step prep-inputs, return script paths cell group given character vector. step run-macs, return NULL. step read-outputs , returns tibble peaks cell group concatenated. Columnns chr, start, end, group, name, score, strand, fold_enrichment, log10_pvalue, log10_qvalue, summit_offset","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_macs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call peaks using MACS2/3 — call_peaks_macs","text":"File format: Inputs written bed file used input MACS, well shell file containing call MACS written cell group. Bed files containing chr, start, end coordinates insertions written <path>/input/<group>.bed.gz. Shell commands run MACS manually written <path>/input/<group>.sh. Outputs written output directory subdirectory cell group. cell group's output directory contains file narrowPeaks, peaks, summits. NarrowPeaks written <path>/output/<group>/<group>_peaks.narrowPeak. Peaks written <path>/output/<group>/<group>_peaks.xls. Summits written <path>/output/<group>/<group>_summits.bed. narrowPeaks file read tibble returned. information outputs MACS, visit MACS docs Performance: Running 2600 cell dataset taking start end insertions account, written input bedfiles MACS outputs used 364 MB 158 MB space respectively.  4 threads, running function end end took 74 seconds, 61 seconds spent running MACS. Running MACS manually: run MACS manually, first run call_peaks_macs() step=\"prep-inputs. , manually run shell scripts generated <path>/input/<group>.sh. Finally, run call_peaks_macs() original arguments, setting step=\"read-outputs\".","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":null,"dir":"Reference","previous_headings":"","what":"Call peaks from tiles — call_peaks_tile","title":"Call peaks from tiles — call_peaks_tile","text":"Calling peaks pre-set list tiles can much faster using dedicated peak-calling software like macs3. resulting peaks less precise terms exact coordinates, sufficient analyses.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call peaks from tiles — call_peaks_tile","text":"","code":"call_peaks_tile(   fragments,   chromosome_sizes,   cell_groups = rep.int(\"all\", length(cellNames(fragments))),   effective_genome_size = NULL,   peak_width = 200,   peak_tiling = 3,   fdr_cutoff = 0.01,   merge_peaks = c(\"all\", \"group\", \"none\") )"},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call peaks from tiles — call_peaks_tile","text":"fragments IterableFragments object chromosome_sizes Chromosome start end coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position See read_ucsc_chrom_sizes(). cell_groups Grouping vector one entry per cell fragments, e.g. cluster IDs effective_genome_size (Optional) effective genome size poisson background rate estimation. See deeptools values common genomes. Defaults sum chromosome sizes, overestimates peak significance peak_width Width candidate peaks peak_tiling Number candidate peaks overlapping base genome. E.g. peak_width = 300 peak_tiling = 3 results candidate peaks 300bp spaced 100bp apart fdr_cutoff Adjusted p-value significance cutoff merge_peaks merge significant peaks merge_peaks_iterative() \"\" Merge full set peaks \"group\" Merge peaks within group \"none\" perform merging","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call peaks from tiles — call_peaks_tile","text":"tibble peak calls following columns: chr, start, end: genome coordinates group: group ID peak identified p_val, q_val: Poission p-value BH-corrected p-value enrichment: Enrichment counts peak compared genome-wide background","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call peaks from tiles — call_peaks_tile","text":"Peak calling steps: Estimate genome-wide expected insertions per tile based peak_width, effective_genome_size, per-group read counts Tile genome nonoverlapping tiles size peak_width tile group, calculate p_value based Poisson model Compute adjusted p-values using BH method using total number tiles number hypotheses tested. Repeat steps 2-4 peak_tiling times, evenly spaced offsets merge_peaks \"\" \"group\": use merge_peaks_iterative() within group keep significant overlapping candidate peaks merge_peaks \"\", perform final round merge_peaks_iterative(), prioritizing peak within-group significance rank","code":""},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the MD5 checksum of an IterableMatrix — checksum","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"Calculate MD5 checksum IterableMatrix return checksum hexidecimal format.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"","code":"checksum(matrix)"},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"matrix IterableMatrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"MD5 checksum string hexidecimal format.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"checksum() converts non-zero elements sparse input matrix double precision, concatenates element value element row column index words, uses 16-byte blocks along matrix dimensions row column names calculate checksum. checksum value depends storage order column- row-order matrices element values give different checksum values. checksum() uses element index values little-endian CPU storage order. converts little-endian order big-endian architecture although tested.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/checksum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the MD5 checksum of an IterableMatrix — checksum","text":"","code":"library(Matrix) library(BPCells) m1 <- matrix(seq(1,12), nrow=3) m2 <- as(m1, 'dgCMatrix') m3 <- as(m2, 'IterableMatrix') checksum(m3) #> [1] \"8a6bf37ef376f7d74b4642a2ed0fc58d\""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster an adjacency matrix — cluster_graph_leiden","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"Cluster adjacency matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"","code":"cluster_graph_leiden(   snn,   resolution = 1,   objective_function = c(\"modularity\", \"CPM\"),   seed = 12531,   ... )  cluster_graph_louvain(snn, resolution = 1, seed = 12531)  cluster_graph_seurat(snn, resolution = 0.8, ...)"},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"snn Symmetric adjacency matrix (dgCMatrix) output e.g. knn_to_snn_graph() knn_to_geodesic_graph(). lower triangle used resolution Resolution parameter. Higher values result clusters objective_function Graph statistic optimize clustering. Modularity default keeps resolution independent dataset size (see details ). meaning option, see igraph::cluster_leiden(). seed Random seed clustering initialization ... Additional arguments underlying clustering function","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"Factor vector containing cluster assignment cell.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"cluster_graph_leiden: Leiden clustering algorithm igraph::cluster_leiden(). Note using objective_function = \"CPM\" number clusters empirically scales cells * resolution, 1e-3 good resolution 10k cells, 1M cells better 1e-5 resolution. resolution 1 good default objective_function = \"modularity\" per default. cluster_graph_louvain: Louvain graph clustering algorithm igraph::cluster_louvain() cluster_graph_seurat: Seurat's clustering algorithm Seurat::FindClusters()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert grouping vector to sparse matrix — cluster_membership_matrix","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"Converts vector membership IDs sparse matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"","code":"cluster_membership_matrix(groups, group_order = NULL)"},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"groups Vector one entry per cell, specifying cell's group group_order Optional vector listing ordering groups","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"cell x group matrix entry 1 cell given group","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect features for plotting — collect_features","title":"Collect features for plotting — collect_features","text":"Helper function data features plot diverse set data sources.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect features for plotting — collect_features","text":"","code":"collect_features(   source,   features = NULL,   gene_mapping = human_gene_mapping,   n = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect features for plotting — collect_features","text":"source Matrix data frame pull features , vector feature values single feature. matrix, features must rows. features Character vector features names plot source vector. gene_mapping optional vector gene name matching match_gene_symbol(). Ignored source data frame. n Internal-use parameter marking number nested calls. used finding name \"source\" input variable caller's perspective","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect features for plotting — collect_features","text":"Data frame one column feature requested","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collect features for plotting — collect_features","text":"source data.frame, features drawn columns. source matrix object (IterableMatrix, dgCMatrix, matrix), features drawn rows.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/concat_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","title":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","text":"Helper function rbind/cbind concatenating dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/concat_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","text":"","code":"concat_dimnames(x, y, len_x, len_y, warning_prefix, dim_type)"},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the type of a matrix — convert_matrix_type","title":"Convert the type of a matrix — convert_matrix_type","text":"Convert type matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the type of a matrix — convert_matrix_type","text":"","code":"convert_matrix_type(matrix, type = c(\"uint32_t\", \"double\", \"float\"))"},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the type of a matrix — convert_matrix_type","text":"matrix IterableMatrix object input type One uint32_t (unsigned 32-bit integer), float (32-bit real number), double (64-bit real number)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the type of a matrix — convert_matrix_type","text":"IterableMatrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine ggplot track plots into an aligned grid. — draw_trackplot_grid","title":"Combine ggplot track plots into an aligned grid. — draw_trackplot_grid","text":"function renamed trackplot_combine().","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine ggplot track plots into an aligned grid. — draw_trackplot_grid","text":"","code":"draw_trackplot_grid(   ...,   labels,   title = NULL,   heights = rep(1, length(plots)),   label_width = 0.2,   label_style = list(fontface = \"bold\", size = 4) )"},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine ggplot track plots into an aligned grid. — draw_trackplot_grid","text":"... Plots order top bottom, generally plain ggplots. better accomodate many bulk tracks, patchwork objects contain multiple tracks also accepted. case, plot labels drawn attribute $patchwork$labels present, rather labels argument. labels Text labels display track title Text overarching title plot heights Relative heights component plot. suggested use 1 standard height pseudobulk track. label_width Fraction width used labels relative main track area label_style Arguments pass geom_text adjust label text style","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine ggplot track plots into an aligned grid. — draw_trackplot_grid","text":"plot object aligned genome plots. aligned row text label, y-axis, plot body. relative height row given heights. shared title x-axis put top.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":null,"dir":"Reference","previous_headings":"","what":"Download a file with a custom timeout — ensure_downloaded","title":"Download a file with a custom timeout — ensure_downloaded","text":"Download file custom timeout","code":""},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download a file with a custom timeout — ensure_downloaded","text":"","code":"ensure_downloaded(path, backup_url, timeout)"},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download a file with a custom timeout — ensure_downloaded","text":"path Output path write file timeout timeout seconds url download ","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend genome ranges in a strand-aware fashion. — extend_ranges","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"Extend genome ranges strand-aware fashion.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"","code":"extend_ranges(   ranges,   upstream = 0,   downstream = 0,   metadata_cols = c(\"strand\"),   chromosome_sizes = NULL,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"ranges Genomic regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position upstream Number bases extend range upstream (negative shrink width) downstream Number bases extend range downstream (negative shrink width) metadata_cols Optional list metadata columns require & extract chromosome_sizes (optional) Size chromosomes genomic-ranges object zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"Note ranges blocked extending past beginning chromosome (base 0), chromosome_sizes given also blocked extending past end chromosome","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Get footprints around a set of genomic coordinates — footprint","title":"Get footprints around a set of genomic coordinates — footprint","text":"Get footprints around set genomic coordinates","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get footprints around a set of genomic coordinates — footprint","text":"","code":"footprint(   fragments,   ranges,   zero_based_coords = !is(ranges, \"GRanges\"),   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   cell_weights = rlang::rep_along(cell_groups, 1),   flank = 125L,   normalization_width = flank%/%10L )"},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get footprints around a set of genomic coordinates — footprint","text":"fragments IterableFragments object ranges Footprint centers given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand \"+\" strand ranges footprint around start coordinate, \"-\" strand ranges around end coordinate. zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range cell_groups Character factor assigning group cell, order cellNames(fragments) cell_weights Numeric vector assigning weight factors (e.g. inverse total reads) cell, order cellNames(fragments) flank Number flanking basepairs include either side motif normalization_width Number basepairs upstream + downstream extremes use calculating enrichment","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get footprints around a set of genomic coordinates — footprint","text":"tibble::tibble() columns group, position, count, enrichment","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_R_conversion.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between BPCells fragments and R objects. — convert_to_fragments","title":"Convert between BPCells fragments and R objects. — convert_to_fragments","text":"BPCells fragments can interconverted GRanges data.frame R objects. main conversion method R's builtin () function, though convert_to_fragments() helper also available. R objects except GRanges, BPCells assumes 0-based, end-exclusive coordinate system. (See genomic-ranges-like reference details)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_R_conversion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between BPCells fragments and R objects. — convert_to_fragments","text":"","code":"# Convert from R to BPCells convert_to_fragments(x, zero_based_coords = !is(x, \"GRanges\")) as(x, \"IterableFragments\")  # Convert from BPCells to R as.data.frame(bpcells_fragments) as(bpcells_fragments, \"data.frame\") as(bpcells_fragments, \"GRanges\")"},{"path":"https://bnprks.github.io/BPCells/reference/fragment_R_conversion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between BPCells fragments and R objects. — convert_to_fragments","text":"x Fragment coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position cell_id: cell barcodes unique identifiers string factor zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_R_conversion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between BPCells fragments and R objects. — convert_to_fragments","text":"convert_to_fragments(): IterableFragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write BPCells fragment objects — write_fragments_memory","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"BPCells fragments can read/written compressed (bitpacked) uncompressed form variety storage locations: memory (R object), hdf5 file, directory disk (containing binary files).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"","code":"write_fragments_memory(fragments, compress = TRUE)  write_fragments_dir(   fragments,   dir,   compress = TRUE,   buffer_size = 1024L,   overwrite = FALSE )  open_fragments_dir(dir, buffer_size = 1024L)  write_fragments_hdf5(   fragments,   path,   group = \"fragments\",   compress = TRUE,   buffer_size = 8192L,   chunk_size = 1024L,   overwrite = FALSE,   gzip_level = 0L )  open_fragments_hdf5(path, group = \"fragments\", buffer_size = 16384L)"},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"fragments Input fragments object compress Whether compress data. compression, storage size half size gzip-compressed 10x fragments file. dir Directory read/write data buffer_size performance tuning . number items bufferred memory calling writes disk. overwrite TRUE, write temp dir overwrite existing data. Alternatively, pass temp path string customize temp dir location. path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use chunk_size performance tuning . chunk size used HDF5 array storage. gzip_level Gzip compression level. Default 0 (compression). recommended compression compatibility outside programs required. Otherwise, using compress=TRUE recommended >10x faster often similar compression levels.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"Fragment object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"Saving directory disk good default local analysis, provides best /O performance lowest memory usage. HDF5 format allows saving within existing hdf5 files group data together, memory format provides fastest performance event memory usage unimportant.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if two fragments objects are identical — fragments_identical","title":"Check if two fragments objects are identical — fragments_identical","text":"Check two fragments objects identical","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if two fragments objects are identical — fragments_identical","text":"","code":"fragments_identical(fragments1, fragments2)"},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if two fragments objects are identical — fragments_identical","text":"fragments1 First IterableFragments compare fragments2 Second IterableFragments compare","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if two fragments objects are identical — fragments_identical","text":"boolean whether fragments objects identical","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Gene Symbol Mapping data — human_gene_mapping","title":"Gene Symbol Mapping data — human_gene_mapping","text":"Mapping canonical gene symbols corresponding unambiguous alias, previous symbol, ensembl ID, entrez ID.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gene Symbol Mapping data — human_gene_mapping","text":"","code":"human_gene_mapping  mouse_gene_mapping"},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Gene Symbol Mapping data — human_gene_mapping","text":"human_gene_mapping named character vector. Names aliases IDs values corresponding canonical gene symbol mouse_gene_mapping named character vector. Names aliases IDs values corresponding canonical gene symbol","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Gene Symbol Mapping data — human_gene_mapping","text":"human_gene_mapping http://ftp.ebi.ac.uk/pub/databases/genenames/hgnc/tsv/non_alt_loci_set.txt mouse_gene_mapping http://www.informatics.jax.org/downloads/reports/MGI_EntrezGene.rpt http://www.informatics.jax.org/downloads/reports/MRK_ENSEMBL.rpt","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gene Symbol Mapping data — human_gene_mapping","text":"See source code data-raw/human_gene_mapping.R data-raw/mouse_gene_mapping.R exactly mappings made.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":null,"dir":"Reference","previous_headings":"","what":"Gene symbol matching — match_gene_symbol","title":"Gene symbol matching — match_gene_symbol","text":"Correct alias gene symbols, Ensembl IDs, Entrez IDs canonical gene symbols. useful matching gene names different datasets might always use gene naming conventions.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gene symbol matching — match_gene_symbol","text":"","code":"match_gene_symbol(query, subject, gene_mapping = human_gene_mapping)  canonical_gene_symbol(query, gene_mapping = human_gene_mapping)"},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gene symbol matching — match_gene_symbol","text":"query Character vector gene symbols IDs subject Vector gene symbols IDs index gene_mapping Named vector names gene symbols IDs values canonical gene symbols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gene symbol matching — match_gene_symbol","text":"match_gene_symbol Integer vector indices v subject[v] corresponds gene symbols query canonical_gene_symbol Character vector canonical gene symbols symbol query","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Find gene region — gene_region","title":"Find gene region — gene_region","text":"Conveniently look region gene gene symbol. value returned function can used region argument trackplot functions trackplot_coverage() trackplot_gene()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find gene region — gene_region","text":"","code":"gene_region(   genes,   gene_symbol,   extend_bp = c(10000, 10000),   gene_mapping = human_gene_mapping )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find gene region — gene_region","text":"genes Transcipt features given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand gene_name: Symbol gene ID gene_symbol Name gene symbol ID extend_bp Bases extend region upstream downstream gene. length 1, extension symmetric. length 2, provide upstream extension downstream extension positive distances. gene_mapping Named vector names gene symbols IDs values canonical gene symbols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find gene region — gene_region","text":"List chr, start, end positions use trackplot functions.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"ArchR-style gene activity scores based weighted sum tile according signed distance tile gene body. function calculates signed distances according ArchR's default parameters.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"","code":"gene_score_tiles_archr(   genes,   chromosome_sizes = NULL,   tile_width = 500,   addArchRBug = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"genes Gene coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand chromosome_sizes (optional) Size chromosomes genomic-ranges object tile_width Size tiles consider addArchRBug Replicate ArchR bug handling nested genes","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"Tibble one range per tile, additional metadata columns gene_idx (row index gene tile corresponds ) distance. Distance signed distance calculated tile smaller start coordinate gene gene + strand, distance negative. distance adjacent non-overlapping regions 1bp, counting .","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"ArchR's tile distance algorithm works follows Genes extended 5kb upstream Genes linked tiles 1kb-100kb upstream + downstream, tiles beyond neighboring gene considered","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate GeneActivityScores — gene_score_weights_archr","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"Gene activity scores can calculated distance-weighted sum per-tile accessibility. tile weights gene can represented sparse matrix dimension genes x tiles. multiply weight matrix corresponding tile matrix (tiles x cells), can get gene activity score matrix genes x cells. gene_score_weights_archr() calculates weight matrix (best pre-computed tile matrix), gene_score_archr() provides easy--use wrapper.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"","code":"gene_score_weights_archr(   genes,   chromosome_sizes,   blacklist = NULL,   tile_width = 500,   gene_name_column = \"gene_id\",   addArchRBug = FALSE )  gene_score_archr(   fragments,   genes,   chromosome_sizes,   blacklist = NULL,   tile_width = 500,   gene_name_column = \"gene_id\",   addArchRBug = FALSE,   tile_max_count = 4,   scale_factor = 10000,   tile_matrix_path = tempfile(pattern = \"gene_score_tile_mat\") )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"genes Gene coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand chromosome_sizes Chromosome start end coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position See read_ucsc_chrom_sizes(). blacklist Regions exclude calculations, given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position tile_width Size tiles consider gene_name_column NULL, column name genes use row names addArchRBug Replicate ArchR bug handling nested genes fragments Input fragments object tile_max_count Maximum value tile counts matrix. null, tile counts higher clipped tile_max_count. Equivalent ceiling argument ArchR::addGeneScoreMatrix() scale_factor null, counts cell scaled sum scale_factor. Equivalent scaleTo argument ArchR::addGeneScoreMatrix() tile_matrix_path Path directory intermediate tile matrix saved","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"gene_score_weights_archr Weight matrix dimension genes x tiles gene_score_archr Gene score matrix dimension genes x cells.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"gene_score_weights_archr: Given set tile coordinates distances returned gene_score_tiles_archr(), calculate weight matrix dimensions genes x tiles. matrix can multiplied tile matrix obtain ArchR-compatible gene activity scores.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges-like.html","id":null,"dir":"Reference","previous_headings":"","what":"Genomic range formats — genomic-ranges-like","title":"Genomic range formats — genomic-ranges-like","text":"BPCells accepts flexible set genomic ranges-like objects input, either GRanges, data.frame, lists, character vectors. objects must specify chromosome, start, end coordinates along optional metadata range. exception GenomicRanges::GRanges objects, BPCells assumes objects use zero-based, end-exclusive coordinate system (see details).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges-like.html","id":"valid-range-like-objects","dir":"Reference","previous_headings":"","what":"Valid Range-like objects","title":"Genomic range formats — genomic-ranges-like","text":"BPCells can interpret following types ranges: list(), data.frame(), columns: chr: Character factor chromosome names start: Start coordinates (0-based) end: End coordinates (exclusive) (optional) strand: \"+\"/\"-\" TRUE/FALSE pos/neg strand (optional) Additional metadata named list entries data.frame columns GenomicRanges::GRanges start(x) interpreted 1-based start coordinate end(x) interpreted inclusive end coordinate strand(x): \"*\" entries interpeted postive strand (optional) mcols(x) holds additional metadata character Given format \"chr1:1000-2000\" \"chr1:1,000-2,000\" Uses 0-based, end-exclusive coordinate system used ranges additional metadata required","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges-like.html","id":"range-coordinate-systems","dir":"Reference","previous_headings":"","what":"Range coordinate systems","title":"Genomic range formats — genomic-ranges-like","text":"two main conventions coordinate systems: One-based, end-inclusive ranges first base chromosome numbered 1 last base range equal end coordinate e.g. 1-5 describes first 5 bases chromosome Used formats SAM, GTF BPCells, used reading writing GenomicRanges::GRanges objects Zero-based, end-exclusive ranges first base chromosome numbered 0 last base range one less end coordinate e.g. 0-5 describes first 5 bases chromosome Used formats BAM, BED BPCells, used range objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/import_matrix_market.html","id":null,"dir":"Reference","previous_headings":"","what":"Import MatrixMarket files — import_matrix_market","title":"Import MatrixMarket files — import_matrix_market","text":"Read sparse matrix MatrixMarket file. text-based format used 10x, Parse, others store sparse matrices. Format details NIST website.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/import_matrix_market.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import MatrixMarket files — import_matrix_market","text":"","code":"import_matrix_market(   mtx_path,   outdir = tempfile(\"matrix_market\"),   row_names = NULL,   col_names = NULL,   row_major = FALSE,   tmpdir = tempdir(),   load_bytes = 4194304L,   sort_bytes = 1073741824L )  import_matrix_market_10x(   mtx_dir,   outdir = tempfile(\"matrix_market\"),   feature_type = NULL,   row_major = FALSE,   tmpdir = tempdir(),   load_bytes = 4194304L,   sort_bytes = 1073741824L )"},{"path":"https://bnprks.github.io/BPCells/reference/import_matrix_market.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import MatrixMarket files — import_matrix_market","text":"mtx_path Path mtx mtx.gz file outdir Directory store output row_names Character vector row names col_names Character vector col names row_major true, store matrix row-major orientation tmpdir Temporary directory use intermediate storage load_bytes minimum contiguous load size merge sort passes sort_bytes amount memory allocate re-sorting chunks entries mtx_dir Directory holding matrix.mtx.gz, barcodes.tsv.gz, features.tsv.gz feature_type String vector feature types include. (cellranger 3.0 newer)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/import_matrix_market.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import MatrixMarket files — import_matrix_market","text":"MatrixDir object imported matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/import_matrix_market.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import MatrixMarket files — import_matrix_market","text":"Import MatrixMarket mtx files BPCells format. implementation ensures fixed memory usage even large inputs -disk sorts. much slower hdf5 inputs, use MatrixMarket format absolutely necessary. rough speed estimate, importing 17GB Parse 1M PBMC DGE_1M_PBMC.mtx file takes 4 minutes 1.3GB RAM, producing compressed output matrix 1.5GB. mtx.gz files slower import due gzip decompression. importing 10x mtx files, row column names can read automatically using import_matrix_market_10x() convenience function.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/iterate_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a wrapped pointer to the iterable matrix — iterate_matrix","title":"Get a wrapped pointer to the iterable matrix — iterate_matrix","text":"Get wrapped pointer iterable matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/iterate_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a wrapped pointer to the iterable matrix — iterate_matrix","text":"","code":"iterate_matrix(x)"},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a knn matrix from reduced dimensions — knn_hnsw","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"Search approximate nearest neighbors cells reduced dimensions (e.g. PCA), return k nearest neighbors (knn) cell. Optionally, can find neighbors two separate sets cells utilizing data query.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"","code":"knn_hnsw(   data,   query = NULL,   k = 10,   metric = c(\"euclidean\", \"cosine\"),   verbose = TRUE,   threads = 1,   ef = 100 )  knn_annoy(   data,   query = data,   k = 10,   metric = c(\"euclidean\", \"cosine\", \"manhattan\", \"hamming\"),   n_trees = 50,   search_k = -1 )"},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"data cell x dims matrix reference dataset query cell x dims matrix query dataset (optional) k number neighbors calculate metric distance metric use verbose whether print progress information search threads Number threads use. Note result non-deterministic threads > 1 ef ef parameter RccppHNSW::hnsw_search. Increase slower search improved accuracy n_trees Number trees index build time. trees gives higher accuracy search_k Number nodes inspect query, -1 default value. Higher number gives higher accuracy","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"List 2 matrices – idx cell x K neighbor indices, dist cell x K neighbor distances. query given, nearest neighbors found mapping data matrix , prohibiting self-neighbors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"knn_hnsw: Use RcppHNSW knn engine knn_annoy: Use RcppAnnoy knn engine","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"K Nearest Neighbor (KNN) Graph — knn_to_graph","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"Convert KNN object (e.g. returned knn_hnsw() knn_annoy()) graph. graph represented sparse adjacency matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"","code":"knn_to_graph(knn, use_weights = FALSE, self_loops = TRUE)  knn_to_snn_graph(   knn,   min_val = 1/15,   self_loops = FALSE,   return_type = c(\"matrix\", \"list\") )  knn_to_geodesic_graph(knn, return_type = c(\"matrix\", \"list\"), threads = 0L)"},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn List 2 matrices – idx cell x K neighbor indices, dist cell x K neighbor distances use_weights boolean whether replace distance weights 1 self_loops Whether allow self-loops output graph min_val minimum jaccard index neighbors. Values round 0 return_type Whether return sparse adjacency matrix edge list threads Number threads use calculations","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn_to_graph Sparse matrix (dgCMatrix) mat[,j] = distance cell cell j, 0 cell j K nearest neighbors knn_to_snn_graph return_type == \"matrix\": Sparse matrix (dgCMatrix) mat[,j] = jaccard index overlap nearest neigbors cell cell j, 0 jaccard index < min_val. lower triangle filled , compatible BPCells clustering methods return_type == \"list\": List 3 equal-length vectors , j, weight, along integer dim. correspond rows, cols, values non-zero entries lower triangle adjacency matrix. dim total number vertices (cells) graph knn_to_geodesic_graph return_type == \"matrix\": Sparse matrix (dgCMatrix) mat[,j] = normalized similarity cell cell j. lower triangle filled , compatible BPCells clustering methods return_type == \"list\": List 3 equal-length vectors , j, weight, along integer dim. correspond rows, cols, values non-zero entries lower triangle adjacency matrix. dim total number vertices (cells) graph","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn_to_graph Create knn graph knn_to_snn_graph Convert knn object shared nearest neighbors adjacency matrix. follows algorithm Seurat uses compute SNN graphs knn_to_geodesic_graph Convert knn object undirected weighted graph, using geodesic distance estimation method UMAP package. matches output umap._umap.fuzzy_simplicial_set umap-learn python package, used default scanpy.pp.neighbors. re-weights symmetrizes KNN graph, usually use less memory return sparser graph knn_to_snn_graph computes 2nd-order neighbors. Note: cells listed nearest neighbor, results may differ slightly umap._umap.fuzzy_simplicial_set, assumes self always successfully found approximate nearest neighbor search.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/linear_operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a LinearOperator object — linear_operator","title":"Construct a LinearOperator object — linear_operator","text":"Constructs C++ matrix object save pointer use repeated matrix-vector products bit experimental still internal use","code":""},{"path":"https://bnprks.github.io/BPCells/reference/linear_operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a LinearOperator object — linear_operator","text":"","code":"linear_operator(mat)"},{"path":"https://bnprks.github.io/BPCells/reference/macs_path_is_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if MACS executable is valid. If macs_executable is NULL, this function will try to auto-detect MACS from PATH, with preference for MACS3 over MACS2. If macs_executable is provided, this function will check if MACS can be called. — macs_path_is_valid","title":"Test if MACS executable is valid. If macs_executable is NULL, this function will try to auto-detect MACS from PATH, with preference for MACS3 over MACS2. If macs_executable is provided, this function will check if MACS can be called. — macs_path_is_valid","text":"Test MACS executable valid. macs_executable NULL, function try auto-detect MACS PATH, preference MACS3 MACS2. macs_executable provided, function check MACS can called.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/macs_path_is_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if MACS executable is valid. If macs_executable is NULL, this function will try to auto-detect MACS from PATH, with preference for MACS3 over MACS2. If macs_executable is provided, this function will check if MACS can be called. — macs_path_is_valid","text":"","code":"macs_path_is_valid(macs_executable)"},{"path":"https://bnprks.github.io/BPCells/reference/macs_path_is_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if MACS executable is valid. If macs_executable is NULL, this function will try to auto-detect MACS from PATH, with preference for MACS3 over MACS2. If macs_executable is provided, this function will check if MACS can be called. — macs_path_is_valid","text":"macs_executable (string) Path either MACS2/3 executable. Default (NULL) autodetect PATH.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/macs_path_is_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if MACS executable is valid. If macs_executable is NULL, this function will try to auto-detect MACS from PATH, with preference for MACS3 over MACS2. If macs_executable is provided, this function will check if MACS can be called. — macs_path_is_valid","text":"MACS executable path.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for marker features — marker_features","title":"Test for marker features — marker_features","text":"Given features x cells matrix, perform one-vs-differential tests find markers.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for marker features — marker_features","text":"","code":"marker_features(mat, groups, method = \"wilcoxon\")"},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for marker features — marker_features","text":"mat IterableMatrix object dimensions features x cells groups Character/factor vector cell groups/clusters. Length #cells method Test method use. Current options : wilcoxon: Wilconxon rank-sum test .k.Mann-Whitney U test","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for marker features — marker_features","text":"tibble following columns: foreground: Group ID used foreground background: Group ID used background (NA comparing rest cells) feature: ID feature p_val_raw: Unadjusted p-value differential test foreground_mean: Average value foreground group background_mean: Average value background group","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test for marker features — marker_features","text":"Tips using values function: Use dplyr::mutate() add columns e.g. adjusted p-value log fold change. Use dplyr::filter() get differential genes given threshold get adjusted p-values, use R p.adjust(), recommended method \"BH\" get log2 fold change: input matrix already log-transformed, calculate (foreground_mean - background_mean)/log(2). input matrix log-transformed, calculate log2(forground_mean/background_mean)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask matrix entries to zero Set matrix entries to zero given a mask matrix of the same dimensions. Normally, non-zero values in the mask will set the matrix entry to zero. If inverted, zero values in the mask matrix will set the matrix entry to zero. — mask_matrix","title":"Mask matrix entries to zero Set matrix entries to zero given a mask matrix of the same dimensions. Normally, non-zero values in the mask will set the matrix entry to zero. If inverted, zero values in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"Mask matrix entries zero Set matrix entries zero given mask matrix dimensions. Normally, non-zero values mask set matrix entry zero. inverted, zero values mask matrix set matrix entry zero.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask matrix entries to zero Set matrix entries to zero given a mask matrix of the same dimensions. Normally, non-zero values in the mask will set the matrix entry to zero. If inverted, zero values in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"","code":"mask_matrix(mat, mask, invert = FALSE)"},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask matrix entries to zero Set matrix entries to zero given a mask matrix of the same dimensions. Normally, non-zero values in the mask will set the matrix entry to zero. If inverted, zero values in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"mat Data matrix (IterableMatrix) mask Mask matrix (IterableMatrix dgCMatrix)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcasting vector arithmetic — add_rows","title":"Broadcasting vector arithmetic — add_rows","text":"Convenience functions adding multiplying row / column matrix number.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcasting vector arithmetic — add_rows","text":"","code":"add_rows(mat, vec)  add_cols(mat, vec)  multiply_rows(mat, vec)  multiply_cols(mat, vec)"},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcasting vector arithmetic — add_rows","text":"mat Matrix-like object vec Numeric vector","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcasting vector arithmetic — add_rows","text":"Matrix-like object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_R_conversion.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between BPCells matrix and R objects. — matrix_R_conversion","title":"Convert between BPCells matrix and R objects. — matrix_R_conversion","text":"BPCells matrices can interconverted Matrix package dgCMatrix sparse matrices, well base R dense matrices (though may result high memory usage large matrices)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_R_conversion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between BPCells matrix and R objects. — matrix_R_conversion","text":"","code":"# Convert to R from BPCells as(bpcells_mat, \"dgCMatrix\") # Sparse matrix conversion as.matrix(bpcells_mat) # Dense matrix conversion  # Convert to BPCells from R as(dgc_mat, \"IterableMatrix\")"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","title":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","text":"File objects 0 inputs. transforms 1 input. transforms (e.g. matrix multiplication matrix concatenation) can multiple used primarily know safe clear dimnames intermediate transformed matrices. C++ relies base matrices (non-transform) dimnames, R relies outermost matrix (transform) dimnames.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","text":"","code":"matrix_inputs(x)"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write sparse matrices — write_matrix_memory","title":"Read/write sparse matrices — write_matrix_memory","text":"BPCells matrices stored sparse format, meaning non-zero entries stored. Matrices can store integer counts data decimal numbers (float double). See details information.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write sparse matrices — write_matrix_memory","text":"","code":"write_matrix_memory(mat, compress = TRUE)  write_matrix_dir(   mat,   dir,   compress = TRUE,   buffer_size = 8192L,   overwrite = FALSE )  open_matrix_dir(dir, buffer_size = 8192L)  write_matrix_hdf5(   mat,   path,   group,   compress = TRUE,   buffer_size = 8192L,   chunk_size = 1024L,   overwrite = FALSE,   gzip_level = 0L )  open_matrix_hdf5(path, group, buffer_size = 16384L)"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write sparse matrices — write_matrix_memory","text":"compress Whether compress data. dir Directory save data buffer_size performance tuning . number items buffered memory calling writes disk. overwrite TRUE, write temp dir overwrite existing data. Alternatively, pass temp path string customize temp dir location. path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use chunk_size performance tuning . chunk size used HDF5 array storage. gzip_level Gzip compression level. Default 0 (compression). recommended compression compatibility outside programs required. Otherwise, using compress=TRUE recommended >10x faster often similar compression levels. matrix Input matrix, either IterableMatrix dgCMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write sparse matrices — write_matrix_memory","text":"BPCells matrix object","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"storage-locations","dir":"Reference","previous_headings":"","what":"Storage locations","title":"Read/write sparse matrices — write_matrix_memory","text":"Matrices can stored directory disk, memory, HDF5 file. Saving directory disk good default local analysis, provides best /O performance lowest memory usage. HDF5 format allows saving within existing hdf5 files group data together, memory format provides fastest performance event memory usage unimportant.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"bitpacking-compression","dir":"Reference","previous_headings":"","what":"Bitpacking Compression","title":"Read/write sparse matrices — write_matrix_memory","text":"typical RNA counts matrices holding integer counts, bitpacking compression result 6-8x less space R dgCMatrix, 4-6x smaller scipy csc_matrix. compression effective count values matrix small, rows matrix sorted rowMeans. tests RNA-seq data optimal ordering save 40% storage space. non-integer data row indices compressed, values space savings smaller. non-integer data matrices, bitpacking compression much less effective, can applied indexes entry values. still space savings, far less counts matrices.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate matrix stats — matrix_stats","title":"Calculate matrix stats — matrix_stats","text":"Calculate matrix stats","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate matrix stats — matrix_stats","text":"","code":"matrix_stats(   matrix,   row_stats = c(\"none\", \"nonzero\", \"mean\", \"variance\"),   col_stats = c(\"none\", \"nonzero\", \"mean\", \"variance\"),   threads = 0L )"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate matrix stats — matrix_stats","text":"matrix Input matrix object row_stats row statistics compute col_stats col statistics compute threads Number threads use execution","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate matrix stats — matrix_stats","text":"List row_stats: matrix n_stats x n_rows, col_stats: matrix n_stats x n_cols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate matrix stats — matrix_stats","text":"statistics calculated single pass matrix, method desirable use efficiency purposes compared standard rowMeans colMeans multiple statistics needed. stats ordered complexity: nonzero, mean, variance. less complex stats calculated process calculating complicated stat. calculate mean variance simultaneously, just ask variance, compute mean nonzero counts side-effect","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge cells into pseudobulks — merge_cells","title":"Merge cells into pseudobulks — merge_cells","text":"Peak tile matrix calculations can sped reducing number cells. cases outputs going added together afterwards, can provide performance improvement","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge cells into pseudobulks — merge_cells","text":"","code":"merge_cells(fragments, cell_groups)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge cells into pseudobulks — merge_cells","text":"fragments Input fragments object cell_groups Character factor vector providing group cell. Ordering cellNames(fragments)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for rbind/cbind merging dimnames — merge_dimnames","title":"Helper function for rbind/cbind merging dimnames — merge_dimnames","text":"Helper function rbind/cbind merging dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for rbind/cbind merging dimnames — merge_dimnames","text":"","code":"merge_dimnames(x, y, warning_prefix, dim_type)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge peaks — merge_peaks_iterative","title":"Merge peaks — merge_peaks_iterative","text":"Merge peaks according ArchR's iterative merging algorithm. details ArchR website","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge peaks — merge_peaks_iterative","text":"","code":"merge_peaks_iterative(peaks)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge peaks — merge_peaks_iterative","text":"peaks Peaks given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position Must ordered priority columns chr, start, end.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge peaks — merge_peaks_iterative","text":"tibble::tibble() nonoverlapping subset rows peaks. metadata columns preserved","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge peaks — merge_peaks_iterative","text":"Properties merged peaks: peaks merged set overlap Peaks prioritized according order original input output peaks subset input peaks, peak boundaries changed","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Elementwise minimum — min_scalar","title":"Elementwise minimum — min_scalar","text":"min_scalar: Take minumum global constant min_by_row: Take minimum per-row constant min_by_col: Take minimum per-col constant","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elementwise minimum — min_scalar","text":"","code":"min_scalar(mat, val)  min_by_row(mat, vals)  min_by_col(mat, vals)"},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elementwise minimum — min_scalar","text":"mat IterableMatrix val Single positive numeric value","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elementwise minimum — min_scalar","text":"IterableMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Elementwise minimum — min_scalar","text":"Take minimum value matrix per-row, per-col, global constant. constant must >0 preserve sparsity matrix. effect capping maximum value matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize an object representing genomic ranges — normalize_ranges","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"Normalize object representing genomic ranges","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"","code":"normalize_ranges(   ranges,   metadata_cols = character(0),   zero_based_coords = !is(ranges, \"GRanges\"),   n = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"ranges Genomic regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position metadata_cols Optional list metadata columns require & extract zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"data frame zero-based coordinates, elements chr (factor), start (int), end (int). ranges chr level information, chr levels sorted unique values chr. strand metadata_cols, output strand element TRUE positive strand, FALSE negative strand. (Converted character vector \"+\"/\"-\" necessary)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_unique_file_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust a set of (unique) potential file names to not include any invalid characters. — normalize_unique_file_names","title":"Adjust a set of (unique) potential file names to not include any invalid characters. — normalize_unique_file_names","text":"Adjust set (unique) potential file names include invalid characters.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_unique_file_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust a set of (unique) potential file names to not include any invalid characters. — normalize_unique_file_names","text":"","code":"normalize_unique_file_names(names, replacement = \"_\")"},{"path":"https://bnprks.github.io/BPCells/reference/normalized_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","title":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","text":"Helper function set dimnames NULL instead 0-length character vectors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalized_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","text":"","code":"normalized_dimnames(row_names, col_names)"},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Count fragments by nucleosomal size — nucleosome_counts","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"Count fragments nucleosomal size","code":""},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"","code":"nucleosome_counts(fragments, nucleosome_width = 147)"},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"fragments Fragments object nucleosome_width Integer cutoff use nucleosome width","code":""},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"List names subNucleosomal, monoNucleosomal, multiNucleosomal, nFrags, containing count vectors fragments class per cell.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"Shorter nucleosome_width subNucleosomal, nucleosome_width 2*nucleosome_width-1 monoNucleosomal, anything longer multiNucleosomal. sum fragments given nFrags","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write a 10x fragments file — open_fragments_10x","title":"Read/write a 10x fragments file — open_fragments_10x","text":"10x fragment files come bed-like format, columns chr, start, end, cell_id, pcr_duplicates. Unlike standard bed format, format cellranger inclusive end-coordinate, meaning end coordinate counted tagmentation site, rather offset 1.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write a 10x fragments file — open_fragments_10x","text":"","code":"open_fragments_10x(path, comment = \"#\", end_inclusive = TRUE)  write_fragments_10x(   fragments,   path,   end_inclusive = TRUE,   append_5th_column = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write a 10x fragments file — open_fragments_10x","text":"path File path (e.g. fragments.tsv fragments.tsv.gz) comment Skip lines beginning file start comment string end_inclusive Whether end coordinate bed inclusive – .e. insertion end coordinate rather base end coordinate. 10x default, though quite standard bed file format. fragments Input fragments object append_5th_column Whether include 5th column 0 compatibility 10x fragment file outputs (defaults 4 columns chr,start,end,cell)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write a 10x fragments file — open_fragments_10x","text":"10x fragments file object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write a 10x fragments file — open_fragments_10x","text":"open_fragments_10x disk operations take place fragments used function write_fragments_10x Fragments written disk immediately, returned readable object.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"Read/write 10x feature matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"","code":"open_matrix_10x_hdf5(path, feature_type = NULL, buffer_size = 16384L)  write_matrix_10x_hdf5(   mat,   path,   barcodes = colnames(mat),   feature_ids = rownames(mat),   feature_names = rownames(mat),   feature_types = \"Gene Expression\",   feature_metadata = list(),   buffer_size = 16384L,   chunk_size = 1024L,   gzip_level = 0L,   type = c(\"uint32_t\", \"double\", \"float\", \"auto\") )"},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"path Path hdf5 file disk feature_type Optional selection feature types include output matrix. multiome data, options \"Gene Expression\" \"Peaks\". option compatible files cellranger 3.0 newer. buffer_size performance tuning . number items buffered memory calling writes disk. mat IterableMatrix barcodes Vector names cells feature_ids Vector IDs features feature_names Vector names features feature_types String vector feature types feature_metadata Named list additional metadata vectors store feature chunk_size performance tuning . chunk size used HDF5 array storage. gzip_level Gzip compression level. Default 0 (compression) type Data type output matrix. Default uint32_t match matrix 10x UMI counts. Non-integer data types include float double. auto, use data type mat.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"BPCells matrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"10x format makes use gzip compression matrix data, can slow read performance. Consider writing another format read performance important . Input matrices must column-major storage order, rownames colnames set, names must provided relevant metadata parameters. metadata parameters read default BPCells, possible export use tools.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write AnnData matrix — open_matrix_anndata_hdf5","title":"Read/write AnnData matrix — open_matrix_anndata_hdf5","text":"Read write sparse matrix anndata hdf5 file. functions automatically transpose matrices converting /AnnData format. AnnData convention stores cells rows, whereas R convention stores cells columns. behavior undesired, call t() manually matrix inputs outputs functions.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write AnnData matrix — open_matrix_anndata_hdf5","text":"","code":"open_matrix_anndata_hdf5(path, group = \"X\", buffer_size = 16384L)  write_matrix_anndata_hdf5(   mat,   path,   group = \"X\",   buffer_size = 16384L,   chunk_size = 1024L,   gzip_level = 0L )"},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write AnnData matrix — open_matrix_anndata_hdf5","text":"path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use buffer_size performance tuning . number items buffered memory calling writes disk. chunk_size performance tuning . chunk size used HDF5 array storage. gzip_level Gzip compression level. Default 0 (compression)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write AnnData matrix — open_matrix_anndata_hdf5","text":"AnnDataMatrixH5 object, cells columns.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Get end-sorted ordering for genome ranges — order_ranges","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"Use function order regioins prior calling peak_matrix() tile_matrix().","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"","code":"order_ranges(ranges, chr_levels, sort_by_end = TRUE)"},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"ranges Genomic regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position chr_levels Ordering chromosome names sort_by_end TRUE (defualt), sort (chr, end, start). Else sort (chr, start, end)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"Numeric vector analagous order function. Provides index selection reorder input ranges sorted chr, end, start","code":""},{"path":"https://bnprks.github.io/BPCells/reference/palettes.html","id":null,"dir":"Reference","previous_headings":"","what":"Color palettes — discrete_palette","title":"Color palettes — discrete_palette","text":"color palettes derived ArchR color palettes, provide large sets distinguishable colors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/palettes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Color palettes — discrete_palette","text":"","code":"discrete_palette(name, n = 1)  continuous_palette(name)"},{"path":"https://bnprks.github.io/BPCells/reference/palettes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Color palettes — discrete_palette","text":"name Name color palette. Valid discrete palettes : stallion, calm, kelly, bear, ironMan, circus, paired, grove, summerNight, captain. Valid continuous palettes bluePurpleDark n Minimum number colors needed","code":""},{"path":"https://bnprks.github.io/BPCells/reference/palettes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Color palettes — discrete_palette","text":"Character vector hex color codes","code":""},{"path":"https://bnprks.github.io/BPCells/reference/palettes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Color palettes — discrete_palette","text":"requested number colors large, new palette constructed via interpolation requested palette","code":""},{"path":"https://bnprks.github.io/BPCells/reference/parallel_split.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare a matrix for multi-threaded operation — parallel_split","title":"Prepare a matrix for multi-threaded operation — parallel_split","text":"Transforms matrix matrix_stats matrix multiplies vector/dense matrix evaluated parallel. speeds specific operations, reading writing matrix general. parallelism guaranteed work additional operations applied parallel split.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/parallel_split.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare a matrix for multi-threaded operation — parallel_split","text":"","code":"parallel_split(mat, threads, chunks = threads)"},{"path":"https://bnprks.github.io/BPCells/reference/parallel_split.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare a matrix for multi-threaded operation — parallel_split","text":"mat IterableMatrix threads Number execution threads chunks Number chunks use (>= threads)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/parallel_split.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare a matrix for multi-threaded operation — parallel_split","text":"IterableMatrix perform certain operations parallel","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ranges x cells overlap matrix — peak_matrix","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"Calculate ranges x cells overlap matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"","code":"peak_matrix(   fragments,   ranges,   mode = c(\"insertions\", \"fragments\", \"overlaps\"),   zero_based_coords = !is(ranges, \"GRanges\"),   explicit_peak_names = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"fragments Input fragments object. Must cell names chromosome names defined ranges Peaks/ranges overlap, given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position mode Mode counting peak overlaps. (See \"value\" section details) zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost) explicit_peak_names Boolean whether add rownames output matrix format e.g chr1:500-1000, start end coords given 0-based coordinate system. Note either way, peak names written matrix saved.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"Iterable matrix object dimension ranges x cells. saved, column names output matrix format chr1:500-1000, start end coords given 0-based coordinate system. mode options \"insertions\": Start end coordinates separately overlapped peak \"fragments\": Like \"insertions\", fragment can contribute 1 count peak, even start end coordinates overlap \"overlaps\": Like \"fragments\", overlap also counted fragment fully spans peak even neither start end falls within peak","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"calculating matrix directly fragments tsv, necessary first call select_chromosomes() order provide ordering chromosomes expect reading tsv.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":null,"dir":"Reference","previous_headings":"","what":"Dotplot — plot_dot","title":"Dotplot — plot_dot","text":"Plot feature levels per group cluster grid dots. Dots colored z-score normalized average expression, sized percent non-zero.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dotplot — plot_dot","text":"","code":"plot_dot(   source,   features,   groups,   group_order = NULL,   gene_mapping = human_gene_mapping,   colors = c(\"lightgrey\", \"#4682B4\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dotplot — plot_dot","text":"source Feature x cell matrix data.frame features. best results, features sparse log-normalized (e.g. run log1p() zero raw counts map zero) features Character vector features plot groups Vector one entry per cell, specifying cell's group group_order Optional vector listing ordering groups gene_mapping optional vector gene name matching match_gene_symbol(). colors Color scale plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot UMAP or embeddings — plot_embedding","title":"Plot UMAP or embeddings — plot_embedding","text":"Plot one features coloring cells UMAP plot.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot UMAP or embeddings — plot_embedding","text":"","code":"plot_embedding(   source,   embedding,   features = NULL,   quantile_range = c(0.01, 0.99),   randomize_order = TRUE,   smooth = NULL,   smooth_rounds = 3,   gene_mapping = human_gene_mapping,   size = NULL,   rasterize = FALSE,   raster_pixels = 512,   legend_continuous = c(\"auto\", \"quantile\", \"value\"),   labels_quantile_range = TRUE,   colors_continuous = c(\"lightgrey\", \"#4682B4\"),   legend_discrete = TRUE,   labels_discrete = TRUE,   colors_discrete = discrete_palette(\"stallion\"),   return_data = FALSE,   return_plot_list = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot UMAP or embeddings — plot_embedding","text":"source Matrix, data frame pull features , vector feature values single feature. matrix, features must rows. embedding matrix dimensions cells x 2 embedding coordinates features Character vector features plot source vector. quantile_range (optional) Length 2 vector giving quantiles clip minimum maximum color scale values, fractions 0 1. NULL NA values skip clipping randomize_order TRUE, shuffle cells prevent overplotting biases. Can pass integer instead specify random seed use. smooth (optional) Sparse matrix dimensions cells x cells cell-cell distance weights smoothing. smooth_rounds Number multiplication rounds apply smoothing. gene_mapping optional vector gene name matching match_gene_symbol(). Ignored source data frame. size Point size plotting rasterize Whether rasterize point drawing speed display graphics programs. raster_pixels Number pixels use rasterizing. Can provide one number square dimensions, two numbers width x height. legend_continuous Whether label continuous features quantile value. \"auto\" labels quantile features continuous quantile_range NULL. Quantile labeling adds text annotation listing range displayed values. labels_quantile_range Whether add text label value range feature legend set quantile colors_continuous Vector colors use continuous color palette legend_discrete Whether show legend discrete (categorical) features. labels_discrete Whether add text labels center group discrete (categorical) features. colors_discrete Vector colors use discrete (categorical) features. return_data true, return data just plotting rather plot. return_plot_list TRUE, return multiple plots list, rather single plot combined using patchwork::wrap_plots() apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot UMAP or embeddings — plot_embedding","text":"default, returns ggplot2 object requested features plotted grid. return_data return_plot_list called, return value match argument.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"smoothing","dir":"Reference","previous_headings":"","what":"Smoothing","title":"Plot UMAP or embeddings — plot_embedding","text":"Smoothing performed follows: first, smoothing matrix normalized sum incoming weights every cell 1. , raw data values repeatedly multiplied smoothing matrix re-scaled average value stays .","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Fragment size distribution — plot_fragment_length","title":"Fragment size distribution — plot_fragment_length","text":"Plot distribution fragment lengths, length basepairs x-axis, proportion fragments y-axis. Typical plots show 10-basepair periodicity, well humps spaced multiples nucleosome width (150bp).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fragment size distribution — plot_fragment_length","text":"","code":"plot_fragment_length(   fragments,   max_length = 500,   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fragment size distribution — plot_fragment_length","text":"fragments Fragments object max_length Maximum length show plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fragment size distribution — plot_fragment_length","text":"Numeric vector index contans number length-fragments","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":null,"dir":"Reference","previous_headings":"","what":"Knee plot of single cell read counts — plot_read_count_knee","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"Plots read count rank vs. number reads log-log scale.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"","code":"plot_read_count_knee(   read_counts,   cutoff = NULL,   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"read_counts Vector read counts per cell cutoff (optional) Read cutoff mark plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"ggplot2 plot object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"Performs logarithmic downsampling reduce number points plotted","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TF footprint — plot_tf_footprint","title":"Plot TF footprint — plot_tf_footprint","text":"Plot footprinting around TF motif sites","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TF footprint — plot_tf_footprint","text":"","code":"plot_tf_footprint(   fragments,   motif_positions,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   flank = 250L,   smooth = 0L,   zero_based_coords = !is(genes, \"GRanges\"),   colors = discrete_palette(\"stallion\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TF footprint — plot_tf_footprint","text":"fragments IterableFragments object motif_positions Coordinate ranges motifs (must include strand) constant width cell_groups Character factor assigning group cell, order cellNames(fragments) flank Number flanking basepairs include either side motif smooth (optional) Sparse matrix dimensions cells x cells cell-cell distance weights smoothing. zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TSS profile — plot_tss_profile","title":"Plot TSS profile — plot_tss_profile","text":"Plot enrichmment insertions relative transcription start sites (TSS). Typically, plot shows strong enrichment insertions near TSS, small bump downstream around 220bp downstream TSS +1 nucleosome.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TSS profile — plot_tss_profile","text":"","code":"plot_tss_profile(   fragments,   genes,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   flank = 2000L,   smooth = 0L,   zero_based_coords = !is(genes, \"GRanges\"),   colors = discrete_palette(\"stallion\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TSS profile — plot_tss_profile","text":"fragments IterableFragments object genes Coordinate ranges genes (must include strand) cell_groups Character factor assigning group cell, order cellNames(fragments) flank Number flanking basepairs include either side motif smooth Number bases smooth (rolling average) zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":null,"dir":"Reference","previous_headings":"","what":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"Density scatter plot log10(fragment_count) x-axis TSS enrichment y-axis. plot useful select cell barcodes experiment correspond high-quality cells","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"","code":"plot_tss_scatter(   atac_qc,   min_frags = NULL,   min_tss = NULL,   bins = 100,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"atac_qc Tibble returned qc_scATAC(). Must columns nFrags TSSEnrichment min_frags Minimum fragment count cutoff min_tss Minimum TSS Enrichment cutoff bins Number bins density calculation apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Add sample prefix to cell names — prefix_cell_names","title":"Add sample prefix to cell names — prefix_cell_names","text":"Rename cells adding prefix names. commonly sample name. cells recieve exact text prefix added beginning, separator characters like \"_\" must included given prefix. Use prior merging fragments different experiments c() order help prevent cell name clashes.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add sample prefix to cell names — prefix_cell_names","text":"","code":"prefix_cell_names(fragments, prefix)"},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add sample prefix to cell names — prefix_cell_names","text":"fragments Input fragments object. prefix String add prefix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add sample prefix to cell names — prefix_cell_names","text":"Fragments object prefixed names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/pseudobulk_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","title":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","text":"Given (features x cells) matrix, group cells cell_groups aggregate counts method feature.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/pseudobulk_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","text":"","code":"pseudobulk_matrix(mat, cell_groups, method = \"sum\", threads = 1L)"},{"path":"https://bnprks.github.io/BPCells/reference/pseudobulk_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","text":"mat IterableMatrix object dimensions features x cells cell_groups (Character/factor) Vector group/cluster assignments cell. Length must ncol(mat). method (Character vector) Method(s) aggregate counts. one method provided, output matrix. multiple methods provided, output named list matrices. Current options : nonzeros, sum, mean, variance. threads (integer) Number threads use.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/pseudobulk_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","text":"method length 1, returns matrix shape (features x groups). method greater length 1, returns list matrices matrix representing pseudobulk matrix different aggregation method. matrix shape (features x groups), names one nonzeros, sum, mean, variance.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/pseudobulk_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate counts matrices by cell group or feature. — pseudobulk_matrix","text":"simpler stats calculated process calculating complex statistics. calculating variance, nonzeros mean can included extra calculation time, calculating mean, adding nonzeros take extra time.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"Calculate ArchR-compatible per-cell QC statistics","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"","code":"qc_scATAC(fragments, genes, blacklist)"},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"fragments IterableFragments object genes Gene coordinates given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position blacklist Blacklisted regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"data.frame QC data","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"implementation mimics ArchR's default parameters. uses requiring flexibility tweak default parameters, best option re-implement function required changes. Output columns data.frame: cellName: cell name cell nFrags: number fragments per cell subNucleosomal, monoNucleosomal, multiNucleosomal: number fragments size 1-146bp, 147-254bp, 255bp + respectively. equivalent ArchR's nMonoFrags, nDiFrags, nMultiFrags respectively TSSEnrichment: AvgInsertInTSS / max(AvgInsertFlankingTSS, 0.1), AvgInsertInTSS ReadsInTSS / 101 (window size), AvgInsertFlankingTSS ReadsFlankingTSS / (100*2) (window size). max(0.1) ensures low-read cells get assigned spuriously high TSSEnrichment. ReadsInPromoter: Number reads 2000bp upstream TSS 101bp downstream TSS ReadsInBlacklist: Number reads provided blacklist region ReadsInTSS: Number reads overlapping 101bp centered around TSS ReadsFlankingTSS: Number reads overlapping 1901-2000bp +/- TSS Differences ArchR: Note ArchR default uses different set annotations derive TSS sites promoter sites. function uses just one annotation gene start+end sites, must called twice exactly re-calculate ArchR QC stats. ArchR's PromoterRatio BlacklistRatio included output, can easily calculated ReadsInPromoter / nFrags  ReadsInBlacklist / nFrags. Similarly, ArchR's NucleosomeRatio can calculated (monoNucleosomal + multiNucleosomal) / subNucleosomal.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":null,"dir":"Reference","previous_headings":"","what":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"Given set genomic ranges, find distance nearest neighbors upstream downstream.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"","code":"range_distance_to_nearest(   ranges,   addArchRBug = FALSE,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"ranges Genomic regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand addArchRBug boolean reproduce ArchR's bug incorrectly handles nested genes zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"2-column data.frame columns upstream downstream, containing distances nearest neighbor respective directions. ranges + * strand, distance calculated : upstream = max(start(range) - end(upstreamNeighbor), 0) downstream = max(start(downstreamNeighbor) - end(range), 0) ranges - strand, definition upstream downstream flipped. Note definition distance one GenomicRanges::distance(), ranges neighbor overlap given distance 1 rather 0.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank-transform a matrix — rank_transform","title":"Rank-transform a matrix — rank_transform","text":"Rank values within row/col matrix, output rank values new matrix. Rank values offset rank 0 value 0, ties handled averaging ranks.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank-transform a matrix — rank_transform","text":"","code":"rank_transform(mat, axis)"},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank-transform a matrix — rank_transform","text":"mat Data matrix (IterableMatrix) axis Axis rank values within. \"col\" rank values within column, \"row\" rank values within row.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank-transform a matrix — rank_transform","text":"Note efficient rank calculation depends storage order matrix, may necessary call transpose_storage_order()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a bed file into a data frame — read_bed","title":"Read a bed file into a data frame — read_bed","text":"Bed files can contain peak blacklist annotations. utilities help read thos annotations","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a bed file into a data frame — read_bed","text":"","code":"read_bed(   path,   additional_columns = character(0),   backup_url = NULL,   timeout = 300 )  read_encode_blacklist(   dir,   genome = c(\"hg38\", \"mm10\", \"hg19\", \"dm6\", \"dm3\", \"ce11\", \"ce10\"),   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a bed file into a data frame — read_bed","text":"path Path file (desired save location backup_url used) additional_columns Names additional columns bed file backup_url path exist, provides URL download gtf timeout Maximum time seconds wait download backup_url dir Output directory cache downloaded gtf file genome genome name","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a bed file into a data frame — read_bed","text":"Data frame coordinates using 0-based convention.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a bed file into a data frame — read_bed","text":"read_bed Read bed file disk url. read_encode_blacklist Downloads Boyle Lab blacklist, described https://doi.org/10.1038/s41598-019-45839-z","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":null,"dir":"Reference","previous_headings":"","what":"Read GTF gene annotations — read_gtf","title":"Read GTF gene annotations — read_gtf","text":"Read gene annotations gtf format data frame. source can URL, gtf file disk, gencode release version.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read GTF gene annotations — read_gtf","text":"","code":"read_gtf(   path,   attributes = c(\"gene_id\"),   tags = character(0),   features = c(\"gene\"),   keep_attribute_column = FALSE,   backup_url = NULL,   timeout = 300 )  read_gencode_genes(   dir,   release = \"latest\",   annotation_set = c(\"basic\", \"comprehensive\"),   gene_type = \"lncRNA|protein_coding|IG_.*_gene|TR_.*_gene\",   attributes = c(\"gene_id\", \"gene_type\", \"gene_name\"),   tags = character(0),   features = c(\"gene\"),   timeout = 300 )  read_gencode_transcripts(   dir,   release = \"latest\",   transcript_choice = c(\"MANE_Select\", \"Ensembl_Canonical\", \"all\"),   annotation_set = c(\"basic\", \"comprehensive\"),   gene_type = \"lncRNA|protein_coding|IG_.*_gene|TR_.*_gene\",   attributes = c(\"gene_id\", \"gene_type\", \"gene_name\", \"transcript_id\"),   features = c(\"transcript\", \"exon\"),   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read GTF gene annotations — read_gtf","text":"path Path file (desired save location backup_url used) attributes Vector GTF attribute names parse columns tags Vector tags parse boolean presence/absence features List features types keep GTF (e.g. gene, transcript, exon, intron) keep_attribute_column Boolean whether preserve raw attribute text column backup_url path exist, provides URL download gtf timeout Maximum time seconds wait download backup_url dir Output directory cache downloaded gtf file release release version (prefix M mouse versions). recent version, use \"latest\" \"latest_mouse\" annotation_set Either \"basic\" \"comprehensive\" annotation sets (see details section). gene_type Regular expression gene types keep. Defaults protein_coding, lncRNA, IG/TR genes transcript_choice Method selecting representative transcripts. Choices : MANE_Select: human-, conservative Ensembl_Canonical: human+mouse, superset MANE_Select human : Preserve transcript models (recommended plotting)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read GTF gene annotations — read_gtf","text":"Data frame coordinates using 0-based convention. Columns : chr source feature start end score strand frame attributes (optional; named according listed attributes) tags (named according listed tags)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read GTF gene annotations — read_gtf","text":"read_gtf Read gtf file URL read_gencode_genes Read gene annotations directly GENCODE. file name vary depending release annotation set requested, format gencode.v42.annotation.gtf.gz. GENCODE currently recommends basic set: https://www.gencodegenes.org/human/. release 42, comprehensive basic sets identical gene-level annotations, comprehensive set additional transcript variants annotated. read_gencode_transcripts Read transcript models GENCODE, use trackplot_gene()","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/read_ucsc_chrom_sizes.html","id":null,"dir":"Reference","previous_headings":"","what":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","title":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","text":"Read chromosome sizes UCSC return tibble one row per chromosome. underlying data pulled : https://hgdownload.soe.ucsc.edu/downloads.html","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_ucsc_chrom_sizes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","text":"","code":"read_ucsc_chrom_sizes(   dir,   genome = c(\"hg38\", \"mm39\", \"mm10\", \"mm9\", \"hg19\"),   keep_chromosomes = \"chr[0-9]+|chrX|chrY\",   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. Matrix colMeans, colSums, rowMeans, rowSums","code":""},{"path":"https://bnprks.github.io/BPCells/reference/regress_out.html","id":null,"dir":"Reference","previous_headings":"","what":"Regress out unwanted variation — regress_out","title":"Regress out unwanted variation — regress_out","text":"Regress effects confounding variables using linear least squares regression model.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/regress_out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regress out unwanted variation — regress_out","text":"","code":"regress_out(mat, latent_data, prediction_axis = c(\"row\", \"col\"))"},{"path":"https://bnprks.github.io/BPCells/reference/regress_out.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regress out unwanted variation — regress_out","text":"mat Input IterableMatrix latent_data Data regress , data.frame column variable regress . prediction_axis axis corresponds prediction outputs linear models (e.g. gene axis typical single cell analysis). Options include \"row\" (default) \"col\".","code":""},{"path":"https://bnprks.github.io/BPCells/reference/regress_out.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regress out unwanted variation — regress_out","text":"IterableMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/regress_out.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regress out unwanted variation — regress_out","text":"Conceptually, regress_out calculates linear least squares best fit model row matrix. (column prediction_axis \"col\"). input data regression model columns latent_data, model tries predict values corresponding row (column) mat. fitting model, regress_out subtract model predictions input values, aiming retain effects explained variables latent_data. models can fit efficiently since share input data calculations closed-form best fit solution shared. QR factorization model matrix dense matrix-vector multiply sufficient fully calculate residual values. Efficiency considerations: output matrix dense rather sparse, mean variance calculations may run comparatively slowly. However, PCA matrix/vector multiply operations can performed nearly cost input matrix due mathematical simplifications. Memory usage scales n_features * ((nrow(mat) + ncol(mat)). Generally, n_features == ncol(latent_data), categorical variables latent_data, category expanded indicator variable. Memory usage therefore higher using categorical input variables many (.e. >100) distinct values.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate ggplot x axis labels — rotate_x_labels","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"Rotate ggplot x axis labels","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"","code":"rotate_x_labels(degrees = 45)"},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"degrees Number degrees rotate ","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"Scan fragments without performing operations (used benchmarking)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"","code":"scan_fragments(fragments)"},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"fragments Fragments object scan","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"Length 4 vector fragment count, sums chr, starts, ends","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":null,"dir":"Reference","previous_headings":"","what":"SCTransform Pearson Residuals — sctransform_pearson","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"Calculate pearson residuals negative binomial sctransform model. Normalized values calculated (X - mu) / sqrt(mu + mu^2/theta). mu calculated cell_read_counts * gene_beta.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"","code":"sctransform_pearson(   mat,   gene_theta,   gene_beta,   cell_read_counts,   min_var = -Inf,   clip_range = c(-10, 10),   columns_are_cells = TRUE,   slow = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"mat IterableMatrix (raw counts) gene_theta Vector per-gene thetas (overdispersion values) gene_beta Vector per-gene betas (expression level values) cell_read_counts Vector total reads per (umi count RNA) min_var Minimum value clipping variance clip_range Length 2 vector min max clipping range columns_are_cells Whether columns matrix correspond cells (default) genes slow TRUE, use 10x slower precise implementation (default FALSE)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"IterableMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"parameterization used somewhat simplified compared original SCTransform paper, particular uses linear-scale rather log-scale represent cell_read_counts gene_beta variables. also support addition arbitrary cell metadata (e.g. batch) add negative binomial regression.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset, translate, or reorder cell IDs — select_cells","title":"Subset, translate, or reorder cell IDs — select_cells","text":"Subset, translate, reorder cell IDs","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset, translate, or reorder cell IDs — select_cells","text":"","code":"select_cells(fragments, cell_selection)"},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset, translate, or reorder cell IDs — select_cells","text":"fragments Input fragments object cell_selection List cell IDs (numeric), names (character), logical mask.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subset, translate, or reorder cell IDs — select_cells","text":"Numeric cell IDs re-assigned order cell_selection. output cell ID n taken input cell ID/name cell_selection[n].","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset, translate, or reorder chromosome IDs — select_chromosomes","title":"Subset, translate, or reorder chromosome IDs — select_chromosomes","text":"Subset, translate, reorder chromosome IDs","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset, translate, or reorder chromosome IDs — select_chromosomes","text":"","code":"select_chromosomes(fragments, chromosome_selection)"},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset, translate, or reorder chromosome IDs — select_chromosomes","text":"fragments Input fragments object chromosome_selection List chromosme IDs (numeric), names (character), logical mask.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subset, translate, or reorder chromosome IDs — select_chromosomes","text":"Numeric chromosome IDs re-assigned order chromosome_selection. output chromosome ID n taken input chromosome ID/name chromosome_selection[n].","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset fragments by genomic region — select_regions","title":"Subset fragments by genomic region — select_regions","text":"Fragments can subset based overlapping (overlapping) set regions","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset fragments by genomic region — select_regions","text":"","code":"select_regions(   fragments,   ranges,   invert_selection = FALSE,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset fragments by genomic region — select_regions","text":"fragments Input fragments object. ranges Peaks/ranges overlap, given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position invert_selection TRUE, select fragments overlapping selected regions instead fragments overlapping selected regions. zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset fragments by genomic region — select_regions","text":"Fragments object filtered according selected regions","code":""},{"path":"https://bnprks.github.io/BPCells/reference/set_threads.html","id":null,"dir":"Reference","previous_headings":"","what":"Set matrix op thread count — set_threads","title":"Set matrix op thread count — set_threads","text":"Set number threads use sparse-dense multiply matrix_stats.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/set_threads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set matrix op thread count — set_threads","text":"","code":"set_threads(mat, threads = 0L)"},{"path":"https://bnprks.github.io/BPCells/reference/set_threads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set matrix op thread count — set_threads","text":"mat IterableMatrix, product rbind cbind threads Number threads use execution","code":""},{"path":"https://bnprks.github.io/BPCells/reference/set_threads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set matrix op thread count — set_threads","text":"valid concatenated matrices","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift start or end coordinates — shift_fragments","title":"Shift start or end coordinates — shift_fragments","text":"Shifts start end fragments fixed amount, can useful correct Tn5 offset.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift start or end coordinates — shift_fragments","text":"","code":"shift_fragments(fragments, shift_start = 0L, shift_end = 0L)"},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift start or end coordinates — shift_fragments","text":"fragments Input fragments object shift_start many basepairs shift start coords shift_end many basepairs shift end coords","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift start or end coordinates — shift_fragments","text":"Shifted fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shift start or end coordinates — shift_fragments","text":"correct Tn5 offset +/- 4bp since Tn5 cut sites opposite strands offset 9bp. However, +4/-5 bp often applied bed-format files, since end coordinate bed files 1 past last basepair sequenced DNA fragment. results bed-like format except inclusive end coordinates.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset fragments by length — subset_lengths","title":"Subset fragments by length — subset_lengths","text":"Subset fragments length","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset fragments by length — subset_lengths","text":"","code":"subset_lengths(fragments, min_len = 0L, max_len = NA_integer_)"},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset fragments by length — subset_lengths","text":"fragments Input fragments object min_len Minimum bases fragment (inclusive) max_len Maximum bases fragment (inclusive)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset fragments by length — subset_lengths","text":"Fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subset fragments by length — subset_lengths","text":"Fragment length calculated end-start","code":""},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate svds — svds","title":"Calculate svds — svds","text":"Use C++ Spectra solver (RSpectra package), order compute largest k values corresponding singular vectors. Empirically, memory usage much lower using irlba::irlba(), likely due avoiding R garbage creation solving due pure-C++ solver. documentation slightly-edited version RSpectra::svds() documentation.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate svds — svds","text":"","code":"svds(A, k, nu = k, nv = k, opts = list(), threads=0L, ...)"},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate svds — svds","text":"matrix whose truncated SVD computed. k Number singular values requested. nu Number right singular vectors computed. must 0 'k'. (Must equal 'k' BPCells IterableMatrix) opts Control parameters related computing algorithm. See Details threads Control threads use calculating mat-vec producs (BPCells specific)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate svds — svds","text":"list following components: d vector computed singular values. u m nu matrix whose columns contain left singular vectors. nu == 0, NULL returned. v n nv matrix whose columns contain right singular vectors. nv == 0, NULL returned. nconv Number converged singular values. niter Number iterations used. nops Number matrix-vector multiplications used.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate svds — svds","text":"RSpectra installed, function just add method RSpectra::svds() IterableMatrix class. opts argument list can supply following parameters: ncv Number Lanzcos basis vectors use. vectors result faster convergence, greater memory use. ncv must satisfy \\(k < ncv \\le p\\) p = min(m, n). Default min(p, max(2*k+1, 20)). tol Precision parameter. Default 1e-10. maxitr Maximum number iterations. Default 1000. center Either logical value (TRUE/FALSE), numeric vector length \\(n\\). vector \\(c\\) supplied, SVD computed matrix \\(- 1c'\\), implicit way without actually forming matrix. center = TRUE effect center = colMeans(). Default FALSE. Ignored BPCells scale Either logical value (TRUE/FALSE), numeric vector length \\(n\\). vector \\(s\\) supplied, SVD computed matrix \\((- 1c')S\\), \\(c\\) centering vector \\(S = diag(1/s)\\). scale = TRUE, vector \\(s\\) computed column norm \\(- 1c'\\). Default FALSE. Ignored BPCells","code":""},{"path":"https://bnprks.github.io/BPCells/reference/svds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate svds — svds","text":"Qiu Y, Mei J (2022). RSpectra: Solvers Large-Scale Eigenvalue SVD Problems. R package version 0.16-1, https://CRAN.R-project.org/package=RSpectra.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ranges x cells tile overlap matrix — tile_matrix","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"Calculate ranges x cells tile overlap matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"","code":"tile_matrix(   fragments,   ranges,   mode = c(\"insertions\", \"fragments\"),   zero_based_coords = !is(ranges, \"GRanges\"),   explicit_tile_names = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"fragments Input fragments object ranges Tiled regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position tile_width: Size tile region basepairs Must non-overlapping sorted (chr, start), chromosomes ordered according chromosome names fragments mode Mode counting tile overlaps. (See \"value\" section detail) zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost) explicit_tile_names Boolean whether add rownames output matrix format e.g chr1:500-1000, start end coords given 0-based coordinate system. whole-genome Tile matrices names take ~5 seconds generate take 400MB memory. Note either way, tile names written matrix saved.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"Iterable matrix object dimension ranges x cells. saved, column names format chr1:500-1000, start end coords given 0-based coordinate system. mode options \"insertions\": Start end coordinates separately overlapped tile \"fragments\": Like \"insertions\", fragment can contribute 1 count tile, even start end coordinates overlap","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"calculating matrix directly fragments tsv, necessary first call select_chromosomes() order provide ordering chromosomes expect reading tsv.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","title":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","text":"Get ranges corresponding selected tiles tile matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","text":"","code":"tile_ranges(tile_matrix, selection)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudobulk trackplot — trackplot_bulk","title":"Pseudobulk trackplot — trackplot_bulk","text":"function renamed trackplot_coverage() Plot pseudobulk genome track, showing number fragment insertions across region.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pseudobulk trackplot — trackplot_bulk","text":"","code":"trackplot_bulk(   fragments,   region,   groups,   cell_read_counts,   group_order = NULL,   bins = 200,   clip_quantile = 0.999,   colors = discrete_palette(\"stallion\"),   legend_label = \"group\",   zero_based_coords = !is(region, \"GRanges\"),   return_data = FALSE,   return_plot_list = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pseudobulk trackplot — trackplot_bulk","text":"fragments Fragments object region GRanges length 1 region plot, list/data.frame one entry chr, start, end. See gene_region() genomic-ranges details groups Vector one entry per cell, specifying cell's group cell_read_counts Numeric vector read counts cell (used normalization) group_order Optional vector listing ordering groups bins Number bins plot across region clip_quantile (optional) Quantile values clipping y-axis limits. Default 0.999 crop just extreme outliers across region. NULL disable clipping colors Character vector color values (optionally named group) legend_label Custom label put legend zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost) return_data true, return data just plotting rather plot. return_plot_list TRUE, return multiple plots list, rather single plot combined using patchwork::wrap_plots() apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pseudobulk trackplot — trackplot_bulk","text":"Returns combined plot pseudobulk genome tracks. compatability draw_trackplot_grid(), extra attribute $patches$labels added specify labels track. return_data return_plot_list TRUE, return value modified accordingly.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_calculate_segment_height.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate y positions for trackplot segments to avoid overlap Steps:  Calculate the maximum overlap depth of transcripts Iterate through start/end of segments in sorted order Randomly assign each segment a y-coordinate between 1 and max overlap depth, with the restriction that a segment can't have the same y-coordinate as an overlapping segment  — trackplot_calculate_segment_height","title":"Calculate y positions for trackplot segments to avoid overlap Steps:  Calculate the maximum overlap depth of transcripts Iterate through start/end of segments in sorted order Randomly assign each segment a y-coordinate between 1 and max overlap depth, with the restriction that a segment can't have the same y-coordinate as an overlapping segment  — trackplot_calculate_segment_height","text":"Calculate y positions trackplot segments avoid overlap Steps: Calculate maximum overlap depth transcripts Iterate start/end segments sorted order Randomly assign segment y-coordinate 1 max overlap depth, restriction segment y-coordinate overlapping segment","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_calculate_segment_height.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate y positions for trackplot segments to avoid overlap Steps:  Calculate the maximum overlap depth of transcripts Iterate through start/end of segments in sorted order Randomly assign each segment a y-coordinate between 1 and max overlap depth, with the restriction that a segment can't have the same y-coordinate as an overlapping segment  — trackplot_calculate_segment_height","text":"","code":"trackplot_calculate_segment_height(data)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_calculate_segment_height.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate y positions for trackplot segments to avoid overlap Steps:  Calculate the maximum overlap depth of transcripts Iterate through start/end of segments in sorted order Randomly assign each segment a y-coordinate between 1 and max overlap depth, with the restriction that a segment can't have the same y-coordinate as an overlapping segment  — trackplot_calculate_segment_height","text":"data tibble genome ranges start end columns, assumed chromosome.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_calculate_segment_height.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate y positions for trackplot segments to avoid overlap Steps:  Calculate the maximum overlap depth of transcripts Iterate through start/end of segments in sorted order Randomly assign each segment a y-coordinate between 1 and max overlap depth, with the restriction that a segment can't have the same y-coordinate as an overlapping segment  — trackplot_calculate_segment_height","text":"Vector y coordinates, one per input row, ranges y coordinate overlap","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_combine.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine track plots — trackplot_combine","title":"Combine track plots — trackplot_combine","text":"Combines multiple track plots region single grid. Uses patchwork package perform alignment.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_combine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine track plots — trackplot_combine","text":"","code":"trackplot_combine(   tracks,   side_plot = NULL,   title = NULL,   side_plot_width = 0.3 )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_combine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine track plots — trackplot_combine","text":"tracks List tracks order top bottom, generally ggplots output trackplot_*() functions. side_plot Optional plot align right (e.g. RNA expression per cluster). aligned first trackplot_coverage() output present, else first generic ggplot alignment. horizontal orientation cluster ordering coverage plots. title Text overarching title plot side_plot_width Fraction width used side plot relative main track area","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_combine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine track plots — trackplot_combine","text":"plot object aligned genome plots. aligned row text label, y-axis, plot body. relative height row given heights. shared title x-axis put top.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudobulk coverage trackplot — trackplot_coverage","title":"Pseudobulk coverage trackplot — trackplot_coverage","text":"Plot pseudobulk genome track, showing number fragment insertions across region cell type group.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pseudobulk coverage trackplot — trackplot_coverage","text":"","code":"trackplot_coverage(   fragments,   region,   groups,   cell_read_counts,   group_order = NULL,   bins = 500,   clip_quantile = 0.999,   colors = discrete_palette(\"stallion\"),   legend_label = NULL,   zero_based_coords = !is(region, \"GRanges\"),   return_data = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pseudobulk coverage trackplot — trackplot_coverage","text":"fragments Fragments object region Region plot, e.g. output gene_region(). String format \"chr1:100-200\", list/data.frame/GRanges length 1 specifying chr, start, end. See help(\"genomic-ranges-like\") details groups Vector one entry per cell, specifying cell's group cell_read_counts Numeric vector read counts cell (used normalization) group_order Optional vector listing ordering groups bins Number bins plot across region clip_quantile (optional) Quantile values clipping y-axis limits. Default 0.999 crop just extreme outliers across region. NULL disable clipping colors Character vector color values (optionally named group) legend_label Custom label put legend (longer used color legend shown anymore) zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see archived UCSC blogpost) return_data true, return data just plotting rather plot. scale_bar Whether include scale bar top track (TRUE FALSE)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pseudobulk coverage trackplot — trackplot_coverage","text":"Returns combined plot pseudobulk genome tracks. compatability draw_trackplot_grid(), extra attribute $patches$labels added specify labels track. return_data return_plot_list TRUE, return value modified accordingly.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_create_arrow_segs.html","id":null,"dir":"Reference","previous_headings":"","what":"Break up segments into smaller segments the length of the plot, divided by size — trackplot_create_arrow_segs","title":"Break up segments into smaller segments the length of the plot, divided by size — trackplot_create_arrow_segs","text":"Break segments smaller segments length plot, divided size","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_create_arrow_segs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Break up segments into smaller segments the length of the plot, divided by size — trackplot_create_arrow_segs","text":"","code":"trackplot_create_arrow_segs(data, region, size = 50, head_only = FALSE)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_create_arrow_segs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Break up segments into smaller segments the length of the plot, divided by size — trackplot_create_arrow_segs","text":"data Dataframe full segments broken region Region plotted end start attr size int Number arrows span x axis track head_only bool TRUE, head segment plotted","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_create_arrow_segs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Break up segments into smaller segments the length of the plot, divided by size — trackplot_create_arrow_segs","text":"Dataframe segments broken smaller segments.  columns start, end, additional metadata columns original data","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot transcript models — trackplot_gene","title":"Plot transcript models — trackplot_gene","text":"Plot transcript models","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot transcript models — trackplot_gene","text":"","code":"trackplot_gene(   transcripts,   region,   exon_size = 2.5,   gene_size = 0.5,   label_size = 11 * 0.8/ggplot2::.pt,   track_label = \"Genes\",   return_data = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot transcript models — trackplot_gene","text":"transcripts Transcipt features given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position strand: +/- TRUE/FALSE positive negative strand feature: entries marked \"transcript\" \"exon\" considered gene_name: Symbol gene ID display transcript_id: Transcritp identifier link transcripts exons Usually given output read_gencode_transcripts() region Region plot, e.g. output gene_region(). String format \"chr1:100-200\", list/data.frame/GRanges length 1 specifying chr, start, end. See help(\"genomic-ranges-like\") details exon_size size exon lines units mm gene_size size intron/gene lines units mm label_size size transcript labels units mm return_data true, return data just plotting rather plot. labels Character vector labels item transcripts. NA items labeled transcript_size size transcript lines units mm","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot transcript models — trackplot_gene","text":"Plot gene locations","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_genome_annotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot range-based annotation tracks (e.g. peaks) — trackplot_genome_annotation","title":"Plot range-based annotation tracks (e.g. peaks) — trackplot_genome_annotation","text":"Plot range-based annotation tracks (e.g. peaks)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_genome_annotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot range-based annotation tracks (e.g. peaks) — trackplot_genome_annotation","text":"","code":"trackplot_genome_annotation(   loci,   region,   color_by = NULL,   colors = NULL,   label_by = NULL,   label_size = 11 * 0.8/ggplot2::.pt,   show_strand = FALSE,   annotation_size = 2.5,   track_label = \"Peaks\",   return_data = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_genome_annotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot range-based annotation tracks (e.g. peaks) — trackplot_genome_annotation","text":"loci Genomic loci given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position region Region plot, e.g. output gene_region(). String format \"chr1:100-200\", list/data.frame/GRanges length 1 specifying chr, start, end. See help(\"genomic-ranges-like\") details color_by Name metadata column loci use coloring, data vector length loci. Column must numeric convertible factor. colors Vector hex color codes use color scale. numeric color_by data, passed ggplot2::scale_color_gradientn(), otherwise interpreted discrete color palette ggplot2::scale_color_manual() label_by Name metadata column loci use labeling, data vector length loci. Column must hold string data. label_size size labels units mm show_strand TRUE, show strand direction arrows annotation_size size annotation lines mm return_data true, return data just plotting rather plot.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_genome_annotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot range-based annotation tracks (e.g. peaks) — trackplot_genome_annotation","text":"Plot genomic loci return_data FALSE, otherwise returns data frame used generate plot","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_loop.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot loops — trackplot_loop","title":"Plot loops — trackplot_loop","text":"Plot loops","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_loop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot loops — trackplot_loop","text":"","code":"trackplot_loop(   loops,   region,   color_by = NULL,   colors = NULL,   allow_truncated = TRUE,   curvature = 0.75,   track_label = \"Links\",   return_data = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_loop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot loops — trackplot_loop","text":"loops Genomic regions given GRanges, data.frame, list. See help(\"genomic-ranges-like\") details format coordinate systems. Required attributes: chr, start, end: genomic position region Region plot, e.g. output gene_region(). String format \"chr1:100-200\", list/data.frame/GRanges length 1 specifying chr, start, end. See help(\"genomic-ranges-like\") details color_by Name metadata column loops use coloring, data vector length loci. Column must numeric convertible factor. colors Vector hex color codes use color scale. numeric color_by data, passed ggplot2::scale_color_gradientn(), otherwise interpreted discrete color palette ggplot2::scale_color_manual() allow_truncated FALSE, remove loops fully contained within region curvature Curvature value 0 1. 1 180-degree arc, 0 flat lines. return_data true, return data just plotting rather plot.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_loop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot loops — trackplot_loop","text":"Plot loops connecting genomic coordinates","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_normalize_ranges_with_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize trackplot ranges data, while handling metadata argument renaming and type conversions Type conversions are as follows: color -> factor or numeric label -> string — trackplot_normalize_ranges_with_metadata","title":"Normalize trackplot ranges data, while handling metadata argument renaming and type conversions Type conversions are as follows: color -> factor or numeric label -> string — trackplot_normalize_ranges_with_metadata","text":"Normalize trackplot ranges data, handling metadata argument renaming type conversions Type conversions follows: color -> factor numeric label -> string","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_normalize_ranges_with_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize trackplot ranges data, while handling metadata argument renaming and type conversions Type conversions are as follows: color -> factor or numeric label -> string — trackplot_normalize_ranges_with_metadata","text":"","code":"trackplot_normalize_ranges_with_metadata(data, metadata)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_normalize_ranges_with_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize trackplot ranges data, while handling metadata argument renaming and type conversions Type conversions are as follows: color -> factor or numeric label -> string — trackplot_normalize_ranges_with_metadata","text":"data Input ranges-like object metadata List form e.g. list(color=color_by, label=label_by). values can either column names data vectors. NULL values skipped","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_normalize_ranges_with_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize trackplot ranges data, while handling metadata argument renaming and type conversions Type conversions are as follows: color -> factor or numeric label -> string — trackplot_normalize_ranges_with_metadata","text":"Tibble normalized ranges additional columns populated requested metadata","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_scalebar.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot scale bar — trackplot_scalebar","title":"Plot scale bar — trackplot_scalebar","text":"Plots human-readable scale bar coordinates region plotted","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_scalebar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot scale bar — trackplot_scalebar","text":"","code":"trackplot_scalebar(region, font_pt = 11)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_scalebar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot scale bar — trackplot_scalebar","text":"region Region plot, e.g. output gene_region(). String format \"chr1:100-200\", list/data.frame/GRanges length 1 specifying chr, start, end. See help(\"genomic-ranges-like\") details font_pt Font size scale bar labels units pt.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_scalebar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot scale bar — trackplot_scalebar","text":"Plot coordinates scalebar plotted genomic region","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_utils.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust trackplot properties — set_trackplot_label","title":"Adjust trackplot properties — set_trackplot_label","text":"Adjust labels heights trackplots. Labels set facet labels ggplot2, heights additional properties read trackplot_combine() determine relative height input plots.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_utils.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust trackplot properties — set_trackplot_label","text":"","code":"set_trackplot_label(plot, labels)  set_trackplot_height(plot, height)  get_trackplot_height(plot)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_utils.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust trackplot properties — set_trackplot_label","text":"plot ggplot object labels character vector labels – must match existing number facets plot height New height. numeric, adjusts relative height. ggplot2::unit grid::unit sets absolute height specified units. \"null\" units interpreted relative height.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_utils.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust trackplot properties — set_trackplot_label","text":"set_trackplot_label: ggplot object adjusted facet labels set_trackplot_height: ggplot object adjusted trackplot height get_trackplot_height: ggplot2::unit object height setting","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose the storage order for a matrix — transpose_storage_order","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"Transpose storage order matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"","code":"transpose_storage_order(   matrix,   outdir = tempfile(\"transpose\"),   tmpdir = tempdir(),   load_bytes = 4194304L,   sort_bytes = 1073741824L )"},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"matrix Input matrix outdir Directory store output tmpdir Temporary directory use intermediate storage load_bytes minimum contiguous load size merge sort passes sort_bytes amount memory allocate re-sorting chunks entries","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"MatrixDir object copy input matrix, storage order flipped","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"re-sorts entries matrix change storage order row-major col-major. large matrices, can slow – around 2 minutes transpose 500k cell RNA-seq matrix default load_bytes (4MiB) sort_bytes (1GiB) parameters allow ~85GB data sorted two passes data, ~7.3TB data sorted three passes data.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/wrapMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","title":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","text":"Helps avoid duplicate storage dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/wrapMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","text":"","code":"wrapMatrix(class, m, ...)"},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bed.html","id":null,"dir":"Reference","previous_headings":"","what":"Create bed files from fragments split by cell group. — write_insertion_bed","title":"Create bed files from fragments split by cell group. — write_insertion_bed","text":"Create bed files fragments split cell group.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create bed files from fragments split by cell group. — write_insertion_bed","text":"","code":"write_insertion_bed(   fragments,   path,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   insertion_mode = c(\"start_only\", \"both\", \"end_only\"),   verbose = FALSE,   threads = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create bed files from fragments split by cell group. — write_insertion_bed","text":"fragments IterableFragments object path (character vector) Path save bed files. cell_groups provided, must character vector one name level cell_groups Else, must character vector length 1. cell_groups (character vector factor) Cluster assignments cell. insertion_mode (string) fragment ends use coverage calculation. One \"\", \"start_only\", \"end_only\" verbose (bool) Whether provide verbose progress output console. threads (int) Number threads use.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create bed files from fragments split by cell group. — write_insertion_bed","text":"NULL","code":""},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bedgraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Write insertion counts to bedgraph file — write_insertion_bedgraph","title":"Write insertion counts to bedgraph file — write_insertion_bedgraph","text":"Write insertion counts data one pseudobulks bedgraph format. reports total number insertions basepair group listed cell_groups.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bedgraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write insertion counts to bedgraph file — write_insertion_bedgraph","text":"","code":"write_insertion_bedgraph(   fragments,   path,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   insertion_mode = c(\"both\", \"start_only\", \"end_only\") )"},{"path":"https://bnprks.github.io/BPCells/reference/write_insertion_bedgraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write insertion counts to bedgraph file — write_insertion_bedgraph","text":"fragments IterableFragments object path (character vector) Path(s) save bedgraph , optionally ending \".gz\" add gzip compression. cell_groups provided, path must named character vector, one name level cell_groups cell_groups Character factor assigning group cell, order cellNames(fragments) insertion_mode (string) fragment ends use coverage calculation. One \"\", \"start_only\", \"end_only\"","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bpcells-10-roadmap","dir":"Changelog","previous_headings":"","what":"BPCells 1.0 Roadmap","title":"BPCells 1.0 Roadmap","text":"Parallelization (basic support complete. See ) Native python library (re-using C++ backend) Peak-gene correlations MACS peak calling Contributions welcome :)","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"features-0-2-1","dir":"Changelog","previous_headings":"","what":"Features","title":"BPCells 0.2.1 (main branch - in progress)","text":"apply_by_col() apply_by_row() allow providing custom R functions compute per row/col summaries. initial tests calculating row/col means using R functions ~2x slower C++-based implementation memory usage remains low. Add rowMaxs() colMaxs() functions, return maximum value row column matrix. matrixStats MatrixGenerics packages installed, BPCells::rowMaxs() fall back implementations non-BPCells objects. Thanks @immanuelazn first contribution new lab hire! Add regress_out() allow removing unwanted sources variation via least squares linear regression models. Thanks @ycli1995 pull request #110 Add trackplot_genome_annotation() plotting peaks, options directional arrows, colors, labels, peak widths. (pull request #113) Add MACS2/3 input creation peak calling call_peaks_macs()(pull request #118). Note, renamed call_macs_peaks() pull request #143 Add rowQuantiles() colQuantiles() functions, return quantiles row/column matrix. Currently rowQuantiles() works row-major matrices colQuantiles() works col-major matrices. matrixStats MatrixGenerics packages installed, BPCells::colQuantiles() fall back implementations non-BPCells objects. (pull request #128) Add pseudobulk_matrix() allows pseudobulk aggregation sum mean calculation per-pseudobulk variance nonzero statistics gene (pull request #128)","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"improvements-0-2-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"BPCells 0.2.1 (main branch - in progress)","text":"trackplot_loop() now accepts discrete color scales trackplot_combine() now smarter layout logic margins, well detecting plots combined cover different genomic regions. (pull request #116) select_cells() select_chromosomes() now also allow using logical mask selection. (pull request #117) BPCells installation can now also configured setting LDFLAGS CFLAGS environment variables addition setting ~/.R/Makevars (pull request #124) open_matrix_anndata_hdf5() now supports reading AnnData matrices dense format. (pull request #146) cluster_graph_leiden() now better defaults produce reasonable cluster counts regardless dataset size. (pull request #147)","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bug-fixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bug-fixes","title":"BPCells 0.2.1 (main branch - in progress)","text":"Fixed error message matrix large converted dgCMatrix. (Thanks @RookieA1 reporting issue #95) Fixed forgetting dimnames subsetting certain sets operations. (Thanks @Yunuuuu reporting issues #97 #100) Fixed plotting crashes running trackplot_coverage() fragments single cluster. (Thanks @sjessa directly reporting bug coming fix) Fixed issues trackplot_coverage() called ranges less 500 bp length (Thanks @bettybliu directly reporting bug.) Fix Rcpp warning created handling compressed matrices one non-zero entry (pull request #123) Fixed discrepancy default ArchR BPCells peak calling insertion method, BPCells defaulted using start fragment opposed ArchR’s method using start end sites fragments (pull request #143) Fix error tile_matrix() fragment mode (pull request #141) Fix precision bug sctransform_pearson() ARM architecture (pull request #141) Fix type-confusion error pseudobulk_matrix() gets integer matrix (pull request #174)","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"deprecations-0-2-1","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"BPCells 0.2.1 (main branch - in progress)","text":"trackplot_coverage() legend_label argument now ignored, color legend longer shown default coverage plots.","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bpcells-020-6142024","dir":"Changelog","previous_headings":"","what":"BPCells 0.2.0 (6/14/2024)","title":"BPCells 0.2.0 (6/14/2024)","text":"finally declaring new release version, covering large amount changes improvements past year. Among major features parallelization options svds() matrix_stats(), improved genomic track plots, runtime CPU feature detection SIMD code (enables higher performance, portable builds). Full details changes . version also comes new installation path, done preparation future Python package release. (can one folder R one Python, rather R files sit root folder). breaking change requires slightly modified installation command. Thanks @brgew, @ycli1995, @Yunuuuu pull requests contributed release, well users submitted github issues help identify fix bugs.","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"BPCells 0.2.0 (6/14/2024)","text":"r-universe mirrors add \"subdir\": \"r\" packages.json config. New slots added 10x matrix objects, saved RDS files may need 10x matrix inputs re-opened replaced calling all_matrix_inputs(). Outside loading old RDS files changes needed. trackplot_gene() now returns plot facet label match new trackplot system. label can removed calling trackplot_gene(...) + ggplot2::facet_null() equivalent old function’s output.","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"deprecations-0-2-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"BPCells 0.2.0 (6/14/2024)","text":"draw_trackplot_grid() deprecated, replaced trackplot_combine() simplified arguments trackplot_bulk() deprecated, replaced trackplot_coverage() equivalent functionality old function names output deprecation warnings, otherwise work .","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"features-0-2-0","dir":"Changelog","previous_headings":"","what":"Features","title":"BPCells 0.2.0 (6/14/2024)","text":"New svds() function, based excellent Spectra C++ library (used RSpectra) Yixuan Qiu. ensure lower memory usage compared irlba, achieving similar speed + accuracy. normalizations supported, operations like marker_features() writing matrix disk remain single-threaded. Running svds() many threads gene-major matrices can result high memory usage now. problem present cell-major matrices. Reading text-based MatrixMarket inputs (e.g. 10x Parse) now supported via import_matrix_market() convenience function import_matrix_market_10x(). implementation uses disk-backed sorting allow importing large files low memory usage. Added binarize() function associated generics <, <=, >, >=. supports comparison non-negative numbers currently. (Thanks contribution @brgew) Added round() matrix transformation (Thanks contributions @brgew) Add getter/setter function all_matrix_inputs() help enable relocating underlying storage BPCells matrix transform objects. hdf5-writing functions now support gzip_level parameter, enable shuffle + gzip filter compression. generally much slower bitpacking compression, adds improved storage options files must read outside programs. Thanks @ycli1995 submitting improvement pull #42. AnnData export now supported via write_matrix_anndata_hdf5() (issue #49) Re-licensed code base use dual-licensed Apache V2 MIT instead GPLv3 Assigning subset now supported (e.g. m1[,j] <- m2). Note modify data disk. Instead, uses series subsetting concatenation operations provide appearance overwriting appropriate entries. Added knn_to_geodesic_graph(), matches Scanpy default construction graph-based clustering Add checksum(), allows calculating MD5 checksum matrix contents. Thanks @brgrew submitting improvement pull request #83 write_insertion_bedgraph() allows exporting pseudobulk insertion data bedgraph format","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"BPCells 0.2.0 (6/14/2024)","text":"Merging fragments c() now handles inputs mismatched chromosome names. Merging fragments now 2-3.5x faster SNN graph construction knn_to_snn_graph() work smoothly large datasets due C++ implementation Reduced memory usage marker_features() samples millions cells large number clusters compare. Windows, increased maximum number files can simultaneously open. Previously, opening >63 compressed counts matrices simultaneously hit limit. Now least 1,000 simultaneous matrices possible. Subsetting peak tile matrices [ now propagates always avoid computing parts peak/tile matrix discarded subset. Subsetting tile matrix automatically convert peak matrix possible improved efficiency. Subsetting RowBindMatrices ColBindMatrices now propagates avoid touching matrices selected indices Added logic help reduce cases subsetting causes BPCells fall back less efficient matrix-vector multiply algorithm. affects math transforms. part , filtering part subset propagate earlier transformation steps, reordering . Thanks @nimanouri-nm raising issue #65 fix bug initial implementation. Additional C++17 filesystem backwards compatibility allow slightly older compilers GCC 7.5 build BPCells. .matrix() produce integer matrices appropriate (Thanks @Yunuuuu pull #77) 10x HDF5 matrices can now read write non-integer types requested (Thanks @ycli1995 pull #75) Old-style 10x files cellranger v2 can now read multi-genome files, returned list (Thanks @ycli1995 pull #75) Trackplots now use faceting provide per-plot labels, leading easier--use trackplot_combine() trackplot_gene() now draws arrows direction transcription trackplot_loop() new track type allows plotting interactions genomic regions, instance peak-gene correlations loop calls Hi-C trackplot_scalebar() added show genomic scale trackplot functions now return ggplot objects additional metadata stored plotting height track Labels heights trackplots can adjusted using set_trackplot_label() set_trackplot_height() getting started pbmc 3k vignette now includes updated trackplot APIs final example Add rowVars() colVars() functions, convenience wrappers around matrix_stats(). matrixStats MatrixGenerics packages installed, BPCells::rowVars() fall back implementations non-BPCells objects. Unfortunately, matrixStats::rowVars() generic, either BPCells::rowVars() BPCells::colVars() Optimize mean variance calculations matrices added per-row per-column constant. Adds run-time detection CPU features eliminate architecture-specific compilation now, Pow SIMD implementation removed, Square gets new SIMD implementation Empirically, operations using SIMD math instructions 2x faster. includes log1p(), sctransform_pearson() Minor speedups dense-sparse matrix multiply functions (1.1-1.5x faster)","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug-fixes","title":"BPCells 0.2.0 (6/14/2024)","text":"Fixed fragment transforms using chrNames(frags) <- val cellNames(frags) <- val cause downstream errors. Fixed errors transpose_storage_order() matrices >4 billion non-zero entries. Fixed error transpose_storage_order() matrices non-zero entries. Fixed bug writing fragment files >512 chromosomes. Fixed bug reading fragment files >4 billion fragments. Fixed file permissions errors using read-hdf5 files (Issue #26 reported thanks @ttumkaya) Renaming rownames() colnames() now propagated saving matrices (Issue #29 reported thanks @realzehuali, additional fix report thanks @Dario-Rocha) Fixed 64-bit integer overflow (!) cause incorrect p-value calculations marker_features() features 2.6 million zeros. Improved robustness Windows installation process setups need -lsz linker flag compile hdf5 Fixed possible memory safety bug wrapped R objects (dgCMatrix) potentially garbage collected C++ still trying access data rare circumstances. Fixed case dimnames preserved calling convert_matrix_type() twice row cancels (e.g. double -> uint32_t -> double). Thanks @brgrew reporting issue #43 Caused fixed issue resulting unusably slow performance reading matrices HDF5 files. Broken versions range commit 21f8dcf fix 3711a40 (October 18-November 3, 2023). Thanks @abhiachoudhary reporting issue #53 Fixed error svds() handling row-major matrices correctly. Thanks @ycli1995 reporting issue #55 Fixed error row/col name handling AnnData matrices. Thanks @lisch7 reporting issue #57 Fixed error merging matrices different data types. Thanks @Yunuuuu identifying issue providing fix (#68 #70) Fixed issue losing dimnames subset assignment [<-. Thanks @Yunuuuu identifying issue #67 Fixed incorrect results cases scaling matrix shifting. Thanks @Yunuuuu identifying issue #72 Fixed infinite loop bug calling transpose_storage_order() densely-transformed matrix. Thanks @Yunuuuu reporting issue #71 h5ad outputs now subset properly loaded Python anndata package (Thanks issue described @ggruenhagen3 issue #49 fixed @ycli1995 pull #81) Disk-backed fragment objects now load via absolute path, matching behavior matrices making objects loaded via readRDS() can used different working directories. footprints() now respects user interrupts via Ctrl-C","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"features-0-1-0","dir":"Changelog","previous_headings":"","what":"Features","title":"BPCells 0.1.0 (4/7/2023)","text":"Reading/writing 10x fragment files disk Reading/writing compressed fragments disk (folder hdf5 group) Interconversion fragments objects GRanges / data.frame Merging multiple source fragment files transparently run time Calculation Cell x Peak matrices, Cell x Tile matrices ArchR-compatible QC calculations ArchR-compatible gene activity score calculations Filtering fragments chromosmes, cells, lengths, genomic region Fast peak calling approximation via overlapping tiles Conversion /R sparse matrices Read-write access 10x hdf5 feature matrices, read-access AnnData files Reading/writing compressed matrices disk (folder hdf5 group) Support integer single/double-precision floating point matrices disk Fast transposition storage order, switch indexing cell gene/feature. Concatenation multiple source matrix files transparently run time Single-pass calculation row/column mean variance Wilcoxon marker feature calculation Transparent handling vector +, -, *, /, log1p streaming normalization, along less common operations. allows implementation ATAC-seq LSI Seurat default normalization, along published log-based normalizations. SCTransform pearson residual calculation Multiplication sparse matrices Read count knee cutoffs UMAP embeddings Dot plots Transcription factor footprinting / TSS profile plotting Fragments vs. TSS Enrichment ATAC-seq QC plot Pseudobulk genome track plots, gene annotation plots Matching gene symbols/IDs canonical symbols Download transcript annotations Gencode GTF files Download + parse UCSC chromosome sizes Parse peak files BED format; Download ENCODE blacklist region Wrappers knn graph calculation + clustering Note: operations interoperate storage formats. example, matrix operations can applied directly AnnData 10x matrix file. many cases bitpacking-compressed formats provide performance/space advantages, required use computations.","code":""}]
