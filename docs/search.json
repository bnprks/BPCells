[{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic tutorial","text":"tutorial, : Load RNA ATAC-seq data 10x multiome experiment Filter high-quality cells RNA PCA + UMAP dimensionality reduction Unbiased clustering Visualize marker genes annotate clusters Call ATAC-seq peaks ATAC PCA + UMAP dimensionality reduction Visualize transcription factor footprints Plot accessibility genome tracks tutorial work--progress, inspired Seurat’s PBMC 3k clustering tutorial.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"install-packages","dir":"Articles","previous_headings":"Setup","what":"Install packages","title":"Basic tutorial","text":"Install cran dependencies: irlba (PCA) uwot (UMAP) RcppHNSW (clustering) igraph (clustering) BiocManager (access bioconductor packages) ggplot2 version <=3.3.5 >=3.4.1 (hexbin broken versions 3.3.6-3.4.0) Bioconductor dependencies: BSgenome.Hsapiens.UCSC.hg38 (TF motif scanning) Github: motifmatchr (TF motif scanning) chromVARmotifs (TF motif database)","code":"install.packages(c(\"irlba\", \"uwot\", \"RcppHNSW\", \"igraph\", \"BiocManager\", \"devtools\", \"ggplot2\")) BiocManager::install(\"BSgenome.Hsapiens.UCSC.hg38\") devtools::install_github(c(\"GreenleafLab/motifmatchr\", \"GreenleafLab/chromVARmotifs\"), repos=BiocManager::repositories()) devtools::install_github(c(\"bnprks/BPCells\"))"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"set-up-analysis-folder","dir":"Articles","previous_headings":"Setup","what":"Set up analysis folder","title":"Basic tutorial","text":"","code":"library(BPCells) suppressPackageStartupMessages({   library(dplyr)   library(patchwork) })  # Substitute your preferred working directory for data_dir data_dir <- file.path(tempdir(), \"pbmc-3k\") dir.create(data_dir, recursive = TRUE, showWarnings = FALSE) setwd(data_dir)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"download-data","dir":"Articles","previous_headings":"Setup","what":"Download data","title":"Basic tutorial","text":"Next, download 3k PBMC dataset 10x Genomics temporary directory. files 500MB large combined","code":"url_base <- \"https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_3k/\" rna_raw_url <- paste0(url_base, \"pbmc_granulocyte_sorted_3k_raw_feature_bc_matrix.h5\") atac_raw_url <- paste0(url_base, \"pbmc_granulocyte_sorted_3k_atac_fragments.tsv.gz\")  # Only download files if we haven't downloaded already if (!file.exists(\"pbmc_3k_10x.h5\")) {   download.file(rna_raw_url, \"pbmc_3k_10x.h5\", mode=\"wb\") } if (!file.exists(\"pbmc_3k_10x.fragments.tsv.gz\")) {   download.file(atac_raw_url, \"pbmc_3k_10x.fragments.tsv.gz\", mode=\"wb\") }"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"data-loading","dir":"Articles","previous_headings":"","what":"Data Loading","title":"Basic tutorial","text":"First, convert raw data inputs 10x format bitpacked compressed format stored binary files disk. BPCells can still read data don’t convert format, certain ATAC-seq functionality run much faster converted data. Convert RNA matrix: Convert ATAC-seq fragments ATAC storage space dropped 468 MB gzipped 10x file 209 MB bitpacked storage. RNA storage space dropped 51.2 MB 10x hdf5 file gzip compression 33.5 MB using bitpacking compression. case, storage space little misleading since 39% bitpacked storage spent gene + cell names. case 10x compressed hdf5 bitpacking compression 4-6x smaller uncompressed sparse matrix format AnnData.","code":"# Check if we already ran import if (!file.exists(\"pbmc_3k_rna_raw\")) {   mat_raw <- open_matrix_10x_hdf5(\"pbmc_3k_10x.h5\", feature_type=\"Gene Expression\") %>%      write_matrix_dir(\"pbmc_3k_rna_raw\") } else {   mat_raw <- open_matrix_dir(\"pbmc_3k_rna_raw\") } mat_raw ## 36601 x 650165 IterableMatrix object with class MatrixDir ##  ## Row names: ENSG00000243485, ENSG00000237613 ... ENSG00000277196 ## Col names: AAACAGCCAAACAACA-1, AAACAGCCAAACATAG-1 ... TTTGTTGGTTTGTTGC-1 ##  ## Data type: uint32_t ## Storage order: column major ##  ## Queued Operations: ## 1. Load compressed matrix from directory /home/ben/dev/github/bnprks/BPCells/vignettes/pbmc-3k-data/pbmc_3k_rna_raw # Check if we already ran import if (!file.exists(\"pbmc_3k_frags\")) {   frags_raw <- open_fragments_10x(\"pbmc_3k_10x.fragments.tsv.gz\") %>%       write_fragments_dir(\"pbmc_3k_frags\") } else {   frags_raw <- open_fragments_dir(\"pbmc_3k_frags\") } frags_raw ## IterableFragments object of class \"FragmentsDir\" ##  ## Cells: 462264 cells with names TTTAGCAAGGTAGCTT-1, GCCTTTGGTTGGTTCT-1 ... ATCACCCTCCATAATG-1 ## Chromosomes: 39 chromosomes with names chr1, chr10 ... KI270713.1 ##  ## Queued Operations: ## 1. Read compressed fragments from directory pbmc_3k_frags"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"rna-seq-filtering","dir":"Articles","previous_headings":"Filter for high-quality cells","what":"RNA-seq filtering","title":"Basic tutorial","text":"use simple minimum read threshold RNA-seq quality. cutoff choose just first knee log-log plot reads vs. barcode rank, separates cells empty droplets.","code":"reads_per_cell <- Matrix::colSums(mat_raw) plot_read_count_knee(reads_per_cell, cutoff = 1e3)"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"download-reference-annotations","dir":"Articles","previous_headings":"Filter for high-quality cells > ATAC-seq filtering","what":"Download reference annotations","title":"Basic tutorial","text":"fetch reference information necessary calculate quality-control statistics. default, fetches latest annotations hg38. Since fetching references involves downloading gtf bed files, provide name directory save files . also allows us skip re-downloading files next time.","code":"genes <- read_gencode_transcripts(   \"./references\",    release=\"42\",    transcript_choice=\"MANE_Select\",   annotation_set = \"basic\",    features=\"transcript\" # Make sure to set this so we don't get exons as well ) head(genes) ## # A tibble: 6 × 13 ##   chr   source feature   start    end score strand frame gene_id gene_…¹ gene_…² ##   <chr> <chr>  <chr>     <dbl>  <int> <chr> <chr>  <chr> <chr>   <chr>   <chr>   ## 1 chr1  HAVANA transcr…  65418  71585 .     +      .     ENSG00… protei… OR4F5   ## 2 chr1  HAVANA transcr… 450739 451678 .     -      .     ENSG00… protei… OR4F29  ## 3 chr1  HAVANA transcr… 685715 686654 .     -      .     ENSG00… protei… OR4F16  ## 4 chr1  HAVANA transcr… 923922 944574 .     +      .     ENSG00… protei… SAMD11  ## 5 chr1  HAVANA transcr… 944202 959256 .     -      .     ENSG00… protei… NOC2L   ## 6 chr1  HAVANA transcr… 960583 965719 .     +      .     ENSG00… protei… KLHL17  ## # … with 2 more variables: transcript_id <chr>, MANE_Select <lgl>, and ## #   abbreviated variable names ¹​gene_type, ²​gene_name blacklist <- read_encode_blacklist(\"./references\", genome=\"hg38\") head(blacklist) ## # A tibble: 6 × 4 ##   chr      start      end reason             ##   <chr>    <dbl>    <dbl> <chr>              ## 1 chr10        0    45700 Low Mappability    ## 2 chr10 38481300 38596500 High Signal Region ## 3 chr10 38782600 38967900 High Signal Region ## 4 chr10 39901300 41712900 High Signal Region ## 5 chr10 41838900 42107300 High Signal Region ## 6 chr10 42279400 42322500 High Signal Region chrom_sizes <- read_ucsc_chrom_sizes(\"./references\", genome=\"hg38\") head(chrom_sizes) ## # A tibble: 6 × 3 ##   chr   start       end ##   <chr> <dbl>     <int> ## 1 chr1      0 248956422 ## 2 chr2      0 242193529 ## 3 chr3      0 198295559 ## 4 chr4      0 190214555 ## 5 chr5      0 181538259 ## 6 chr6      0 170805979"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"calculate-atac-seq-quality-control-metrics","dir":"Articles","previous_headings":"Filter for high-quality cells > ATAC-seq filtering","what":"Calculate ATAC-seq quality-control metrics","title":"Basic tutorial","text":"can calculate several built-quality control metrics barcode, including number fragments TSS enrichment. calculations fully compatible ArchR’s methodology quality control statistics. One key ways identify high-quality cells ATAC-seq data plot number fragments vs. TSS Enrichment. plot puts empty droplets bottom-left quadrant, low-quality/dead cells bottom-right quadrant, high-quality cells top-right quadrant. flow-cytometry perspective, use bottom-left group empty droplets negative control help set cutoffs.  Due thresholding ArchR’s formula applies denominator TSS Enrichment calculation, low-read cells can’t assigned high TSS Enrichment value. plot TSS enrichment without thresholding, following:  Note 200/101 fraction accounts ReadsInTSS drawing 101-bp windows, ReadsFlankingTSS drawing 2x100-bp windows. results low-read droplets measuring high TSS Enrichment, use slightly adjusted cutoffs. can also plot sample-level quality control plots. left, fragment length distribution shows three broad bumps corresponding nucleosome spacing (147bp), smaller wiggles corresponding DNA winding (11.5bp). right, TSS enrichment profile shows strong enrichment signal transcription start sites, well small asymmetrical bump downstream TSS +1 nucleosome.","code":"atac_qc <- qc_scATAC(frags_raw, genes, blacklist) head(atac_qc) ## # A tibble: 6 × 10 ##   cellN…¹ TSSEn…² nFrags subNu…³ monoN…⁴ multi…⁵ Reads…⁶ Reads…⁷ Reads…⁸ Reads…⁹ ##   <chr>     <dbl>  <int>   <int>   <int>   <int>   <dbl>   <dbl>   <dbl>   <dbl> ## 1 TTTAGC…  45.1    16363    8069    5588    2706    2964     130   13820     244 ## 2 GCCTTT…   0.198      3       1       2       0       2       0       6       2 ## 3 AGCCGG…  30.9    33313   15855   11868    5590    3992     256   18665     478 ## 4 TGATTA…  41.9    11908    6103    3817    1988    2158     102   10259     174 ## 5 ATTGAC…  43.9    13075    6932    4141    2002    2530     114   11731     190 ## 6 CGTTAG…  31.5    14874    6833    5405    2636    2244     141   10470     231 ## # … with abbreviated variable names ¹​cellName, ²​TSSEnrichment, ³​subNucleosomal, ## #   ⁴​monoNucleosomal, ⁵​multiNucleosomal, ⁶​ReadsInTSS, ⁷​ReadsFlankingTSS, ## #   ⁸​ReadsInPromoter, ⁹​ReadsInBlacklist plot_tss_scatter(atac_qc, min_frags=1000, min_tss=10) atac_qc %>%   dplyr::mutate(TSSEnrichment=ReadsInTSS/pmax(1,ReadsFlankingTSS) * 200/101) %>%   plot_tss_scatter(min_frags=2000, min_tss=20) +   ggplot2::labs(title=\"Raw TSS Enrichment\") plot_fragment_length(frags_raw) + plot_tss_profile(frags_raw, genes)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"select-high-quality-cells","dir":"Articles","previous_headings":"Filter for high-quality cells","what":"Select high-quality cells","title":"Basic tutorial","text":"take cells pass minimum RNA reads, minimum ATAC reads, minimum TSS Enrichment cutoffs. subset RNA ATAC input data just cells passing filter. RNA, subset genes least 3 reads. subset operation also puts cells matching order simplifies cross-modality calculations later .","code":"pass_atac <- atac_qc %>%     dplyr::filter(nFrags > 1000, TSSEnrichment > 10) %>%     dplyr::pull(cellName) pass_rna <- colnames(mat_raw)[Matrix::colSums(mat_raw) > 1e3] keeper_cells <- intersect(pass_atac, pass_rna) frags <- frags_raw %>% select_cells(keeper_cells)  keeper_genes <- Matrix::rowSums(mat_raw) > 3 mat <- mat_raw[keeper_genes,keeper_cells]"},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"matrix-normalization","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Matrix normalization","title":"Basic tutorial","text":", walk Seurat-style matrix normalization calculations manually, though soon helper functions simplify process. First log-normalize, roughly equivalent Seurat::NormalizeData Next pick variable genes: look normalized matrix object, can see quite math operations queued performed --fly needed. improve performance downstream PCA, save sparse normalized matrix temporary file just prior normalizations make matrix dense. saves storage space preventing us re-calculate queued operations several-hundred times PCA optimization iterations. case, matrix quite small ’ll just store memory. larger example swap write_matrix_dir(tempfile(\"mat\")) Finally, perform z-score normalization makes matrix dense.","code":"# Normalize by reads-per-cell mat <- multiply_cols(mat, 1/Matrix::colSums(mat))  # Log normalization mat <- log1p(mat * 10000) # Log normalization stats <- matrix_stats(mat, row_stats=\"variance\")  # To keep the example small, we'll do a very naive variable gene selection variable_genes <- order(stats$row_stats[\"variance\",], decreasing=TRUE) %>%    head(1000) %>%    sort()  mat_norm <- mat[variable_genes,] mat_norm ## 1000 x 2600 IterableMatrix object with class TransformLog1p ##  ## Row names: ENSG00000078369, ENSG00000116251 ... ENSG00000212907 ## Col names: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ##  ## Data type: double ## Storage order: column major ##  ## Queued Operations: ## 1. Load compressed matrix from directory /home/ben/dev/github/bnprks/BPCells/vignettes/pbmc-3k-data/pbmc_3k_rna_raw ## 2. Select rows: 87, 171 ... 36568 and cols: 640783, 89020 ... 504383 ## 3. Convert type from uint32_t to double ## 4. Scale by 1e+04 ## 5. Scale columns by 0.000221, 0.000118 ... 0.000177 ## 6. Transform log1p mat_norm <- mat_norm %>% write_matrix_memory(compress=FALSE) gene_means <- stats$row_stats[\"mean\",variable_genes] gene_vars <- stats$row_stats[\"variance\", variable_genes] mat_norm <- (mat_norm - gene_means) / gene_vars"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"pca-and-umap","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"PCA and UMAP","title":"Basic tutorial","text":"PCA can performed standard solver like irlba. Next calculate UMAP coordinates","code":"svd <- irlba::irlba(mat_norm, nv=50) pca <- multiply_cols(svd$v, svd$d)  cat(sprintf(\"PCA dimensions: %s\\n\", toString(dim(pca)))) pca[1:4,1:3] ## PCA dimensions: 2600, 50 ##           [,1]       [,2]       [,3] ## [1,] 15.167732  0.8951488  2.3650024 ## [2,]  6.599774  7.2484738 -4.4369183 ## [3,] 14.621697 -1.1929478  0.6439662 ## [4,]  8.142875  1.0977225  2.5066238 set.seed(12341512) umap <- uwot::umap(pca) umap[1:4,] ##          [,1]      [,2] ## [1,] 9.478912 2.8883930 ## [2,] 8.899133 0.6127033 ## [3,] 9.270820 2.8209666 ## [4,] 8.049050 0.3024858"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"clustering","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Clustering","title":"Basic tutorial","text":"perform quick clustering follows, based PCA coordinates. now can visualize clusters UMAP:","code":"clusts <- knn_hnsw(pca, ef=500) %>% # Find approximate nearest neighbors   knn_to_snn_graph() %>% # Convert to a SNN graph   cluster_graph_louvain() # Perform graph-based clustering cat(sprintf(\"Clusts length: %s\\n\", length(clusts))) clusts[1:10] ## Clusts length: 2600 ##  [1] 1 2 1 2 2 3 2 2 4 5 ## Levels: 1 2 3 4 5 6 7 8 9 10 11 12 plot_embedding(clusts, umap)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"visualize-marker-genes","dir":"Articles","previous_headings":"RNA Normalization, PCA and UMAP","what":"Visualize marker genes","title":"Basic tutorial","text":"annotate clusters cell types, can plot several marker genes overlaid onto UMAP.  observe cluster-specific enrichment B-cell marker MS4A1, T-cell marker CD3E, Monocyte marker LYZ. allows us make broad cell type groupings follows:  can visualize marker genes cluster using dot plot. typical situations, known marker genes clear, others less specific.","code":"plot_embedding(   source = mat,   umap,   features = c(\"MS4A1\", \"GNLY\", \"CD3E\",                 \"CD14\", \"FCER1A\", \"FCGR3A\",                 \"LYZ\", \"CD4\",\"CD8\"), ) cluster_annotations <- c(   \"1\" = \"T\",   \"2\" = \"CD8 T\",   \"3\" = \"B\",   \"4\" = \"T\",   \"5\" = \"NK\",   \"6\" = \"Mono\",   \"7\" = \"Mono\",   \"8\" = \"Mono\",   \"9\" = \"T\",   \"10\" = \"DC\",   \"11\" = \"Mono\",   \"12\" = \"DC\" ) cell_types <- cluster_annotations[clusts] plot_embedding(cell_types, umap) plot_dot(   mat,    c(\"MS4A1\", \"GNLY\", \"CD3E\",      \"CD14\", \"FCER1A\", \"FCGR3A\",      \"LYZ\", \"CD4\", \"CD8\"),    cell_types )"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"atac-normalization-pca-and-umap","dir":"Articles","previous_headings":"","what":"ATAC Normalization, PCA and UMAP","title":"Basic tutorial","text":"start tile-based peak calling, tests pre-determined overlapping tile positions significant enrichment ATAC-seq signal genome-wide background cell type independently. faster using real peak-caller like MACS, though default parameters peaks always 200bp wide positioning resolution approximately +/- 30bp. Next compute peak matrix counting many ATAC-seq insertions overlap peak. save memory rather saving disk since dataset quite small. Next calculate TF-IDF normalization. formula TF-IDF variant Stuart et al. Looking LSI matrix, can see power BPCells performing matrix operations --fly: LSI normalization fact calculated time fragment overlap calculations read matrix. don’t need store intermediate matrices calculations, even peak matrix can re-calculated --fly based fragments object saved disk. Just like RNA, save matrix running PCA. larger dataset, save disk rather memory. Finally, z-score normalization LSI matrix run PCA. standard practice running PCA, commonly done ATAC-seq datasets due fact greatly increases memory usage. methods, 1st PC highly correlated number reads per cell, thrown empirical correction. Luckily, BPCells can avoid memory usage can just normalize data run PCA usual Next calculate UMAP cluster, just like RNA can plot ATAC-seq embedding ATAC-derived clusters, easily compare RNA-derived clusters earlier.  BPCells works based order cells matrix fragment object. Since ATAC PCA rows cell order RNA clusters, datasets combine additional work. skip normalization, first observe get high correlation first PC reads-per-cell peak matrix  terms actual PCA results, can see cell embeddings mostly 1--1 correspondence across first 6 PCs, though later PCs start diverge. first PC raw TF-IDF corresponds mostly read depth, signal spread across 2 PCs z-score normalized variant.  look loading peak PCA, see similar result.  Finally, UMAP generated exclude first PC fairly similar, though notable difference positioning cluster 18 (subset dendritic cells)","code":"frags_filter_blacklist <- frags %>%   select_regions(blacklist, invert_selection = TRUE) peaks <- call_peaks_tile(frags_filter_blacklist, chrom_sizes, cell_groups=cell_types,                            effective_genome_size = 2.8e9) head(peaks) ## # A tibble: 6 × 7 ##   chr       start       end group     p_val     q_val enrichment ##   <fct>     <int>     <int> <chr>     <dbl>     <dbl>      <dbl> ## 1 chr1   16644600  16644800 NK    1.63e-190 2.52e-183      1017. ## 2 chr19  18281733  18281933 Mono  0         0               518. ## 3 chr17  81860866  81861066 DC    7.87e- 63 1.21e- 55       552. ## 4 chr1    1724333   1724533 Mono  0         0               511. ## 5 chr1  228140000 228140200 NK    2.24e-158 1.73e-151       845. ## 6 chr8   30083133  30083333 CD8 T 8.02e-225 1.24e-217       750. top_peaks <- head(peaks, 50000) top_peaks <- top_peaks[order_ranges(top_peaks, chrNames(frags)),] peak_mat <- peak_matrix(frags, top_peaks, mode=\"insertions\") mat_lsi <- peak_mat %>%   multiply_cols(1 / Matrix::colSums(peak_mat)) %>%   multiply_rows(1 / Matrix::rowMeans(peak_mat))  mat_lsi <- log1p(10000 * mat_lsi) mat_lsi ## 50000 x 2600 IterableMatrix object with class TransformLog1p ##  ## Row names: chr1:817200-817400, chr1:827466-827666 ... chrX:155881200-155881400 ## Col names: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ##  ## Data type: double ## Storage order: row major ##  ## Queued Operations: ## 1. Read compressed fragments from directory pbmc_3k_frags ## 2. Select 2600 cells by name: TTTAGCAAGGTAGCTT-1, AGCCGGTTCCGGAACC-1 ... TACTAAGTCCAATAGC-1 ## 3. Calculate 2600 peaks over 50000 ranges: chr1:817201-817400 ... chrX:155881201-155881400 ## 4. Convert type from uint32_t to double ## 5. Scale by 1e+04 ## 6. Scale columns by 6.72e-05, 5.18e-05 ... 0.000807 ## 7. Scale rows by 11.1, 2.78 ... 3.77 ## 8. Transform log1p mat_lsi <- write_matrix_memory(mat_lsi, compress=FALSE) # Compute colMean and colVariance in one pass cell_peak_stats <- matrix_stats(mat_lsi, col_stats=\"variance\")$col_stats cell_means <- cell_peak_stats[\"mean\",] cell_vars <- cell_peak_stats[\"variance\",] mat_lsi_norm <- mat_lsi %>%   add_cols(-cell_means) %>%   multiply_cols(1 / cell_vars) svd_atac <- irlba::irlba(mat_lsi_norm, nv=10) pca_atac <- multiply_cols(svd_atac$v, svd_atac$d) pca_atac[1:4,1:4] ##            [,1]       [,2]       [,3]      [,4] ## [1,] -103.80520   1.365424   1.707384 -21.38388 ## [2,]  -44.93022 -28.991700 -12.600363  10.43552 ## [3,]  -90.55621   3.551652   3.406559 -13.05907 ## [4,]  -90.57636  -6.205737   7.265390  15.64226 set.seed(12341512) umap_atac <- uwot::umap(pca_atac) umap_atac[1:4,] ##           [,1]        [,2] ## [1,]  7.366673  3.49072457 ## [2,] -7.177320  0.36089159 ## [3,]  7.769831  8.12516213 ## [4,]  8.370543 -0.05077623 clusts_atac <- knn_hnsw(pca_atac, ef=500) %>% # Find approximate nearest neighbors   knn_to_snn_graph() %>% # Convert to a SNN graph   cluster_graph_louvain() # Perform graph-based clustering plot_embedding(clusts_atac, umap_atac, colors_discrete = discrete_palette(\"ironMan\")) +   ggplot2::guides(color=\"none\") +    plot_embedding(cell_types, umap_atac) svd_atac_no_norm <- irlba::irlba(mat_lsi, nv=10) pca_atac_no_norm <- multiply_cols(svd_atac_no_norm$v, svd_atac$d) cor_to_depth <- dplyr::bind_rows(   tibble::tibble(     method=\"z-score normalize\",     abs_cor_to_depth = as.numeric(abs(cor(Matrix::colSums(mat_lsi), pca_atac))),     PC=seq_along(abs_cor_to_depth)   ),   tibble::tibble(     method=\"raw TF-IDF\",     abs_cor_to_depth = as.numeric(abs(cor(Matrix::colSums(mat_lsi), pca_atac_no_norm))),     PC=seq_along(abs_cor_to_depth)   ) ) ggplot2::ggplot(cor_to_depth, ggplot2::aes(PC, abs_cor_to_depth, color=method)) +   ggplot2::geom_point() +   ggplot2::theme_bw() +   ggplot2::labs(title=\"Correlation to of PCs to read depth\") cor_between_embeddings <- tidyr::expand_grid(   pca_atac_no_norm = seq_len(ncol(pca_atac_no_norm)),   pca_atac=seq_len(ncol(pca_atac)) ) %>% mutate(   cor = as.numeric(abs(cor(.env$pca_atac, .env$pca_atac_no_norm))) )  ggplot2::ggplot(cor_between_embeddings, ggplot2::aes(pca_atac, pca_atac_no_norm, fill=abs(cor))) +   ggplot2::geom_tile() +   ggplot2::geom_text(mapping=ggplot2::aes(label=sprintf(\"%.2f\", cor))) +   ggplot2::scale_x_continuous(breaks=1:10) +   ggplot2::scale_y_continuous(breaks=1:10) +   ggplot2::theme_classic() +   ggplot2::labs(title=\"Correlation between cell embeddings\",                  x=\"z-score normalize PCs\",                 y =\"raw TF-IDF PCs\") cor_between_loadings <- tidyr::expand_grid(   pca_atac_no_norm = seq_len(ncol(svd_atac_no_norm$u)),   pca_atac=seq_len(ncol(svd_atac$u)) ) %>% mutate(   cor = as.numeric(abs(cor(.env$svd_atac$u, .env$svd_atac_no_norm$u))) )  ggplot2::ggplot(cor_between_loadings, ggplot2::aes(pca_atac, pca_atac_no_norm, fill=abs(cor))) +   ggplot2::geom_tile() +   ggplot2::geom_text(mapping=ggplot2::aes(label=sprintf(\"%.2f\", cor))) +   ggplot2::scale_x_continuous(breaks=1:10) +   ggplot2::scale_y_continuous(breaks=1:10) +   ggplot2::theme_classic() +   ggplot2::labs(title=\"Correlation between peak loadings\",                 x=\"z-score normalize PCs\",                 y =\"raw TF-IDF PCs\") set.seed(12341512) umap_atac_no_norm <- uwot::umap(pca_atac_no_norm[,-1]) plot_embedding(clusts_atac, umap_atac_no_norm, colors_discrete = discrete_palette(\"ironMan\")) +   ggplot2::guides(color=\"none\") +    plot_embedding(cell_types, umap_atac_no_norm)"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"motif-footprinting","dir":"Articles","previous_headings":"","what":"Motif footprinting","title":"Basic tutorial","text":"motif footprinting, first need find instances motifs--interest peaks Next, can use motif positions plot aggregate accessibility surrounding TF binding sites across cell types proxy TF activity. ’re able see enrichment accessibility neighboring sites myeloid transcription factor DC Monocyte cells. Transcription factor binding (generally) mutually-exclusive nucleosome occupancy, transcription factor bound creates accessibility flanking regions. squiggly bit center due Tn5 insertion bias motif .  can also use patchwork library show multiple plots grid, highlighting cell-type-specific factors well general factors like CTCF.","code":"suppressPackageStartupMessages({   library(GenomicRanges)   library(Biostrings) }) peaks_sorted <- dplyr::arrange(peaks, chr, start) peaks_gr <- dplyr::mutate(peaks_sorted, start = start + 1) %>% as(\"GenomicRanges\") selected_motifs <- c(   \"CEBPA\" = \"ENSG00000245848_LINE568_CEBPA_D_N4\",   \"EOMES\" = \"ENSG00000163508_LINE3544_EOMES_D_N1\",    \"SPI1\" = \"ENSG00000066336_LINE1813_SPI1_D_N5\",   \"CTCF\" = \"ENSG00000102974_LINE747_CTCF_D_N67\" ) suppressWarnings({   motif_positions <- motifmatchr::matchMotifs(       chromVARmotifs::human_pwms_v2[selected_motifs],        peaks_gr, genome=\"hg38\", out=\"positions\") }) names(motif_positions) <- names(selected_motifs) motif_positions ## GRangesList object of length 4: ## $CEBPA ## GRanges object with 13979 ranges and 1 metadata column: ##           seqnames              ranges strand |     score ##              <Rle>           <IRanges>  <Rle> | <numeric> ##       [1]     chr1     1060191-1060200      + |   7.24916 ##       [2]     chr1     1398356-1398365      - |   7.31987 ##       [3]     chr1     1408228-1408237      - |   7.91988 ##       [4]     chr1     1470604-1470613      + |   7.26088 ##       [5]     chr1     1614370-1614379      - |   7.33086 ##       ...      ...                 ...    ... .       ... ##   [13975]     chrX 154247973-154247982      + |   7.91988 ##   [13976]     chrX 154377819-154377828      - |   7.91988 ##   [13977]     chrX 154497506-154497515      + |   8.62515 ##   [13978]     chrX 154734157-154734166      + |   7.33807 ##   [13979]     chrX 155242494-155242503      - |   7.24431 ##   ------- ##   seqinfo: 39 sequences from an unspecified genome; no seqlengths ##  ## ... ## <3 more elements> plot_tf_footprint(   frags,   motif_positions$CEBPA,   cell_groups = cell_types,   flank = 250,   smooth = 2 ) +   ggplot2::labs(title=\"CEBPA\") footprinting_plots <- list() for (motif in names(selected_motifs)) {   footprinting_plots[[motif]] <- plot_tf_footprint(     frags,      motif_positions[[motif]],      cell_groups = cell_types,      flank=250,     smooth=2) +     ggplot2::labs(title=motif, color=\"Cluster\") } patchwork::wrap_plots(footprinting_plots, guides=\"collect\")"},{"path":"https://bnprks.github.io/BPCells/articles/pbmc3k.html","id":"genome-accessibility-tracks","dir":"Articles","previous_headings":"","what":"Genome accessibility tracks","title":"Basic tutorial","text":"plot genome accessibility tracks, need select genome region view. BPCells provides helper function find genome regions centered around gene. normalizing tracks, need provide total number reads cell type. can substituted total reads peaks metrics desired. can create first component track plot plotting genome tracks . can see small peak center mainly present B cells (top row), unclear sits relative B-cell marker CD19.  much useful gene annotation track added . ’ll get set canonical transcripts (one per gene) Gencode can make annotation track  Finally, can put elements together make combined trackplot. Now see small peak just upstream CD19 gene.","code":"region <- gene_region(genes, \"CD19\", extend_bp = 1e5) region ## $chr ## [1] \"chr16\" ##  ## $start ## [1] 28831970 ##  ## $end ## [1] 29039342 read_counts <- atac_qc$nFrags[   match(cellNames(frags), atac_qc$cellName) ] bulk_plot <- trackplot_bulk(   frags,   region = region,    groups=cell_types,   read_counts,   bins=500 ) bulk_plot transcripts <- read_gencode_transcripts(\"./references\", release=\"42\") head(transcripts) ## # A tibble: 6 × 13 ##   chr   source feature   start    end score strand frame gene_id gene_…¹ gene_…² ##   <chr> <chr>  <chr>     <dbl>  <int> <chr> <chr>  <chr> <chr>   <chr>   <chr>   ## 1 chr1  HAVANA transcr…  65418  71585 .     +      .     ENSG00… protei… OR4F5   ## 2 chr1  HAVANA exon      65418  65433 .     +      .     ENSG00… protei… OR4F5   ## 3 chr1  HAVANA exon      65519  65573 .     +      .     ENSG00… protei… OR4F5   ## 4 chr1  HAVANA exon      69036  71585 .     +      .     ENSG00… protei… OR4F5   ## 5 chr1  HAVANA transcr… 450739 451678 .     -      .     ENSG00… protei… OR4F29  ## 6 chr1  HAVANA exon     450739 451678 .     -      .     ENSG00… protei… OR4F29  ## # … with 2 more variables: transcript_id <chr>, MANE_Select <lgl>, and ## #   abbreviated variable names ¹​gene_type, ²​gene_name gene_plot <- trackplot_gene(transcripts, region) gene_plot draw_trackplot_grid(   bulk_plot,   gene_plot,   labels = list(\"Cell Types\", \"Genes\") )"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"rna-seq-normalization-pca","dir":"Articles > Web-only","previous_headings":"","what":"RNA-seq normalization + PCA","title":"Performance Benchmarks","text":"BPCells can perform operations streaming disk, able use dramatically less memory operations read matrix values. chunking strategy similar tools like DelayedArray. extensively optimized C++ code avoid slowdowns commonly caused using disk-backed computations. benchmark , show time memory perform basic workflow data import, normalization, variable gene selection, PCA. reproduce PCA results existing tools within numerical precision, starting raw counts1.  Note Seurat plot crashes 1.3M cell dataset due R sparse matrices supporting roughly 2 billion non-zero entries matrix. utilizing Seurat v5’s BPCells integration, possible perform analyses million cell datasets without downsampling.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"counts-matrices-rna-or-atac","dir":"Articles > Web-only","previous_headings":"Bitpacking compression","what":"Counts matrices (RNA or ATAC)","title":"Performance Benchmarks","text":"Single cell counts matrices stored sparse matrices. traditional formats like AnnData 10x hdf5 feature matrices, inherent tradeoff storage size speed loading. Gzip-compressed files small, slow read. BPCells uses bitpacking compression provide 4-6x smaller storage counts matrices compared uncompressed binary format (e.g. AnnData’s default h5ad settings2). single thread can load matrix data faster reading uncompressed data many cases, due smaller data size extremely fast decompression3. Benchmark storing + loading 1.3M cell RNA-seq experiment 10x Genomics.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"fragment-alignments-atac","dir":"Articles > Web-only","previous_headings":"Bitpacking compression","what":"Fragment alignments (ATAC)","title":"Performance Benchmarks","text":"Single cell ATAC-seq data stored lists fragment alignments, including chromosome, start+end coordinates, cell ID. storage space BPCells bitpacked format 2x smaller 10x fragments.tsv.gz file. storage format includes lightweight genome-position index enable fast loading data selected genome location. BPCells can decompress 70 million fragments per second single core, compared 5 million fragments per second 10x fragments.tsv.gz file (14x faster). Compared ArchR arrow files, BPCells also 2x smaller ~10x faster import times fragments.tsv.gz files.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/benchmarks.html","id":"atac-seq-overlap-calculations","dir":"Articles > Web-only","previous_headings":"","what":"ATAC-seq overlap calculations","title":"Performance Benchmarks","text":"BPCells stores fragments genome-indexed format also enables fast seeking genome location. helps visualization selected genomic loci, well fast calculations cell x peak matrices. often necessary re-quantify cell x peak matrices fragments comparing datasets different original peak calls. implementation 40x faster ArchR calculating overlaps 100k peaks across genome, 500x faster calculating overlaps just 10 peaks. due fact BPCells fragments sorted genome coordinate, whereas arrow files sort cell genome coordinate.  peak matrix overlap calculation runs rate 25 million overlapping fragments per second, fast enough bottleneck /O speed rather computation reading 250MB/s hard drive bitpacking compression available reduce /O bandwidth.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"matrix-logical-storage-layout","dir":"Articles > Web-only","previous_headings":"","what":"Matrix Logical Storage Layout","title":"Matrix Storage Format","text":"data storage, use storage abstraction named data arrays, stored e.g. single group hdf5 directory files. matrix format compressed sparse column/row (CSC/CSR) format following data arrays: interpretation array follows: val - Values non-zero entries increasing order (column, row) position non-zero value. index - index[] provides 0-based row index value found val[] (column index row-major storage order) idxptr - indexes idx val entries column j can found idxptr[j] idxptr[j+1] - 1 , inclusive. (row j row-major storage order) shape - number rows matrix, followed number columns row_names - Names row matrix (optional) col_names - Names column matrix (optional) storage_order- col compressed-sparse-column, row compressed-sparse-row Bitpacked compressed matrices consist following modifications: val: unsigned 32-bit integers, replace val val_data, val_idx, val_idx_offsets corresponding BP-128m1 encoding described . total number values already stored last value idxptr. 32-bit 64-bit floats val remains unchanged. index: replace index array BP-128d1z encoded data arrays index_data, index_idx, index_idx_offsets, index_starts matrix stored single directory, HDF5 group, R S4 object. storage format matrix encoded version string. current version string format [compression]-[datatype]-matrix-v2, [compression] can either packed unpacked, [datatype] can one uint, float, double corresponding 32-bit unsigned integer, 32-bit float, 64-bit double respectively. v1 formats, difference idxptr type uint32.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bitpacking-formats","dir":"Articles > Web-only","previous_headings":"","what":"Bitpacking formats","title":"Matrix Storage Format","text":"bitpacked formats based formats described paper Lemire Boytsov.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128","title":"Matrix Storage Format","text":"vanilla BP-128 format stored 3 arrays follows: data - stream bitpacked data, represented 32-bit integers interleaved bit layout shown Lemire Boytsov figure 6. chunk 128 32-bit input integers \\(B\\) bits per integer stored using \\(4B\\) 32-bit integers holding bitpacked data. idx - list 32-bit integers, encoded data integers index 128*128*+ 127 can found data index idx[] index idx[+1]-1. lists \\(2^{32}\\) (4 billion) entries greater, idx stores index modulo \\(2^{32}\\) idx_offsets - list 64-bit integers, values idx indices idx_offsets[] idx_offsets[+1]-1 *(2^32) added .","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128m1","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128m1","title":"Matrix Storage Format","text":"BP-128, 1 subtracted value prior compression","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128d1","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128d1","title":"Matrix Storage Format","text":"Equivalent BP-128* algorithm Lemire Boytsov integers difference encoded prior bitpacking. best lists sorted integers. data - Encoding vanilla BP-128, difference encoding prior bitpacking: \\(x_{0}^{\\prime}=0\\), \\(x_{1}^{\\prime}=x_{1}-x_{0}\\), \\(x_{2}^{\\prime}=x_{2}-x_{1}\\), …, \\(x_{127}^{\\prime}=x_{127}-x_{126}\\) idx, idx_offsets - identical BP-128 starts - list 32-bit integers, starts[] decoded value integer index 128*","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"bp-128d1z","dir":"Articles > Web-only","previous_headings":"Bitpacking formats","what":"BP-128d1z","title":"Matrix Storage Format","text":"Similar BP128d1 zigzag encoding applied difference encoding. best lists close fully sorted runs integers. data - Encoding BP-128d1, difference encoding bitpacking, results zigzag encoded, \\(zigzag(x)=2x\\) \\(x\\geq0\\), \\(zigzag(x)=-2x-1\\) \\(x<0\\). idx, idx_offsets - identical BP-128 starts - identical BP128-d1 core bitpacking code can found src/bitpacking/bp128.cpp github repository.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"physical-storage-layout","dir":"Articles > Web-only","previous_headings":"","what":"Physical storage layout","title":"Matrix Storage Format","text":"abstraction named data arrays can realized different formats. three currently supported BPCells :","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"directory-of-files-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"Directory of files format:","title":"Matrix Storage Format","text":"array numbers stored single file 8-byte header, followed data values little-endian binary format. Unsigned integers encoded according standard little-endian representation, 32-bit 64-bit floating point numbers IEEE-754 format. Header values 8-byte ASCII text follows: unsigned 32-bit integer UINT32v1, unsigned 64-bit integer UINT64v1, 32-bit float FLOATSv1, 64-bit float DOUBLEv1. Arrays strings stored ASCII text one array value per line header. version string stored file named version containing version string followed newline.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"hdf5-file-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"Hdf5 file format:","title":"Matrix Storage Format","text":"Arrays numbers stored HDF5 datasets using built-HDF5 encoding format. Arrays strings stored HDF5 variable length string datasets. version string stored version attribute HDF5 group","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/bitpacking-format.html","id":"r-object-format","dir":"Articles > Web-only","previous_headings":"Physical storage layout","what":"R object format:","title":"Matrix Storage Format","text":"Strings stored native R character arrays. Unsigned integers 32-bit floats stored native R integer arrays bitcasting R signed integers required data types. 64-bit floats stored native R numeric arrays. 64-bit integers stored doubles R numeric arrays. reduces highest representable value \\(2^{64}-1\\) \\(2^{53}-1\\) (9 quadrillion), expect pose practical problems. Named collections arrays stored R lists (writing) S4 objects (reading). version string stored string vector named version length 1.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"operating-principles","dir":"Articles > Web-only","previous_headings":"","what":"Operating Principles","title":"How BPCells works","text":"Two key principles understand using BPCells operations streaming lazy. Streaming means minimal amount data stored memory computation happening. almost memory used storing intermediate results. Hence, can compute operations large matrices without ever loading fully memory. Lazy means real work performed matrix fragment objects result needs returned R object written disk. helps support streaming computation, since otherwise forced compute intermediate results use additional memory.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"basic-usage","dir":"Articles > Web-only","previous_headings":"Operating Principles","what":"Basic usage","title":"How BPCells works","text":"begin basic example loading ATAC fragments 10x fragments file, reading peak set bed file, calculating cell x peak matrix. bitpacked compressed fragment file half size 10x file, much faster read.","code":"library(\"BPCells\")  # File reading is lazy, so this is instantaneous fragments <- open_fragments_10x(\"atac_fragments.tsv.gz\")  # This is when we actually read the file, should take 1-2 minutes to scan # since we bottleneck on gzip decompression. packed_fragments <- write_fragments_dir(fragments, \"pbmc-3k-fragments\") # Later, we can re-open these fragments packed_fragments <- open_fragments_dir(\"pbmc-3k_fragments\")  peaks <- read_bed(\"peaks.bed\")  # This is fast because the peak matrix calculation is lazy. # It will be computed on-the-fly when we actually need results from it. peak_matrix <- peak_matrix(packed_fragments, peaks)  # Here is where the peak matrix calculation happens. Runs over 10-times # faster than ArchR, which utilizes IRanges to perform overlap calculations. R_matrix <- as(peak_matrix, \"dgCMatrix\")"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/how-it-works.html","id":"streaming-operations","dir":"Articles > Web-only","previous_headings":"Operating Principles","what":"Streaming operations","title":"How BPCells works","text":"lazy, stream-oriented design means can calculate complicated transformations single pass. faster memory-efficient calculating several intermediate results sequential manner. example, perform following pipeline: 1. Exclude fragments non-standard chromosomes 2. Subset cells 3. Add Tn5 offset 4. Calculate peak matrix 5. Calculate mean-accessibility per peak done using e.g. GRanges sparse matrices, need 3 passes fragments saving intermediate results, 2 passes peak matrix. BPCell’s streaming operations, can done directly fragments single pass, memory usage limited bytes per cell iterating peak matrix returning colMeans. Note knew cell names ahead time, even perform operation directly orignal 10x fragments without ever saving fragments memory. fairly slow 10x fragment files slow decompress, ’s recommended convert BPCells format.","code":"# Here I make use of the new pipe operator |> for better readability  # We'll subset to just the standard chromosomes standard_chr <- which(   stringr::str_detect(chrNames(packed_fragments), \"^chr[0-9XY]+$\") )  # Pick a random subset of 100 cells to consider set.seed(1337) keeper_cells <- sample(cellNames(packed_fragments), 100)  # Run the pipeline, and save the average accessibility per peak peak_accessibility <- packed_fragments |>   select_chromosomes(standard_chr) |>   select_cells(keeper_cells) |>   shift_fragments(shift_start=4, shift_end=-5) |>   peak_matrix(peaks) |>   colMeans()"},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"normalizations-and-pca","dir":"Articles > Web-only","previous_headings":"","what":"Normalizations and PCA","title":"Efficiency tips","text":"Avoid dense matrices whenever possible. Put normalizations preserve sparsity (0 values stay 0) normalizations break sparsity (e.g. adding values row/column). typical RNA-seq matrix <5% non-zero entries, code operate 20x entries dense matrix. operations, recommend using lazy evaluation avoid creating intermediate matrices. one common exception rule running PCA. PCA requires looping matrix several hundred times, often faster write matrix disk just PCA rather recalculating entries PCA iteration. storage efficiency, keep sparsity-breaking normalizations delayed, store sparse normalizations temporary location write_matrix_dir() apply sparsity-breaking normalizations Adding values rows/columns matrix little overhead PCA translates pre post processing step mat-vec multiply iteration. sparsity-breaking operation, adding vector matrix causes operations become expensive, however.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"storage-order","dir":"Articles > Web-only","previous_headings":"","what":"Storage order","title":"Efficiency tips","text":"Marker features can computed matrix indexed gene/feature. Sparse matrix multiplication can performed matrices storage order Sparse matrix multiplication performance can change dramatically depending storage order relative matrix size/sparsity. column-major matrices, left matrix fast load contain delayed operations, right matrix can slow load contain many delayed operations. row-major matrices left/right preferences reversed. can check storage order matrix printing R terminal calling t() function, BPCells just flips boolean flag whether matrix row-major column-major. affect underlying storage order. adjust underlying storage order, call transpose_storage_order(). slower operation, requires writing new copy data disk.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-efficiency.html","id":"other-tips","dir":"Articles > Web-only","previous_headings":"","what":"Other tips","title":"Efficiency tips","text":"Use single call matrix_stats() calculate mean + variance single pass matrix possible. See function reference details. ATAC-seq data, can calculate variable features tile matrix without ever saving disk. allows subset variable tiles create peak matrix just variable tiles space savings.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosophy.html","id":"programming-philosopy","dir":"Articles > Web-only","previous_headings":"","what":"Programming philosopy","title":"Programming Philosophy","text":"BPCells operates according somewhat different programming philosophy tools. particular: modify input data files, instead preferring write copy new location needed. Analysis code runs quickly raw counts provides clear reproducibility data provenance BPCells generally avoids storing normalized matrix copies (sometimes referred layers), instead preferring re-calculate normalized values --fly. helps avoid wasteful storage use. BPCells (currently) concept “project” object combines data + metadata complex structure.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosophy.html","id":"working-without-a-project-object","dir":"Articles > Web-only","previous_headings":"Programming philosopy","what":"Working without a project object","title":"Programming Philosophy","text":"Imagine want plot UMAP cells colored cluster. BPCells, way providing: 1, matrix cells x UMAP coordinates 2. vector listing cells belong cluster correspondence cells clusters determined based ordering. rows UMAP matrix order cluster membership vector. keep simple, recommend following approach: See tutorial example, make keeper_cells vector order data consistently according list cell IDs. downstream operations (PCA, clustering, etc.), cell order preserved unless explicitly change . things “just work” keep track per-cell metadata, can helpful make data frame tracking sample IDs, cluster membership, metadata Working without project object provides lot flexibility, since user can easily swap UMAP embeddings, cluster assignments, etc. just providing different variable input. ’s also need “export” metadata since wasn’t import step begin . course, power come additional responsibility keep track metadata. Keeping BPCells flexible power users retaining ease--use newbies ongoing effort, BPCells currently falls side power users","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosopy.html","id":"programming-philosopy","dir":"Articles > Web-only","previous_headings":"","what":"Programming philosopy","title":"Programming Philosophy","text":"BPCells operates according somewhat different programming philosophy tools. particular: modify input data files, instead preferring write copy new location needed. Analysis code runs quickly raw counts provides clear reproducibility data provenance BPCells generally avoids storing normalized matrix copies (sometimes referred layers), instead preferring re-calculate normalized values --fly. helps avoid wasteful storage use. BPCells (currently) concept “project” object combines data + metadata complex structure.","code":""},{"path":"https://bnprks.github.io/BPCells/articles/web-only/programming-philosopy.html","id":"working-without-a-project-object","dir":"Articles > Web-only","previous_headings":"Programming philosopy","what":"Working without a project object","title":"Programming Philosophy","text":"Imagine want plot UMAP cells colored cluster. BPCells, way providing: 1, matrix cells x UMAP coordinates 2. vector listing cells belong cluster correspondence cells clusters determined based ordering. rows UMAP matrix order cluster membership vector. keep simple, recommend following approach: See tutorial example, make keeper_cells vector order data consistently according list cell IDs. downstream operations (PCA, clustering, etc.), cell order preserved unless explicitly change . things “just work” keep track per-cell metadata, can helpful make data frame tracking sample IDs, cluster membership, metadata Working without project object provides lot flexibility, since user can easily swap UMAP embeddings, cluster assignments, etc. just providing different variable input. ’s also need “export” metadata since wasn’t import step begin . course, power come additional responsibility keep track metadata. Keeping BPCells flexible power users retaining ease--use newbies ongoing effort, BPCells currently falls side power users","code":""},{"path":"https://bnprks.github.io/BPCells/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Benjamin Parks. Author, maintainer.","code":""},{"path":"https://bnprks.github.io/BPCells/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parks B (2023). BPCells: Single Cell Counts Matrices PCA. https://bnprks.github.io/BPCells, https://github.com/bnprks/BPCells.","code":"@Manual{,   title = {BPCells: Single Cell Counts Matrices to PCA},   author = {Benjamin Parks},   year = {2023},   note = {https://bnprks.github.io/BPCells, https://github.com/bnprks/BPCells}, }"},{"path":"https://bnprks.github.io/BPCells/index.html","id":"bpcells","dir":"","previous_headings":"","what":"Single Cell Counts Matrices to PCA","title":"Single Cell Counts Matrices to PCA","text":"BPCells package high performance single cell analysis RNA-seq ATAC-seq datasets. can analyze 1.3M cell dataset 2GB RAM around 10 minutes (benchmarks). makes analysis million-cell datasets practical laptop. BPCells provides: Efficient storage single cell datasets via bitpacking compression Fast, disk-backed RNA-seq ATAC-seq data processing powered C++ Downstream analysis marker genes, clustering Interoperability AnnData, 10x datasets, R sparse matrices, GRanges Additionally, BPCells exposes optimized data processing infrastructure use scaling 3rd party single cell tools (e.g. Seurat)","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"learn-more","dir":"","previous_headings":"","what":"Learn more","title":"Single Cell Counts Matrices to PCA","text":"Benchmarks Multiomic analysis example BPCells works Additional articles Function documentation News","code":""},{"path":"https://bnprks.github.io/BPCells/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Single Cell Counts Matrices to PCA","text":"BPCells easiest install directly github: installing, must HDF5 library installed accessible system. HDF5 can installed choice package manager: apt: sudo apt-get install libhdf5-dev yum: sudo yum install hdf5-devel Note: Linux users prefer distro’s package manager (e.g. apt yum) possible, appears give slightly reliable installation experience. also need C/C++ compiler either gcc >=8.0 (>=9.1 recommended), clang >= 7.0 (>= 9.0 recommended). corresponds versions late-2018 newer. Installation troubleshooting – see github issues: Windows (Issue #9) M1 Macs (Issue #6) Macs running MacOS 10.14 (Mojave) older (Issue #3)","code":"remotes::install_github(\"bnprks/BPCells\")"},{"path":"https://bnprks.github.io/BPCells/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Single Cell Counts Matrices to PCA","text":"BPCells open source project, welcome quality contributions. interested contributing experience C++, along Python R, feel free reach ideas like implement . ’m happy provide pointers get started, time permitting. unfamiliar C++ difficult contribute code, detailed bug reports reproducible examples still useful way help . Github issues best forum . maintain single cell analysis package want use BPCells improve scalability, ’m happy provide advice. couple labs try far, promising success. Email best way get touch (look DESCRIPTION file github contact info). Python developers welcome, though full python package likely available mid-summer 2023. AnnData maintainers: love talk putting bitpacking compression AnnData. benchmarks look promising.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"IterableFragments methods — IterableFragments-methods","title":"IterableFragments methods — IterableFragments-methods","text":"Methods IterableFragments objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IterableFragments methods — IterableFragments-methods","text":"","code":"# S4 method for IterableFragments show(object)  cellNames(x)  cellNames(x, ...) <- value  chrNames(x)  chrNames(x, ...) <- value"},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IterableFragments methods — IterableFragments-methods","text":"object IterableFragments object x IterableFragments object value Character vector new names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"IterableFragments methods — IterableFragments-methods","text":"cellNames() Character vector cell names, NULL none known chrNames(): Character vector chromosome names, NULL none known","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IterableFragments methods — IterableFragments-methods","text":"cellNames<- possible replace names, add new names. chrNames<- possible replace names, add new names.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableFragments-methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"IterableFragments methods — IterableFragments-methods","text":"show(IterableFragments): Print IterableFragments cellNames(): Get cell names cellNames(x, ...) <- value: Set cell names chrNames(): Set chromosome names chrNames(x, ...) <- value: Set chromosome names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"IterableMatrix methods — IterableMatrix-methods","title":"IterableMatrix methods — IterableMatrix-methods","text":"Methods IterableMatrix objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IterableMatrix methods — IterableMatrix-methods","text":"","code":"matrix_type(x)  storage_order(x)  # S4 method for IterableMatrix show(object)  # S4 method for IterableMatrix t(x)  # S4 method for IterableMatrix,matrix %*%(x, y)  # S4 method for IterableMatrix rowSums(x)  # S4 method for IterableMatrix colSums(x)  # S4 method for IterableMatrix rowMeans(x)  # S4 method for IterableMatrix colMeans(x)"},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IterableMatrix methods — IterableMatrix-methods","text":"x IterableMatrix object object IterableMatrix object y matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"IterableMatrix methods — IterableMatrix-methods","text":"t() Transposed object x %*% y: dense matrix result rowSums(): vector row sums colSums(): vector col sums rowMeans(): vector row means colMeans(): vector col means","code":""},{"path":"https://bnprks.github.io/BPCells/reference/IterableMatrix-methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"IterableMatrix methods — IterableMatrix-methods","text":"matrix_type(): Get matrix data type (mat_uint32_t, mat_float, mat_double now) storage_order(): Get matrix storage order (\"row\" \"col\") show(IterableMatrix): Display IterableMatrix t(IterableMatrix): Transpose IterableMatrix x %*% y: Multiply dense matrix rowSums(IterableMatrix): Calculate rowSums colSums(IterableMatrix): Calculate colSums rowMeans(IterableMatrix): Calculate rowMeans colMeans(IterableMatrix): Calculate colMeans","code":""},{"path":"https://bnprks.github.io/BPCells/reference/LinearOperator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Represent a sparse matrix-vector product operation — LinearOperator-class","title":"Represent a sparse matrix-vector product operation — LinearOperator-class","text":"LinearOperators perform sparse matrix-vector product operations downstream matrix solvers. avoid repeatedly calling iterate_matrix SVD solver possible efficiency gain","code":""},{"path":"https://bnprks.github.io/BPCells/reference/XPtrList-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This class is used to hold a list of external pointers. — XPtrList-class","title":"This class is used to hold a list of external pointers. — XPtrList-class","text":"class used hold list external pointers.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":null,"dir":"Reference","previous_headings":"","what":"Call peaks from tiles — call_peaks_tile","title":"Call peaks from tiles — call_peaks_tile","text":"Calling peaks pre-set list tiles can much faster using dedicated peak-calling software like macs3. resulting peaks less precise terms exact coordinates, sufficient analyses.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call peaks from tiles — call_peaks_tile","text":"","code":"call_peaks_tile(   fragments,   chromosome_sizes,   cell_groups = rep.int(\"all\", length(cellNames(fragments))),   effective_genome_size = NULL,   peak_width = 200,   peak_tiling = 3,   fdr_cutoff = 0.01,   merge_peaks = c(\"all\", \"group\", \"none\") )"},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call peaks from tiles — call_peaks_tile","text":"fragments IterableFragments object chromosome_sizes genomic-ranges holding start end coordinates chromosome. See read_ucsc_chrom_sizes(). cell_groups Grouping vector one entry per cell fragments, e.g. cluster IDs effective_genome_size (Optional) effective genome size poisson background rate estimation. See (deeptools)https://deeptools.readthedocs.io/en/develop/content/feature/effectiveGenomeSize.html values common genomes. Defaults sum chromosome sizes, overestimates peak significance peak_width Width candidate peaks peak_tiling Number candidate peaks overlapping base genome. E.g. peak_width = 300 peak_tiling = 3 results candidate peaks 300bp spaced 100bp apart fdr_cutoff Adjusted p-value significance cutoff merge_peaks merge significant peaks merge_peaks_iterative() \"\" Merge full set peaks \"group\" Merge peaks within group \"none\" perform merging","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call peaks from tiles — call_peaks_tile","text":"tibble peak calls following columns: chr, start, end: genome coordinates group: group ID peak identified p_val, q_val: Poission p-value BH-corrected p-value enrichment: Enrichment counts peak compared genome-wide background","code":""},{"path":"https://bnprks.github.io/BPCells/reference/call_peaks_tile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call peaks from tiles — call_peaks_tile","text":"Peak calling steps: Estimate genome-wide expected insertions per tile based peak_width, effective_genome_size, per-group read counts Tile genome nonoverlapping tiles size peak_width tile group, calculate p_value based Poisson model Compute adjusted p-values using BH method using total number tiles number hypotheses tested. Repeat steps 2-4 peak_tiling times, evenly spaced offsets merge_peaks 4. Within group, use merge_peaks_iterative() keep significant overlapping candidate peaks 5. merge_peaks == TRUE, perform final round merge_peaks_iterative(), prioritizing peak within-group significance rank","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster an adjacency matrix — cluster_graph_leiden","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"Cluster adjacency matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"","code":"cluster_graph_leiden(snn, resolution = 0.001, seed = 12531, ...)  cluster_graph_louvain(snn, resolution = 1, seed = 12531)  cluster_graph_seurat(snn, resolution = 0.8, ...)"},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"snn Symmetric adjacency matrix (dgCMatrix) output e.g. knn_to_snn_graph resolution Resolution parameter. Higher values result clusters seed Random seed clustering initialization ... Additional arguments underlying clustering function","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"Factor vector containing cluster assignment cell.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster an adjacency matrix — cluster_graph_leiden","text":"cluster_graph_leiden: Leiden graph clustering algorithm igraph::cluster_leiden() cluster_graph_louvain: Louvain graph clustering algorithm igraph::cluster_louvain() cluster_graph_seurat: Seurat's clustering algorithm Seurat::FindClusters()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert grouping vector to sparse matrix — cluster_membership_matrix","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"Converts vector membership IDs sparse matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"","code":"cluster_membership_matrix(groups, group_order = NULL)"},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"groups Vector one entry per cell, specifying cell's group group_order Optional vector listing ordering groups","code":""},{"path":"https://bnprks.github.io/BPCells/reference/cluster_membership_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert grouping vector to sparse matrix — cluster_membership_matrix","text":"cell x group matrix entry 1 cell given group","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect features for plotting — collect_features","title":"Collect features for plotting — collect_features","text":"Helper function data features plot diverse set data sources.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect features for plotting — collect_features","text":"","code":"collect_features(   source,   features = NULL,   gene_mapping = human_gene_mapping,   n = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect features for plotting — collect_features","text":"source Matrix data frame pull features , vector feature values single feature. matrix, features must rows. features Character vector features names plot source vector. gene_mapping optional vector gene name matching match_gene_symbol(). Ignored source data frame. n Internal-use parameter marking number nested calls. used finding name \"source\" input variable caller's perspective","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect features for plotting — collect_features","text":"Data frame one column feature requested","code":""},{"path":"https://bnprks.github.io/BPCells/reference/collect_features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collect features for plotting — collect_features","text":"source data.frame, features drawn columns. source matrix object (IterableMatrix, dgCMatrix, matrix), features drawn rows.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/concat_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","title":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","text":"Helper function rbind/cbind concatenating dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/concat_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for rbind/cbind concatenating dimnames — concat_dimnames","text":"","code":"concat_dimnames(x, y, len_x, len_y, warning_prefix, dim_type)"},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the type of a matrix — convert_matrix_type","title":"Convert the type of a matrix — convert_matrix_type","text":"Convert type matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the type of a matrix — convert_matrix_type","text":"","code":"convert_matrix_type(matrix, type = c(\"uint32_t\", \"double\", \"float\"))"},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the type of a matrix — convert_matrix_type","text":"matrix IterableMatrix object input type One uint32_t (unsigned 32-bit integer), float (32-bit real number), double (64-bit real number)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_matrix_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the type of a matrix — convert_matrix_type","text":"IterableMatrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_to_fragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a Fragments object from an R data frame or GRanges object — convert_to_fragments","title":"Build a Fragments object from an R data frame or GRanges object — convert_to_fragments","text":"Build Fragments object R data frame GRanges object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_to_fragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a Fragments object from an R data frame or GRanges object — convert_to_fragments","text":"","code":"convert_to_fragments(x, zero_based_coords = !is(x, \"GRanges\"))"},{"path":"https://bnprks.github.io/BPCells/reference/convert_to_fragments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a Fragments object from an R data frame or GRanges object — convert_to_fragments","text":"x input GRanges, list data frame. Lists dataframes must chr, start, end, cell_id. GRanges must metadata column cell_id zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see http://genome.ucsc.edu/blog/-ucsc-genome-browser-coordinate-counting-systems/)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/convert_to_fragments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a Fragments object from an R data frame or GRanges object — convert_to_fragments","text":"UnpackedMemFragments object representing given fragments","code":""},{"path":"https://bnprks.github.io/BPCells/reference/discrete_palette.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete color palettes — discrete_palette","title":"Discrete color palettes — discrete_palette","text":"color palettes derived ArchR color palettes, provide large sets distinguishable colors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/discrete_palette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete color palettes — discrete_palette","text":"","code":"discrete_palette(name, n = 1)"},{"path":"https://bnprks.github.io/BPCells/reference/discrete_palette.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete color palettes — discrete_palette","text":"name Name color palette n Minimum number colors needed","code":""},{"path":"https://bnprks.github.io/BPCells/reference/discrete_palette.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete color palettes — discrete_palette","text":"requested number colors large, new palette constructed via interpolation requested palette","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine ggplot track plots into an aligned grid.\nUses patchwork to perform the alignment — draw_trackplot_grid","title":"Combine ggplot track plots into an aligned grid.\nUses patchwork to perform the alignment — draw_trackplot_grid","text":"Combine ggplot track plots aligned grid. Uses patchwork perform alignment","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine ggplot track plots into an aligned grid.\nUses patchwork to perform the alignment — draw_trackplot_grid","text":"","code":"draw_trackplot_grid(   ...,   labels,   title = NULL,   heights = rep(1, length(plots)),   label_width = 0.2,   label_style = list(fontface = \"bold\", size = 4) )"},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine ggplot track plots into an aligned grid.\nUses patchwork to perform the alignment — draw_trackplot_grid","text":"... Plots order top bottom, generally plain ggplots. better accomodate many bulk tracks, patchwork objects contain multiple tracks also accepted. case, plot labels drawn attribute $patchwork$labels present, rather labels argument. labels Text labels display track title Text overarching title plot heights Relative heights component plot. suggested use 1 standard height pseudobulk track. label_width Fraction width used labels relative main track area label_style Arguments pass geom_text adjust label text style","code":""},{"path":"https://bnprks.github.io/BPCells/reference/draw_trackplot_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine ggplot track plots into an aligned grid.\nUses patchwork to perform the alignment — draw_trackplot_grid","text":"plot object aligned genome plots. aligned row text label, y-axis, plot body. relative height row given heights. shared title x-axis put top.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":null,"dir":"Reference","previous_headings":"","what":"Download a file with a custom timeout — ensure_downloaded","title":"Download a file with a custom timeout — ensure_downloaded","text":"Download file custom timeout","code":""},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download a file with a custom timeout — ensure_downloaded","text":"","code":"ensure_downloaded(path, backup_url, timeout)"},{"path":"https://bnprks.github.io/BPCells/reference/ensure_downloaded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download a file with a custom timeout — ensure_downloaded","text":"path Output path write file timeout timeout seconds url download ","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend genome ranges in a strand-aware fashion. — extend_ranges","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"Extend genome ranges strand-aware fashion.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"","code":"extend_ranges(   ranges,   upstream = 0,   downstream = 0,   metadata_cols = c(\"strand\"),   chromosome_sizes = NULL,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"ranges List, GRanges, data.frame object. Must start, end, chr defined. See genomic-ranges upstream Number bases extend range upstream (negative shrink width) downstream Number bases extend range downstream (negative shrink width) metadata_cols Optional list metadata columns require & extract chromosome_sizes (optional) Size chromosomes genomic-ranges object zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/extend_ranges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend genome ranges in a strand-aware fashion. — extend_ranges","text":"Note ranges blocked extending past beginning chromosome (base 0), chromosome_sizes given also blocked extending past end chromosome","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Get footprints around a set of genomic coordinates — footprint","title":"Get footprints around a set of genomic coordinates — footprint","text":"Get footprints around set genomic coordinates","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get footprints around a set of genomic coordinates — footprint","text":"","code":"footprint(   fragments,   ranges,   zero_based_coords = !is(ranges, \"GRanges\"),   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   cell_weights = rlang::rep_along(cell_groups, 1),   flank = 125L,   normalization_width = flank%/%10L )"},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get footprints around a set of genomic coordinates — footprint","text":"fragments IterableFragments object ranges GRanges object positions footprint, list/data frame columns chr, start, & end. list/data frame, must include strand information character vector \"+\"/\"-\", TRUE/FALSE positive/negative strand. \"+\" strand motifs footprint around start coordinate, \"-\" strand motifs footprint around end coordinate zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range cell_groups Character factor assigning group cell, order cellNames(fragments) cell_weights Numeric vector assigning weight factors (e.g. inverse total reads) cell, order cellNames(fragments) flank Number flanking basepairs include either side motif normalization_width Number basepairs upstream + downstream extremes use calculating enrichment","code":""},{"path":"https://bnprks.github.io/BPCells/reference/footprint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get footprints around a set of genomic coordinates — footprint","text":"tibble columns \"group\", \"position\", \"count\", \"enrichment\"","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write BPCells fragment objects — write_fragments_memory","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"BPCells fragments can read/written compressed (bitpacked) uncompressed form variety storage locations: memory (R object), hdf5 file, directory disk (containing binary files).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"","code":"write_fragments_memory(fragments, compress = TRUE)  write_fragments_dir(   fragments,   dir,   compress = TRUE,   buffer_size = 1024L,   overwrite = FALSE )  open_fragments_dir(dir, buffer_size = 1024L)  write_fragments_hdf5(   fragments,   path,   group = \"fragments\",   compress = TRUE,   buffer_size = 8192L,   chunk_size = 1024L,   overwrite = FALSE )  open_fragments_hdf5(path, group = \"fragments\", buffer_size = 16384L)"},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"fragments Input fragments object compress Whether compress data. compression, storage size half size gzip-compressed 10x fragments file. dir Directory read/write data buffer_size performance tuning . number items bufferred memory calling writes disk. overwrite TRUE, write temp dir overwrite existing data. Alternatively, pass temp path string customize temp dir location. path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use chunk_size performance tuning . chunk size used HDF5 array storage.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"Fragment object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragment_io.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write BPCells fragment objects — write_fragments_memory","text":"Saving directory disk good default local analysis, provides best /O performance lowest memory usage. HDF5 format allows saving within existing hdf5 files group data together, memory format provides fastest performance event memory usage unimportant.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if two fragments objects are identical — fragments_identical","title":"Check if two fragments objects are identical — fragments_identical","text":"Check two fragments objects identical","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if two fragments objects are identical — fragments_identical","text":"","code":"fragments_identical(fragments1, fragments2)"},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if two fragments objects are identical — fragments_identical","text":"fragments1 First IterableFragments compare fragments2 Second IterableFragments compare","code":""},{"path":"https://bnprks.github.io/BPCells/reference/fragments_identical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if two fragments objects are identical — fragments_identical","text":"boolean whether fragments objects identical","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Gene Symbol Mapping data — human_gene_mapping","title":"Gene Symbol Mapping data — human_gene_mapping","text":"Mapping canonical gene symbols corresponding unambiguous alias, previous symbol, ensembl ID, entrez ID","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gene Symbol Mapping data — human_gene_mapping","text":"","code":"human_gene_mapping  mouse_gene_mapping"},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Gene Symbol Mapping data — human_gene_mapping","text":"human_gene_mapping named character vector. Names aliases IDs values corresponding canonical gene symbol mouse_gene_mapping named character vector. Names aliases IDs values corresponding canonical gene symbol","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_mapping.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Gene Symbol Mapping data — human_gene_mapping","text":"human_gene_mapping http://ftp.ebi.ac.uk/pub/databases/genenames/hgnc/tsv/non_alt_loci_set.txt mouse_gene_mapping http://www.informatics.jax.org/downloads/reports/MGI_EntrezGene.rpt http://www.informatics.jax.org/downloads/reports/MRK_ENSEMBL.rpt","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":null,"dir":"Reference","previous_headings":"","what":"Gene symbol matching — match_gene_symbol","title":"Gene symbol matching — match_gene_symbol","text":"Correct alias gene symbols, Ensembl IDs, Entrez IDs canonical gene symbols. useful matching gene names different datasets might always use gene naming conventions.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gene symbol matching — match_gene_symbol","text":"","code":"match_gene_symbol(query, subject, gene_mapping = human_gene_mapping)  canonical_gene_symbol(query, gene_mapping = human_gene_mapping)"},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gene symbol matching — match_gene_symbol","text":"query Character vector gene symbols IDs subject Vector gene symbols IDs index gene_mapping Named vector names gene symbols IDs values canonical gene symbols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_matching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gene symbol matching — match_gene_symbol","text":"match_gene_symbol Integer vector indices v subject[v] corresponds gene symbols query canonical_gene_symbol Character vector canonical gene symbols symbol query","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Find gene region — gene_region","title":"Find gene region — gene_region","text":"Conveniently look region gene gene symbol. value returned function can used region argument trackplot functions trackplot_bulk() trackplot_gene()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find gene region — gene_region","text":"","code":"gene_region(   genes,   gene_symbol,   extend_bp = 10000,   gene_mapping = human_gene_mapping )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find gene region — gene_region","text":"genes GRanges, list, data.frame transcript features plot. Required attributes : chr, start, end: genomic position gene_name: Symbol gene ID gene_symbol Name gene symbol ID extend_bp Bases extend region upstream downstream gene gene_mapping Named vector names gene symbols IDs values canonical gene symbols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find gene region — gene_region","text":"list chr, start, end positions use , etc.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"ArchR-style gene activity scores based weighted sum tile according signed distance tile gene body. function calculates signed distances according ArchR's default parameters.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"","code":"gene_score_tiles_archr(   genes,   chromosome_sizes = NULL,   tile_width = 500,   addArchRBug = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"genes GRanges object gene start, end, strand chromosome_sizes (optional) Size chromosomes genomic-ranges object tile_width Size tiles consider addArchRBug Replicate ArchR bug handling nested genes","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"GRanges object one range per tile, additional metadata columns gene_idx (row index gene tile corresponds ) distance. Distance signed distance calculated tile smaller start coordinate gene gene + strand, distance negative calculated min(0, end(tile) - start(gene))","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_score_tiles_archr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate gene-tile distances for ArchR gene activities — gene_score_tiles_archr","text":"ArchR's tile distance algorithm works follows Genes extended 5kb upstream Genes linked tiles 1kb-100kb upstream + downstream, tiles beyond neighboring gene considered Note: assumes 1-based, end inclusive coordinate convention used GRanges, 500bp tiles run bases 1-500, 501-1000, etc.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate GeneActivityScores — gene_score_weights_archr","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"Gene activity scores can calculated distance-weighted sum per-tile accessibility. tile weights gene can represented sparse matrix dimension genes x tiles. multiply weight matrix corresponding tile matrix (tiles x cells), can get gene activity score matrix genes x cells. gene_score_weights_archr() calculates weight matrix (best pre-computed tile matrix), gene_score_archr() provides easy--use wrapper.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"","code":"gene_score_weights_archr(   genes,   chromosome_sizes,   blacklist = NULL,   tile_width = 500,   gene_name_column = \"gene_id\",   addArchRBug = FALSE )  gene_score_archr(   fragments,   genes,   chromosome_sizes,   blacklist = NULL,   tile_width = 500,   gene_name_column = \"gene_id\",   addArchRBug = FALSE,   tile_max_count = 4,   scale_factor = 10000,   tile_matrix_path = tempfile(pattern = \"gene_score_tile_mat\") )"},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"genes GRanges object gene start, end, strand chromosome_sizes genomic-ranges holding start end coordinates chromosome. See read_ucsc_chrom_sizes(). blacklist Blacklist ranges exclude gene calculations. genomic-ranges object (list, data.frame, GRanges) tile_width Size tiles consider gene_name_column NULL, column name genes use row names addArchRBug Replicate ArchR bug handling nested genes fragments Input fragments object tile_max_count Maximum value tile counts matrix. null, tile counts higher clipped tile_max_count. Equivalent ceiling argument ArchR::addGeneScoreMatrix() scale_factor null, counts cell scaled sum scale_factor. Equivalent scaleTo argument ArchR::addGeneScoreMatrix() tile_matrix_path Path directory intermediate tile matrix saved","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"gene_score_weights_archr Weight matrix dimension genes x tiles gene_score_archr Gene score matrix dimension genes x cells.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/gene_scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate GeneActivityScores — gene_score_weights_archr","text":"gene_score_weights_archr Given set tile coordinates distances returned gene_score_tiles_archr(), calculate weight matrix dimensions genes x tiles. matrix can multiplied tile matrix obtain ArchR-compatible gene activity scores.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Genomic range formats — genomic-ranges","title":"Genomic range formats — genomic-ranges","text":"Ranges genomic coordinates given chromosme, start, end coordinate, along optional metadata range. exception GenomicRanges::GRanges objects, BPCells objects assumed use zero-based, end-exclusive coordinate system (see details).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges.html","id":"valid-range-like-objects","dir":"Reference","previous_headings":"","what":"Valid Range-like objects","title":"Genomic range formats — genomic-ranges","text":"BPCells can interpret following types ranges: list(), data.frame(), columns: chr: Character factor chromosome names start: Start coordinates (0-based) end: End coordinates (exclusive) (optional) strand: \"+\"/\"-\" TRUE/FALSE pos/neg strand (optional) Additional metadata named list entries data.frame columns GenomicRanges::GRanges start(x) interpreted 1-based start coordinate end(x) interpreted inclusive end coordinate strand(x): \"*\" entries interpeted postive strand (optional) mcols(x) holds additional metadata character Given format \"chr1:1000-2000\" \"chr1:1,000-2,000\" Uses 0-based, end-exclusive coordinate system used ranges additional metadata required","code":""},{"path":"https://bnprks.github.io/BPCells/reference/genomic-ranges.html","id":"range-coordinate-systems","dir":"Reference","previous_headings":"","what":"Range coordinate systems","title":"Genomic range formats — genomic-ranges","text":"two main conventions coordinate systems: One-based, end-inclusive ranges first base chromosome numbered 1 last base range equal end coordinate e.g. 1-5 describes first 5 bases chromosome Used formats SAM, GTF BPCells, used reading writing GenomicRanges::GRanges objects Zero-based, end-exclusive ranges first base chromosome numbered 0 last base range one less end coordinate e.g. 0-5 describes first 5 bases chromosome Used formats BAM, BED BPCells, used range objects","code":""},{"path":"https://bnprks.github.io/BPCells/reference/iterate_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a wrapped pointer to the iterable matrix — iterate_matrix","title":"Get a wrapped pointer to the iterable matrix — iterate_matrix","text":"Get wrapped pointer iterable matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/iterate_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a wrapped pointer to the iterable matrix — iterate_matrix","text":"","code":"iterate_matrix(x)"},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a knn matrix from reduced dimensions — knn_hnsw","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"Search approximate nearest neighbors cells reduced dimensions (e.g. PCA), return k nearest neighbors (knn) cell. Optionally, can find neighbors two separate sets cells utilizing data query.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"","code":"knn_hnsw(   data,   query = NULL,   k = 10,   metric = c(\"euclidean\", \"cosine\"),   verbose = TRUE,   threads = 1,   ef = 100 )  knn_annoy(   data,   query = data,   k = 10,   metric = c(\"euclidean\", \"cosine\", \"manhattan\", \"hamming\"),   n_trees = 50,   search_k = -1 )"},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"data cell x dims matrix reference dataset query cell x dims matrix query dataset (optional) k number neighbors calculate metric distance metric use verbose whether print progress information search threads Number threads use. Note result non-deterministic threads > 1 ef ef parameter RccppHNSW::hnsw_search. Increase slower search improved accuracy n_trees Number trees index build time. trees gives higher accuracy search_k Number nodes inspect query, -1 default value. Higher number gives higher accuracy","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"List 2 matrices -- idx cell x K neighbor indices, dist cell x K neighbor distances. query given, nearest neighbors found mapping data matrix , prohibiting self-neighbors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get a knn matrix from reduced dimensions — knn_hnsw","text":"knn_hnsw: Use RcppHNSW knn engine knn_annoy: Use RcppAnnoy knn engine","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"K Nearest Neighbor (KNN) Graph — knn_to_graph","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"Convert KNN object (e.g. returned knn_hnsw() knn_annoy()) graph. graph represented sparse adjacency matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"","code":"knn_to_graph(knn, use_weights = FALSE, self_loops = TRUE)  knn_to_snn_graph(knn, min_val = 1/15, self_loops = TRUE)"},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn List 2 matrices -- idx cell x K neighbor indices, dist cell x K neighbor distances use_weights boolean whether replace distance weights 1 self_loops boolean whether allow cells count neighbors min_val minimum jaccard index neighbors. Values round 0","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn_to_graph Sparse matrix (dgCMatrix) mat[,j] = distance cell cell j, 0 cell j K nearest neighbors knn_to_snn_graph Sparse matrix (dgCMatrix) mat[,j] = jaccard index overlap nearest neigbors cell cell j, 0 jaccard index < min_val","code":""},{"path":"https://bnprks.github.io/BPCells/reference/knn_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"K Nearest Neighbor (KNN) Graph — knn_to_graph","text":"knn_to_graph Create knn graph knn_to_snn_graph Convert knn object shared nearest neighbors adjacency matrix. follows algorithm Seurat uses compute SNN graphs","code":""},{"path":"https://bnprks.github.io/BPCells/reference/linear_operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a LinearOperator object — linear_operator","title":"Construct a LinearOperator object — linear_operator","text":"Constructs C++ matrix object save pointer use repeated matrix-vector products bit experimental still internal use","code":""},{"path":"https://bnprks.github.io/BPCells/reference/linear_operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a LinearOperator object — linear_operator","text":"","code":"linear_operator(mat)"},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for marker features — marker_features","title":"Test for marker features — marker_features","text":"Given features x cells matrix, perform one-vs-differential tests find markers.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for marker features — marker_features","text":"","code":"marker_features(mat, groups, method = \"wilcoxon\")"},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for marker features — marker_features","text":"mat IterableMatrix object dimensions features x cells groups Character/factor vector cell groups/clusters. Length #cells method Test method use. Current options : wilcoxon: Wilconxon rank-sum test .k.Mann-Whitney U test","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for marker features — marker_features","text":"tibble following columns: foreground: Group ID used foreground background: Group ID used background (NA comparing rest cells) feature: ID feature p_val_raw: Unadjusted p-value differential test foreground_mean: Average value foreground group background_mean: Average value background group","code":""},{"path":"https://bnprks.github.io/BPCells/reference/marker_features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test for marker features — marker_features","text":"Tips using values function: Use dplyr::mutate() add columns e.g. adjusted p-value log fold change. Use dplyr::filter() get differential genes given threshold get adjusted p-values, use R p.adjust(), recommended method \"BH\" get log2 fold change: input matrix already log-transformed, calculate (foreground_mean - background_mean)/log(2). input matrix log-transformed, calculate log2(forground_mean/background_mean)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask matrix entries to zero\nSet matrix entries to zero given a mask matrix of the\nsame dimensions. Normally, non-zero values in the mask\nwill set the matrix entry to zero. If inverted, zero\nvalues in the mask matrix will set the matrix entry to zero. — mask_matrix","title":"Mask matrix entries to zero\nSet matrix entries to zero given a mask matrix of the\nsame dimensions. Normally, non-zero values in the mask\nwill set the matrix entry to zero. If inverted, zero\nvalues in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"Mask matrix entries zero Set matrix entries zero given mask matrix dimensions. Normally, non-zero values mask set matrix entry zero. inverted, zero values mask matrix set matrix entry zero.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask matrix entries to zero\nSet matrix entries to zero given a mask matrix of the\nsame dimensions. Normally, non-zero values in the mask\nwill set the matrix entry to zero. If inverted, zero\nvalues in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"","code":"mask_matrix(mat, mask, invert = FALSE)"},{"path":"https://bnprks.github.io/BPCells/reference/mask_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask matrix entries to zero\nSet matrix entries to zero given a mask matrix of the\nsame dimensions. Normally, non-zero values in the mask\nwill set the matrix entry to zero. If inverted, zero\nvalues in the mask matrix will set the matrix entry to zero. — mask_matrix","text":"mat Data matrix (IterableMatrix) mask Mask matrix (IterableMatrix dgCMatrix)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcasting vector arithmetic — add_rows","title":"Broadcasting vector arithmetic — add_rows","text":"Convenience functions adding multiplying row / column mtarix number.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcasting vector arithmetic — add_rows","text":"","code":"add_rows(mat, vec)  add_cols(mat, vec)  multiply_rows(mat, vec)  multiply_cols(mat, vec)"},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcasting vector arithmetic — add_rows","text":"mat Matrix-like object vec Numeric vector","code":""},{"path":"https://bnprks.github.io/BPCells/reference/mat_norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcasting vector arithmetic — add_rows","text":"Matrix-like object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","title":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","text":"File objects 0 inputs. transforms 1 input. transforms (e.g. matrix multiplication matrix concatenation) can multiple used primarily know safe clear dimnames intermediate transformed matrices. C++ relies base matrices (non-transform) dimnames, R relies outermost matrix (transform) dimnames.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a list of input matrices to the current matrix (experimental) — matrix_inputs","text":"","code":"matrix_inputs(x)"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write sparse matrices — write_matrix_memory","title":"Read/write sparse matrices — write_matrix_memory","text":"BPCells matrices stored sparse format, meaning non-zero entries stored. Matrices can store integer counts data decimal numbers (float double). See details information.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write sparse matrices — write_matrix_memory","text":"","code":"write_matrix_memory(mat, compress = TRUE)  write_matrix_dir(   mat,   dir,   compress = TRUE,   buffer_size = 8192L,   overwrite = FALSE )  open_matrix_dir(dir, buffer_size = 8192L)  write_matrix_hdf5(   mat,   path,   group,   compress = TRUE,   buffer_size = 8192L,   chunk_size = 1024L,   overwrite = FALSE )  open_matrix_hdf5(path, group, buffer_size = 16384L)"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write sparse matrices — write_matrix_memory","text":"compress Whether compress data. dir Directory save data buffer_size performance tuning . number items buffered memory calling writes disk. overwrite TRUE, write temp dir overwrite existing data. Alternatively, pass temp path string customize temp dir location. path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use chunk_size performance tuning . chunk size used HDF5 array storage. matrix Input matrix, either IterableMatrix dgCMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write sparse matrices — write_matrix_memory","text":"BPCells matrix object","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"storage-locations","dir":"Reference","previous_headings":"","what":"Storage locations","title":"Read/write sparse matrices — write_matrix_memory","text":"Matrices can stored directory disk, memory, HDF5 file. Saving directory disk good default local analysis, provides best /O performance lowest memory usage. HDF5 format allows saving within existing hdf5 files group data together, memory format provides fastest performance event memory usage unimportant.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_io.html","id":"bitpacking-compression","dir":"Reference","previous_headings":"","what":"Bitpacking Compression","title":"Read/write sparse matrices — write_matrix_memory","text":"typical RNA counts matrices holding integer counts, bitpacking compression result 6-8x less space R dgCMatrix, 4-6x smaller scipy csc_matrix. compression effective count values matrix small, rows matrix sorted rowMeans. tests RNA-seq data optimal ordering save 40% storage space. non-integer data row indices compressed, values space savings smaller. non-integer data matrices, bitpacking compression much less effective, can applied indexes entry values. still space savings, far less counts matrices.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate matrix stats — matrix_stats","title":"Calculate matrix stats — matrix_stats","text":"Calculate matrix stats","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate matrix stats — matrix_stats","text":"","code":"matrix_stats(   matrix,   row_stats = c(\"none\", \"nonzero\", \"mean\", \"variance\"),   col_stats = c(\"none\", \"nonzero\", \"mean\", \"variance\") )"},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate matrix stats — matrix_stats","text":"matrix Input matrix object row_stats row statistics compute col_stats col statistics compute","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate matrix stats — matrix_stats","text":"List row_stats: matrix n_stats x n_rows, col_stats: matrix n_stats x n_cols","code":""},{"path":"https://bnprks.github.io/BPCells/reference/matrix_stats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate matrix stats — matrix_stats","text":"statistics calculated single pass matrix, method desirable use efficiency purposes compared standard rowMeans colMeans multiple statistics needed. variance calculated, mean nonzero count included output, mean calculated nonzero count included output.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge cells into pseudobulks — merge_cells","title":"Merge cells into pseudobulks — merge_cells","text":"Peak tile matrix calculations can sped reducing number cells. cases outputs going added together afterwards, can provide performance improvement","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge cells into pseudobulks — merge_cells","text":"","code":"merge_cells(fragments, cell_groups)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge cells into pseudobulks — merge_cells","text":"fragments Input fragments object cell_groups Character factor vector providing group cell. Ordering cellNames(fragments)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for rbind/cbind merging dimnames — merge_dimnames","title":"Helper function for rbind/cbind merging dimnames — merge_dimnames","text":"Helper function rbind/cbind merging dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for rbind/cbind merging dimnames — merge_dimnames","text":"","code":"merge_dimnames(x, y, warning_prefix, dim_type)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge peaks — merge_peaks_iterative","title":"Merge peaks — merge_peaks_iterative","text":"Merge peaks according ArchR's iterative merging algorithm. details : https://www.archrproject.com/bookdown/-iterative-overlap-peak-merging-procedure.html","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge peaks — merge_peaks_iterative","text":"","code":"merge_peaks_iterative(peaks)"},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge peaks — merge_peaks_iterative","text":"peaks data.frame, tibble, list ranges object. Must ordered priority columns chr, start, end.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge peaks — merge_peaks_iterative","text":"`tibble::tibble()`` nonoverlapping subset rows peaks. metadata columns preserved","code":""},{"path":"https://bnprks.github.io/BPCells/reference/merge_peaks_iterative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge peaks — merge_peaks_iterative","text":"Properties merged peaks: peaks merged set overlap Peaks prioritized according order original input output peaks subset input peaks, peak boundaries changed","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Elementwise minimum — min_scalar","title":"Elementwise minimum — min_scalar","text":"min_scalar: Take minumum global constant min_by_row: Take minimum per-row constant min_by_col: Take minimum per-col constant","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elementwise minimum — min_scalar","text":"","code":"min_scalar(mat, val)  min_by_row(mat, vals)  min_by_col(mat, vals)"},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elementwise minimum — min_scalar","text":"mat IterableMatrix val Single positive numeric value","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elementwise minimum — min_scalar","text":"IterableMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/min_elementwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Elementwise minimum — min_scalar","text":"Take minimum value matrix per-row, per-col, global constant. constant must >0 preserve sparsity matrix. effect capping maximum value matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize an object representing genomic ranges — normalize_ranges","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"Normalize object representing genomic ranges","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"","code":"normalize_ranges(   ranges,   metadata_cols = character(0),   zero_based_coords = !is(ranges, \"GRanges\"),   n = 1 )"},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"ranges List, GRanges, data.frame object. Must start, end, chr defined. See genomic-ranges metadata_cols Optional list metadata columns require & extract zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalize_ranges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize an object representing genomic ranges — normalize_ranges","text":"data frame zero-based coordinates, elements chr (factor), start (int), end (int). ranges chr level information, chr levels sorted unique values chr. strand metadata_cols, output strand element TRUE positive strand, FALSE negative strand. (Converted character vector \"+\"/\"-\" necessary)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalized_dimnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","title":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","text":"Helper function set dimnames NULL instead 0-length character vectors","code":""},{"path":"https://bnprks.github.io/BPCells/reference/normalized_dimnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to set dimnames to NULL instead of 0-length character vectors — normalized_dimnames","text":"","code":"normalized_dimnames(row_names, col_names)"},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Count fragments by nucleosomal size — nucleosome_counts","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"Count fragments nucleosomal size","code":""},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"","code":"nucleosome_counts(fragments, nucleosome_width = 147)"},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"fragments Fragments object nucleosome_width Integer cutoff use nucleosome width","code":""},{"path":"https://bnprks.github.io/BPCells/reference/nucleosome_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count fragments by nucleosomal size — nucleosome_counts","text":"List names subNucleosomal, monoNucleosomal, multiNucleosomal containing count vectors fragments class per cell.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write a 10x fragments file — open_fragments_10x","title":"Read/write a 10x fragments file — open_fragments_10x","text":"10x fragment files come bed-like format, columns chr, start, end, cell_id, pcr_duplicates. Unlike standard bed format, format cellranger inclusive end-coordinate, meaning end coordinate counted tagmentation site, rather offset 1.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write a 10x fragments file — open_fragments_10x","text":"","code":"open_fragments_10x(path, comment = \"#\", end_inclusive = TRUE)  write_fragments_10x(   fragments,   path,   end_inclusive = TRUE,   append_5th_column = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write a 10x fragments file — open_fragments_10x","text":"path File path (e.g. fragments.tsv fragments.tsv.gz) comment Skip lines beginning file start comment end_inclusive Whether end coordinate bed inclusive -- .e. insertion end coordinate rather base end coordinate. 10x default, though quite standard bed file format. fragments Input fragments object append_5th_column Whether include 5th column 0 compatibility 10x fragment file outputs (defaults 4 columns chr,start,end,cell)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write a 10x fragments file — open_fragments_10x","text":"10x fragments file object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_fragments_10x.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write a 10x fragments file — open_fragments_10x","text":"open_fragments_10x disk operations take place fragments used function write_fragments_10x Fragments written disk immediately, returned readable object.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"Read/write 10x feature matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"","code":"open_matrix_10x_hdf5(path, feature_type = NULL, buffer_size = 16384L)  write_matrix_10x_hdf5(   mat,   path,   barcodes = colnames(mat),   feature_ids = rownames(mat),   feature_names = rownames(mat),   feature_types = \"Gene Expression\",   feature_metadata = list(),   buffer_size = 16384L,   chunk_size = 1024L )"},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"path Path hdf5 file disk feature_type String vector feature types buffer_size performance tuning . number items buffered memory calling writes disk. mat IterableMatrix barcodes Vector names cells feature_ids Vector IDs features feature_names Vector names features feature_metadata Named list additional metadata vectors store feature chunk_size performance tuning . chunk size used HDF5 array storage.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"BPCells matrix object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_10x_hdf5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/write a 10x feature matrix — open_matrix_10x_hdf5","text":"10x format makes use gzip compression matrix data, can slow read performance. Consider writing another format read performance important . Input matrices must column-major storage order, rownames colnames set, names must provided relevant metadata parameters. metadata parameters read default BPCells, possible export use tools.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":null,"dir":"Reference","previous_headings":"","what":"Read AnnData matrix — open_matrix_anndata_hdf5","title":"Read AnnData matrix — open_matrix_anndata_hdf5","text":"Read sparse integer matrix anndata matrix hdf5 file.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read AnnData matrix — open_matrix_anndata_hdf5","text":"","code":"open_matrix_anndata_hdf5(path, group = \"X\", buffer_size = 16384L)"},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read AnnData matrix — open_matrix_anndata_hdf5","text":"path Path hdf5 file disk group group within hdf5 file write data . writing existing hdf5 file group must already use buffer_size performance tuning . number items buffered memory calling writes disk.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read AnnData matrix — open_matrix_anndata_hdf5","text":"AnnDataMatrixH5 object, cells columns.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/open_matrix_anndata_hdf5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read AnnData matrix — open_matrix_anndata_hdf5","text":"Since AnnData stores RNA matrices cells x genes, whereas BPCells stores RNA matrices genes x cells, returned matrix transposed relative native AnnData matrix.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Get end-sorted ordering for genome ranges — order_ranges","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"Use function order regioins prior calling peak_matrix() tile_matrix().","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"","code":"order_ranges(ranges, chr_levels, sort_by_end = TRUE)"},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"ranges List, GRanges, data.frame object. Must start, end, chr defined. See genomic-ranges chr_levels Ordering chromosome names sort_by_end TRUE (defualt), sort (chr, end, start). Else sort (chr, start, end)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/order_ranges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get end-sorted ordering for genome ranges — order_ranges","text":"Numeric vector analagous order function. Provides index selection reorder input ranges sorted chr, end, start","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ranges x cells overlap matrix — peak_matrix","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"Calculate ranges x cells overlap matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"","code":"peak_matrix(   fragments,   ranges,   mode = c(\"insertions\", \"fragments\", \"overlaps\"),   zero_based_coords = !is(ranges, \"GRanges\"),   explicit_peak_names = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"fragments Input fragments object. Must cell names chromosome names defined ranges GRanges object ranges overlap, list/data frame columns chr, start, & end. mode Mode counting peak overlaps. (See \"value\" section details) zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see http://genome.ucsc.edu/blog/-ucsc-genome-browser-coordinate-counting-systems/) explicit_peak_names Boolean whether add rownames output matrix format e.g chr1:500-1000, start end coords given 0-based coordinate system. Note either way, peak names written matrix saved.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"Iterable matrix object dimension ranges x cells. saved, column names output matrix format chr1:500-1000, start end coords given 0-based coordinate system. mode options \"insertions\": Start end coordinates separately overlapped peak \"fragments\": Like \"insertions\", fragment can contribute 1 count peak, even start end coordinates overlap \"overlaps\": Like \"fragments\", overlap also counted fragment fully spans peak even neither start end falls within peak","code":""},{"path":"https://bnprks.github.io/BPCells/reference/peak_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate ranges x cells overlap matrix — peak_matrix","text":"calculating matrix directly fragments tsv, necessary first call select_chromosomes order provide ordering chromosomes expect reading tsv.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":null,"dir":"Reference","previous_headings":"","what":"Dotplot — plot_dot","title":"Dotplot — plot_dot","text":"Plot feature levels per group cluster grid dots. Dots colored z-score normalized average expression, sized percent non-zero.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dotplot — plot_dot","text":"","code":"plot_dot(   source,   features,   groups,   group_order = NULL,   gene_mapping = human_gene_mapping,   colors = c(\"lightgrey\", \"#4682B4\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dotplot — plot_dot","text":"source Feature x cell matrix data.frame features. best results, features sparse log-normalized (e.g. run log1p() zero raw counts map zero) features Character vector features plot groups Vector one entry per cell, specifying cell's group group_order Optional vector listing ordering groups gene_mapping optional vector gene name matching match_gene_symbol(). colors Color scale plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot UMAP or embeddings — plot_embedding","title":"Plot UMAP or embeddings — plot_embedding","text":"Plot one features coloring cells UMAP plot.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot UMAP or embeddings — plot_embedding","text":"","code":"plot_embedding(   source,   embedding,   features = NULL,   quantile_range = c(0.01, 0.99),   randomize_order = TRUE,   smooth = NULL,   smooth_rounds = 3,   gene_mapping = human_gene_mapping,   size = NULL,   rasterize = FALSE,   raster_pixels = 512,   legend_continuous = c(\"auto\", \"quantile\", \"value\"),   labels_quantile_range = TRUE,   colors_continuous = c(\"lightgrey\", \"#4682B4\"),   legend_discrete = TRUE,   labels_discrete = TRUE,   colors_discrete = discrete_palette(\"stallion\"),   return_data = FALSE,   return_plot_list = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot UMAP or embeddings — plot_embedding","text":"source Matrix, data frame pull features , vector feature values single feature. matrix, features must rows. embedding matrix dimensions cells x 2 embedding coordinates features Character vector features plot source vector. quantile_range (optional) Length 2 vector giving quantiles clip minimum maximum color scale values, fractions 0 1. NULL NA values skip clipping randomize_order TRUE, shuffle cells prevent overplotting biases. Can pass integer instead specify random seed use. smooth (optional) Sparse matrix dimensions cells x cells cell-cell distance weights smoothing. smooth_rounds Number multiplication rounds apply smoothing. gene_mapping optional vector gene name matching match_gene_symbol(). Ignored source data frame. size Point size plotting rasterize Whether rasterize point drawing speed display graphics programs. raster_pixels Number pixels use rasterizing. Can provide one number square dimensions, two numbers width x height. legend_continuous Whether label continuous features quantile value. \"auto\" labels quantile features continuous quantile_range NULL. Quantile labeling adds text annotation listing range displayed values. labels_quantile_range Whether add text label value range feature legend set quantile colors_continuous Vector colors use continuous color palette legend_discrete Whether show legend discrete (categorical) features. labels_discrete Whether add text labels center group discrete (categorical) features. colors_discrete Vector colors use discrete (categorical) features. return_data true, return data just plotting rather plot. return_plot_list TRUE, return multiple plots list, rather single plot combined using patchwork::wrap_plots() apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot UMAP or embeddings — plot_embedding","text":"default, returns ggplot2 object requested features plotted grid. return_data return_plot_list called, return value match argument.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_embedding.html","id":"smoothing","dir":"Reference","previous_headings":"","what":"Smoothing","title":"Plot UMAP or embeddings — plot_embedding","text":"Smoothing performed follows: first, smoothing matrix normalized sum incoming weights every cell 1. , raw data values repeatedly multiplied smoothing matrix re-scaled average value stays .","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Fragment size distribution — plot_fragment_length","title":"Fragment size distribution — plot_fragment_length","text":"Plot distribution fragment lengths, length basepairs x-axis, proportion fragments y-axis. Typical plots show 10-basepair periodicity, well humps spaced multiples nucleosome width (150bp).","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fragment size distribution — plot_fragment_length","text":"","code":"plot_fragment_length(   fragments,   max_length = 500,   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fragment size distribution — plot_fragment_length","text":"fragments Fragments object max_length Maximum length show plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_fragment_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fragment size distribution — plot_fragment_length","text":"Numeric vector index contans number length-fragments","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":null,"dir":"Reference","previous_headings":"","what":"Knee plot of single cell read counts — plot_read_count_knee","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"Plots read count rank vs. number reads log-log scale.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"","code":"plot_read_count_knee(   read_counts,   cutoff = NULL,   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"read_counts Vector read counts per cell cutoff (optional) Read cutoff mark plot return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"ggplot2 plot object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_read_count_knee.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knee plot of single cell read counts — plot_read_count_knee","text":"Performs logarithmic downsampling reduce number points plotted","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TF footprint — plot_tf_footprint","title":"Plot TF footprint — plot_tf_footprint","text":"Plot footprinting around TF motif sites","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TF footprint — plot_tf_footprint","text":"","code":"plot_tf_footprint(   fragments,   motif_positions,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   flank = 250L,   smooth = 0L,   zero_based_coords = !is(genes, \"GRanges\"),   colors = discrete_palette(\"stallion\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tf_footprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TF footprint — plot_tf_footprint","text":"fragments IterableFragments object motif_positions Coordinate ranges motifs (must include strand) constant width cell_groups Character factor assigning group cell, order cellNames(fragments) flank Number flanking basepairs include either side motif smooth (optional) Sparse matrix dimensions cells x cells cell-cell distance weights smoothing. zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TSS profile — plot_tss_profile","title":"Plot TSS profile — plot_tss_profile","text":"Plot enrichmment insertions relative transcription start sites (TSS). Typically, plot shows strong enrichment insertions near TSS, small bump downstream around 220bp downstream TSS +1 nucleosome.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TSS profile — plot_tss_profile","text":"","code":"plot_tss_profile(   fragments,   genes,   cell_groups = rlang::rep_along(cellNames(fragments), \"all\"),   flank = 2000L,   smooth = 0L,   zero_based_coords = !is(genes, \"GRanges\"),   colors = discrete_palette(\"stallion\"),   return_data = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TSS profile — plot_tss_profile","text":"fragments IterableFragments object genes Coordinate ranges genes (must include strand) cell_groups Character factor assigning group cell, order cellNames(fragments) flank Number flanking basepairs include either side motif smooth Number bases smooth (rolling average) zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range return_data true, return data just plotting rather plot. apply_styling false, return plot without pretty styling applied","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":null,"dir":"Reference","previous_headings":"","what":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"Density scatter plot log10(fragment_count) x-axis TSS enrichment y-axis. plot useful select cell barcodes experiment correspond high-quality cells","code":""},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"","code":"plot_tss_scatter(   atac_qc,   min_frags = NULL,   min_tss = NULL,   bins = 100,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/plot_tss_scatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TSS Enrichment vs. Fragment Counts plot — plot_tss_scatter","text":"atac_qc Tibble returned qc_scATAC(). Must columns nFrags TSSEnrichment min_frags Minimum fragment count cutoff min_tss Minimum TSS Enrichment cutoff bins Number bins density calculation apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename cells by adding a prefix to the names (e.g. sample name) — prefix_cell_names","title":"Rename cells by adding a prefix to the names (e.g. sample name) — prefix_cell_names","text":"Rename cells adding prefix names (e.g. sample name)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename cells by adding a prefix to the names (e.g. sample name) — prefix_cell_names","text":"","code":"prefix_cell_names(fragments, prefix)"},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename cells by adding a prefix to the names (e.g. sample name) — prefix_cell_names","text":"fragments Input fragments object. prefix String add prefix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/prefix_cell_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename cells by adding a prefix to the names (e.g. sample name) — prefix_cell_names","text":"Fragments object prefixed names","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"Calculate ArchR-compatible per-cell QC statistics","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"","code":"qc_scATAC(fragments, genes, blacklist)"},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"fragments IterableFragments object genes GenomicRanges object list/data.frame columns chr, start, end blacklist GenomicRanges object list/data.frame columns chr, start, end","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"data.frame QC data","code":""},{"path":"https://bnprks.github.io/BPCells/reference/qc_scATAC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate ArchR-compatible per-cell QC statistics — qc_scATAC","text":"implementation mimics ArchR's default parameters. uses requiring flexibility tweak default parameters, best option re-implement function required changes. Output columns data.frame: cellName: cell name cell nFrags: number fragments per cell subNucleosomal, monoNucleosomal, multiNucleosomal: number fragments size 1-146bp, 147-254bp, 255bp + respectively. equivalent ArchR's nMonoFrags, nDiFrags, nMultiFrags respectively TSSEnrichment: AvgInsertInTSS / max(AvgInsertFlankingTSS, 0.1), AvgInsertInTSS ReadsInTSS / 101 (window size), AvgInsertFlankingTSS ReadsFlankingTSS / (100*2) (window size). max(0.1) ensures low-read cells get assigned spuriously high TSSEnrichment. ReadsInPromoter: Number reads 2000bp upstream TSS 101bp downstream TSS ReadsInBlacklist: Number reads provided blacklist region ReadsInTSS: Number reads overlapping 101bp centered around TSS ReadsFlankingTSS: Number reads overlapping 1901-2000bp +/- TSS Differences ArchR: Note ArchR default uses different set annotations derive TSS sites promoter sites. function uses just one annotation gene start+end sites, must called twice exactly re-calculate ArchR QC stats. ArchR's PromoterRatio BlacklistRatio included output, can easily calculated ReadsInPromoter / nFrags  ReadsInBlacklist / nFrags. Similarly, ArchR's NucleosomeRatio can calculated (monoNucleosomal + multiNucleosomal) / subNucleosomal.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":null,"dir":"Reference","previous_headings":"","what":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"Given set genomic ranges, find distance nearest neighbors upstream downstream.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"","code":"range_distance_to_nearest(   ranges,   addArchRBug = FALSE,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"ranges List, GRanges, data.frame object. Must chr, start, end, strand defined. See genomic-ranges addArchRBug boolean reproduce ArchR's bug incorrectly handles nested genes zero_based_coords true, coordinates start 0 end coordinate included range. false, coordinates start 1 end coordinate included range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/range_distance_to_nearest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find signed distance to nearest genomic ranges — range_distance_to_nearest","text":"2-column data.frame columns upstream downstream, containing distances nearest neighbor respective directions. ranges + * strand, distance calculated : upstream = max(start(range) - end(upstreamNeighbor), 0) downstream = max(start(downstreamNeighbor) - end(range), 0) ranges - strand, definition upstream downstream flipped. Note definition distance one GenomicRanges::distance(), ranges neighbor overlap given distance 1 rather 0.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank-transform a matrix — rank_transform","title":"Rank-transform a matrix — rank_transform","text":"Rank values within row/col matrix, output rank values new matrix. Rank values offset rank 0 value 0, ties handled averaging ranks.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank-transform a matrix — rank_transform","text":"","code":"rank_transform(mat, axis)"},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank-transform a matrix — rank_transform","text":"mat Data matrix (IterableMatrix) axis Axis rank values within. \"col\" rank values within column, \"row\" rank values within row.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rank_transform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank-transform a matrix — rank_transform","text":"Note efficient rank calculation depends storage order matrix, may necessary call transpose_storage_order()","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a bed file into a data frame — read_bed","title":"Read a bed file into a data frame — read_bed","text":"Bed files can contain peak blacklist annotations. utilities help read thos annotations","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a bed file into a data frame — read_bed","text":"","code":"read_bed(   path,   additional_columns = character(0),   backup_url = NULL,   timeout = 300 )  read_encode_blacklist(   dir,   genome = c(\"hg38\", \"mm10\", \"hg19\", \"dm6\", \"dm3\", \"ce11\", \"ce10\"),   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a bed file into a data frame — read_bed","text":"path Path file (desired save location backup_url used) additional_columns Names additional columns bed file backup_url path exist, provides URL download gtf timeout Maximum time seconds wait download backup_url dir Output directory cache downloaded gtf file genome genome name","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a bed file into a data frame — read_bed","text":"Data frame coordinates using 0-based convention.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_bed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a bed file into a data frame — read_bed","text":"read_bed Read bed file disk url. read_encode_blacklist Downloads Boyle Lab blacklist, described https://doi.org/10.1038/s41598-019-45839-z","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":null,"dir":"Reference","previous_headings":"","what":"Read GTF gene annotations — read_gtf","title":"Read GTF gene annotations — read_gtf","text":"Read gene annotations gtf format data frame. source can URL, gtf file disk, gencode release version.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read GTF gene annotations — read_gtf","text":"","code":"read_gtf(   path,   attributes = c(\"gene_id\"),   tags = character(0),   features = c(\"gene\"),   keep_attribute_column = FALSE,   backup_url = NULL,   timeout = 300 )  read_gencode_genes(   dir,   release = \"latest\",   annotation_set = c(\"basic\", \"comprehensive\"),   gene_type = \"lncRNA|protein_coding|IG_.*_gene|TR_.*_gene\",   attributes = c(\"gene_id\", \"gene_type\", \"gene_name\"),   tags = character(0),   features = c(\"gene\"),   timeout = 300 )  read_gencode_transcripts(   dir,   release = \"latest\",   transcript_choice = c(\"MANE_Select\", \"Ensembl_Canonical\", \"all\"),   annotation_set = c(\"basic\", \"comprehensive\"),   gene_type = \"lncRNA|protein_coding|IG_.*_gene|TR_.*_gene\",   attributes = c(\"gene_id\", \"gene_type\", \"gene_name\", \"transcript_id\"),   features = c(\"transcript\", \"exon\"),   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read GTF gene annotations — read_gtf","text":"path Path file (desired save location backup_url used) attributes Vector GTF attribute names parse columns tags Vector tags parse boolean presence/absence features List features types keep GTF (e.g. gene, transcript, exon, intron) keep_attribute_column Boolean whether preserve raw attribute text column backup_url path exist, provides URL download gtf timeout Maximum time seconds wait download backup_url dir Output directory cache downloaded gtf file release release version (prefix M mouse versions). recent version, use \"latest\" \"latest_mouse\" annotation_set Either \"basic\" \"comprehensive\" annotation sets (see details section). gene_type Regular expression gene types keep. Defaults protein_coding, lncRNA, IG/TR genes transcript_choice Method selecting representative transcripts. Choices : MANE_Select: human-, conservative Ensembl_Canonical: human+mouse, superset MANE_Select human : Preserve transcript models (recommended plotting)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read GTF gene annotations — read_gtf","text":"Data frame coordinates using 0-based convention. Columns : chr source feature start end score strand frame attributes (optional; named according listed attributes) tags (named according listed tags)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_gtf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read GTF gene annotations — read_gtf","text":"read_gtf Read gtf file URL read_gencode_genes Read gene annotations directly GENCODE. file name vary depending release annotation set requested, format gencode.v42.annotation.gtf.gz. GENCODE currently recommends basic set: https://www.gencodegenes.org/human/. release 42, comprehensive basic sets identical gene-level annotations, comprehensive set additional transcript variants annotated. read_gencode_transcripts Read transcript models GENCODE, use trackplot_gene()","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/reference/read_ucsc_chrom_sizes.html","id":null,"dir":"Reference","previous_headings":"","what":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","title":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","text":"Read chromosome sizes UCSC return tibble one row per chromosome. underlying data pulled : https://hgdownload.soe.ucsc.edu/downloads.html","code":""},{"path":"https://bnprks.github.io/BPCells/reference/read_ucsc_chrom_sizes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read UCSC chromosome sizes — read_ucsc_chrom_sizes","text":"","code":"read_ucsc_chrom_sizes(   dir,   genome = c(\"hg38\", \"mm39\", \"mm10\", \"mm9\", \"hg19\"),   keep_chromosomes = \"chr[0-9]+|chrX|chrY\",   timeout = 300 )"},{"path":"https://bnprks.github.io/BPCells/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. Matrix colMeans, colSums, rowMeans, rowSums, t","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate ggplot x axis labels — rotate_x_labels","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"Rotate ggplot x axis labels","code":""},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"","code":"rotate_x_labels(degrees = 45)"},{"path":"https://bnprks.github.io/BPCells/reference/rotate_x_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate ggplot x axis labels — rotate_x_labels","text":"degrees Number degrees rotate ","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"Scan fragments without performing operations (used benchmarking)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"","code":"scan_fragments(fragments)"},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"fragments Fragments object scan","code":""},{"path":"https://bnprks.github.io/BPCells/reference/scan_fragments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scan through fragments without performing any operations (used for benchmarking) — scan_fragments","text":"Length 4 vector fragment count, sums chr, starts, ends","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":null,"dir":"Reference","previous_headings":"","what":"SCTransform Pearson Residuals — sctransform_pearson","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"Calculate pearson residuals negative binomial sctransform model. Normalized values calculated (X - mu) / sqrt(mu + mu^2/theta). mu calculated cell_read_counts * gene_beta.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"","code":"sctransform_pearson(   mat,   gene_theta,   gene_beta,   cell_read_counts,   min_var = -Inf,   clip_range = c(-10, 10),   columns_are_cells = TRUE,   slow = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"mat IterableMatrix (raw counts) gene_theta Vector per-gene thetas (overdispersion values) gene_beta Vector per-gene betas (expression level values) cell_read_counts Vector total reads per (umi count RNA) min_var Minimum value clipping variance clip_range Length 2 vector min max clipping range columns_are_cells Whether columns matrix correspond cells (default) genes slow TRUE, use 10x slower precise implementation (default FALSE)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"IterableMatrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/sctransform_pearson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SCTransform Pearson Residuals — sctransform_pearson","text":"parameterization used somewhat simplified compared original SCTransform paper, particular uses linear-scale rather log-scale represent cell_read_counts gene_beta variables. also support addition arbitrary cell metadata (e.g. batch) add negative binomial regression.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Select cells for subsetting or translating cells IDs in a fragments object — select_cells","title":"Select cells for subsetting or translating cells IDs in a fragments object — select_cells","text":"Select cells subsetting translating cells IDs fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select cells for subsetting or translating cells IDs in a fragments object — select_cells","text":"","code":"select_cells(fragments, cell_selection)"},{"path":"https://bnprks.github.io/BPCells/reference/select_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select cells for subsetting or translating cells IDs in a fragments object — select_cells","text":"fragments Input fragments object cell_selection List chromosme IDs (numeric), names (character). output cell ID n`` taken input cell ID/name cell_selectionn`.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Select chromosmes for subsetting or translating chromosome IDs in a fragments object — select_chromosomes","title":"Select chromosmes for subsetting or translating chromosome IDs in a fragments object — select_chromosomes","text":"Select chromosmes subsetting translating chromosome IDs fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select chromosmes for subsetting or translating chromosome IDs in a fragments object — select_chromosomes","text":"","code":"select_chromosomes(fragments, chromosome_selection)"},{"path":"https://bnprks.github.io/BPCells/reference/select_chromosomes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select chromosmes for subsetting or translating chromosome IDs in a fragments object — select_chromosomes","text":"fragments Input fragments object chromosome_selection List chromosme IDs (numeric), names (character). output chromosome ID n taken input fragments chromosome ID/name chromosome_selectionn.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Select fragments overlapping (or not overlapping) selected regions — select_regions","title":"Select fragments overlapping (or not overlapping) selected regions — select_regions","text":"Select fragments overlapping (overlapping) selected regions","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select fragments overlapping (or not overlapping) selected regions — select_regions","text":"","code":"select_regions(   fragments,   ranges,   invert_selection = FALSE,   zero_based_coords = !is(ranges, \"GRanges\") )"},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select fragments overlapping (or not overlapping) selected regions — select_regions","text":"fragments Input fragments object. ranges GRanges object ranges overlap, list/data frame columns chr, start, & end. invert_selection TRUE, select fragments overlapping selected regions instead fragments overlapping selected regions. zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see http://genome.ucsc.edu/blog/-ucsc-genome-browser-coordinate-counting-systems/)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/select_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select fragments overlapping (or not overlapping) selected regions — select_regions","text":"Fragments object filtered according selected regions","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift start or end coordinates — shift_fragments","title":"Shift start or end coordinates — shift_fragments","text":"Shifts start end fragments fixed amount, can useful correct Tn5 offset.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift start or end coordinates — shift_fragments","text":"","code":"shift_fragments(fragments, shift_start = 0L, shift_end = 0L)"},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift start or end coordinates — shift_fragments","text":"fragments Input fragments object shift_start many basepairs shift start coords shift_end many basepairs shift end coords","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift start or end coordinates — shift_fragments","text":"Shifted fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/shift_fragments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shift start or end coordinates — shift_fragments","text":"correct Tn5 offset +/- 4bp since Tn5 cut sites opposite strands offset 9bp. However, +4/-5 bp often applied bed-format files, since end coordinate bed files 1 past last basepair sequenced DNA fragment. results bed-like format except inclusive end coordinates.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset fragments to only include those in a given size range — subset_lengths","title":"Subset fragments to only include those in a given size range — subset_lengths","text":"Subset fragments include given size range","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset fragments to only include those in a given size range — subset_lengths","text":"","code":"subset_lengths(fragments, min_len = 0L, max_len = NA_integer_)"},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset fragments to only include those in a given size range — subset_lengths","text":"fragments Input fragments object min_len Minimum bases fragment (inclusive) max_len Maximum bases fragment (inclusive)","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset fragments to only include those in a given size range — subset_lengths","text":"Fragments object","code":""},{"path":"https://bnprks.github.io/BPCells/reference/subset_lengths.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subset fragments to only include those in a given size range — subset_lengths","text":"Fragment length calculated end-start","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate ranges x cells tile overlap matrix — tile_matrix","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"Calculate ranges x cells tile overlap matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"","code":"tile_matrix(   fragments,   ranges,   zero_based_coords = !is(ranges, \"GRanges\"),   explicit_tile_names = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"fragments Input fragments object ranges GRanges object ranges overlap including metadata column tile_width, list/data frame columns chr, start, end, tile_width. Must non-overlapping sorted (chr, start), chromosomes ordered according chromosome names fragments zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see http://genome.ucsc.edu/blog/-ucsc-genome-browser-coordinate-counting-systems/) explicit_tile_names Boolean whether add rownames output matrix format e.g chr1:500-1000, start end coords given 0-based coordinate system. whole-genome Tile matrices names take ~5 seconds generate take 400MB memory. Note either way, tile names written matrix saved.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"Iterable matrix object dimension ranges x cells. saved, column names format chr1:500-1000, start end coords given 0-based coordinate system.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate ranges x cells tile overlap matrix — tile_matrix","text":"calculating matrix directly fragments tsv, necessary first call select_chromosomes order provide ordering chromosomes expect reading tsv.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","title":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","text":"Get ranges corresponding selected tiles tile matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/tile_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ranges corresponding to selected tiles of a tile matrix — tile_ranges","text":"","code":"tile_ranges(tile_matrix, selection)"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudobulk trackplot — trackplot_bulk","title":"Pseudobulk trackplot — trackplot_bulk","text":"Plot pseudobulk genome track, showing number fragment insertions across region.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pseudobulk trackplot — trackplot_bulk","text":"","code":"trackplot_bulk(   fragments,   region,   groups,   cell_read_counts,   group_order = NULL,   bins = 200,   clip_quantile = 0.999,   colors = discrete_palette(\"stallion\"),   legend_label = \"group\",   zero_based_coords = !is(region, \"GRanges\"),   return_data = FALSE,   return_plot_list = FALSE,   apply_styling = TRUE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pseudobulk trackplot — trackplot_bulk","text":"fragments Fragments object region GRanges length 1 region plot, list/data.frame one entry chr, start, end. See gene_region() genomic-ranges details groups Vector one entry per cell, specifying cell's group cell_read_counts Numeric vector read counts cell (used normalization) group_order Optional vector listing ordering groups bins Number bins plot across region clip_quantile (optional) Quantile values clipping y-axis limits. Default 0.999 crop just extreme outliers across region. NULL disable clipping colors Character vector color values (optionally named group) legend_label Custom label put legend zero_based_coords Whether convert ranges 1-based end-inclusive coordinate system 0-based end-exclusive coordinate system. Defaults true GRanges false formats (see http://genome.ucsc.edu/blog/-ucsc-genome-browser-coordinate-counting-systems/) return_data true, return data just plotting rather plot. return_plot_list TRUE, return multiple plots list, rather single plot combined using patchwork::wrap_plots() apply_styling false, return plot without pretty styling applied","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_bulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pseudobulk trackplot — trackplot_bulk","text":"Returns combined plot pseudobulk genome tracks. compatability draw_trackplot_grid()``, extra attribute $patches$labelswill added specify labels track. Ifreturn_dataorreturn_plot_listisTRUE`, return value modified accordingly.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot transcript models — trackplot_gene","title":"Plot transcript models — trackplot_gene","text":"Plot transcript models","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot transcript models — trackplot_gene","text":"","code":"trackplot_gene(   transcripts,   region,   exon_size = 3,   gene_size = 1,   label_size = 3,   return_data = FALSE )"},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot transcript models — trackplot_gene","text":"transcripts GRanges, list, data.frame transcript features plot. Required attributes : chr, start, end: genomic position strand: \"+\"/\"-\" TRUE/FALSE positive negative strand feature (entries marked \"transcript\" \"exon\" considered) transcript_id gene_name See genomic-ranges details region GRanges length 1 region plot, list/data.frame one entry chr, start, end. See gene_region() genomic-ranges details exon_size size exon lines label_size size transcript labels return_data true, return data just plotting rather plot. labels Character vector labels item transcripts. NA items labeled transcript_size size transcript lines","code":""},{"path":"https://bnprks.github.io/BPCells/reference/trackplot_gene.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot transcript models — trackplot_gene","text":"Plot gene locations","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose the storage order for a matrix — transpose_storage_order","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"Transpose storage order matrix","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"","code":"transpose_storage_order(   matrix,   outdir = tempfile(\"transpose\"),   tmpdir = tempdir(),   load_bytes = 4194304L,   sort_bytes = 1073741824L )"},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"matrix Input matrix outdir Directory store output tmpdir Temporary directory use intermediate storage load_bytes minimum contiguous load size merge sort passes sort_bytes amount memory allocate re-sorting chunks entries","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"MatrixDir object copy input matrix, storage order flipped","code":""},{"path":"https://bnprks.github.io/BPCells/reference/transpose_storage_order.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose the storage order for a matrix — transpose_storage_order","text":"re-sorts entries matrix change storage order row-major col-major. large matrices, can slow -- around 2 minutes transpose 500k cell RNA-seq matrix default load_bytes (4MiB) sort_bytes (1GiB) parameters allow ~85GB data sorted two passes data, ~7.3TB data sorted three passes data.","code":""},{"path":"https://bnprks.github.io/BPCells/reference/wrapFragments.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap an inner XPtrList with an outer externalptr object (Rcpp::XPtr) — wrapFragments","title":"Wrap an inner XPtrList with an outer externalptr object (Rcpp::XPtr) — wrapFragments","text":"also track type current pointer provide little safety converting C++. WARNING: Always make sure pass correct inner object, passed chain pointers broken C++ objects freed random GC still using . pass inner=new(\"XPtrList\") C++ object wrapping fragments/matrices","code":""},{"path":"https://bnprks.github.io/BPCells/reference/wrapFragments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap an inner XPtrList with an outer externalptr object (Rcpp::XPtr) — wrapFragments","text":"","code":"wrapFragments(outer, inner)"},{"path":"https://bnprks.github.io/BPCells/reference/wrapMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","title":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","text":"Helps avoid duplicate storage dimnames","code":""},{"path":"https://bnprks.github.io/BPCells/reference/wrapMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an S4 matrix object wrapping another matrix object — wrapMatrix","text":"","code":"wrapMatrix(class, m, ...)"},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bpcells-10-roadmap","dir":"Changelog","previous_headings":"","what":"BPCells 1.0 Roadmap","title":"BPCells 1.0 Roadmap","text":"Parallelization Native python library (re-using C++ backend) Peak-gene correlations MACS peak calling Contributions welcome :)","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"features-0-2-0","dir":"Changelog","previous_headings":"","what":"Features","title":"BPCells 0.2.0 (unreleased - github main branch)","text":"Merging fragments c() now handles inputs mismatched chromosome names.","code":""},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug-fixes","title":"BPCells 0.2.0 (unreleased - github main branch)","text":"Fixed fragment transforms using chrNames(frags) <- val cellNames(frags) <- val cause downstream errors.","code":""},{"path":[]},{"path":"https://bnprks.github.io/BPCells/news/index.html","id":"features-0-1-0","dir":"Changelog","previous_headings":"","what":"Features","title":"BPCells 0.1.0","text":"Reading/writing 10x fragment files disk Reading/writing compressed fragments disk (folder hdf5 group) Interconversion fragments objects GRanges / data.frame Merging multiple source fragment files transparently run time Calculation Cell x Peak matrices, Cell x Tile matrices ArchR-compatible QC calculations ArchR-compatible gene activity score calculations Filtering fragments chromosmes, cells, lengths, genomic region Fast peak calling approximation via overlapping tiles Conversion /R sparse matrices Read-write access 10x hdf5 feature matrices, read-access AnnData files Reading/writing compressed matrices disk (folder hdf5 group) Support integer single/double-precision floating point matrices disk Fast transposition storage order, switch indexing cell gene/feature. Concatenation multiple source matrix files transparently run time Single-pass calculation row/column mean variance Wilcoxon marker feature calculation Transparent handling vector +, -, *, /, log1p streaming normalization, along less common operations. allows implementation ATAC-seq LSI Seurat default normalization, along published log-based normalizations. SCTransform pearson residual calculation Multiplication sparse matrices Read count knee cutoffs UMAP embeddings Dot plots Transcription factor footprinting / TSS profile plotting Fragments vs. TSS Enrichment ATAC-seq QC plot Pseudobulk genome track plots, gene annotation plots Matching gene symbols/IDs canonical symbols Download transcript annotations Gencode GTF files Download + parse UCSC chromosome sizes Parse peak files BED format; Download ENCODE blacklist region Wrappers knn graph calculation + clustering Note: operations interoperate storage formats. example, matrix operations can applied directly AnnData 10x matrix file. many cases bitpacking-compressed formats provide performance/space advantages, required use computations.","code":""}]
